#+TITLE: Functional Programming for Mortals with Scalaz
#+AUTHOR: Sam Halliday
#+DATE: 2017

#+STARTUP: showall
#+TAGS: ME OTHER
#+TODO: TODO | RESEARCH | NOTES | CHART | DIAGRAM | DRAWING | CODE | VIDEO
#+OPTIONS: toc:nil

# Σ ⊣ Δ ⊣ Π

* Frontmatter                                                         :final:
:PROPERTIES:
:EXPORT_FILE_NAME: frontmatter.md
:END:
{frontmatter}

#+BEGIN_QUOTE
"Love is wise; hatred is foolish. In this world, which is getting more
and more closely interconnected, we have to learn to tolerate each
other, we have to learn to put up with the fact that some people say
things that we don't like. We can only live together in that way. But
if we are to live together, and not die together, we must learn a kind
of charity and a kind of tolerance, which is absolutely vital to the
continuation of human life on this planet."

― Bertrand Russell
#+END_QUOTE

** About This Book

This book is for the typical Scala developer, probably with a Java background,
who is both sceptical and curious about the *Functional Programming* (FP)
paradigm. This book justifies every concept with practical examples, including
writing a web application.

There are many ways to do Functional Programming in Scala. This book uses [[https://github.com/scalaz/scalaz][scalaz
7.2]], the most popular, stable, principled and comprehensive framework. You could
instead use the Cats political fork of scalaz, or roll your own framework.

This book is designed to be read from cover to cover, in the order presented,
with a rest between chapters. Earlier chapters encourage coding styles that we
will later discredit: similar to how we learn Newton's theory of gravity as
children, and progress to Riemann / Einstein / Maxwell if we become students of
physics.

A computer is not necessary to follow along, although we hope that you will gain
the confidence to independently study the scalaz source code. Some of the more
complex code snippets are available with [[https://bitbucket.org/fommil/fpmortals/src/][the book's source code]] and those who
want practical exercises are encouraged to (re-)implement scalaz (and the
example application) using the partial descriptions presented in this book.

We also recommend [[https://www.manning.com/books/functional-programming-in-scala][The Red Book]] as further reading. It teaches how to write an FP
library in Scala from first principles. Try to attend a Fantasyland Institute of
Learning training course if you can.

** Copyleft Notice

This book is *Libre* and follows the philosophy of [[https://www.gnu.org/philosophy/free-sw.en.html][Free Software]]: you can use
this book as you like, the [[https://bitbucket.org/fommil/fpmortals/src/][source is available]], you can redistribute this book
and you can distribute your own version. That means you can print it, photocopy
it, e-mail it, upload it to websites, change it, translate it, charge for it,
remix it, delete bits, and draw all over it.

This book is *Copyleft*: if you change the book and distribute your own version,
you must also pass these freedoms to its recipients.

This book uses the [[https://creativecommons.org/licenses/by-sa/4.0/legalcode][Creative Commons Attribution ShareAlike 4.0 International]] (CC
BY-SA 4.0) license.

All original code snippets in this book are separately [[https://wiki.creativecommons.org/wiki/CC0][CC0]] licensed, you may use
them without restriction. Excerpts from =scalaz= and related libraries maintain
their license, reproduced in full in the appendix.

The example application =drone-dynamic-agents= is distributed under the terms of
the [[https://www.gnu.org/licenses/gpl-3.0.en.html][GPLv3]]: only the snippets in this book are available without restriction.

** Thanks

Diego Esteban Alonso Blas, Raúl Raja Martínez and Peter Neyens of 47
degrees, Rúnar Bjarnason, Tony Morris, John de Goes and Edward Kmett
for their help explaining the principles of FP. Kenji Yoshida and
Jason Zaugg for being the main authors of scalaz, and Paul Chuisano /
Miles Sabin for fixing a critical bug in the scala compiler ([[https://issues.scala-lang.org/browse/SI-2712][SI-2712]]).

Thank you to the readers who gave feedback on early drafts of this text.

Some material was particularly helpful for my own understanding of the concepts
that are in this book. Thanks to Juan Manuel Serrano for [[https://skillsmatter.com/skillscasts/9904-london-scala-march-meetup#video][All Roads Lead to
Lambda]], Pere Villega for [[http://perevillega.com/understanding-free-monads][On Free Monads]], Dick Wall and Josh Suereth for [[https://www.youtube.com/watch?v=WDaw2yXAa50][For:
What is it Good For?]], Erik Bakker for [[https://www.youtube.com/watch?v=hGMndafDcc8][Options in Futures, how to unsuck them]],
Noel Markham for [[https://www.47deg.com/presentations/2017/06/01/ADT-for-the-win/][ADTs for the Win!]], Sukant Hajra for [[https://www.youtube.com/watch?v=QtZJATIPB0k][Classy Monad Transformers]],
Luka Jacobowitz for [[https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html][Optimizing Tagless Final]], Vincent Marquez for [[https://www.youtube.com/watch?v=JPVagd9W4Lo][Index your
State]], Gabriel Gonzalez for [[http://www.haskellforall.com/2012/12/the-continuation-monad.html][The Continuation Monad]], and Yi Lin Wei / Zainab Ali
for their tutorials at Hack The Tower meetups.

The helpul souls who patiently explained things to me: Merlin Göttlinger, Edmund
Noble, Fabio Labella, Adelbert Chang, Michael Pilquist, Paul Snively, Daniel
Spiewak, Stephen Compall, Brian McKenna, Ryan Delucchi, Pedro Rodriguez, Emily
Pillmore, Aaron Vargo, Tomas Mikula, Jean-Baptiste Giraudeau, Itamar Ravid, Ross
A. Baker and Alexander Konovalov.

** Practicalities

If you'd like to set up a project that uses the libraries presented in
this book, you will need to use a recent version of Scala with
FP-specific features enabled (e.g. in =build.sbt=):

#+BEGIN_SRC scala
scalaVersion in ThisBuild := "2.12.6"
scalacOptions in ThisBuild ++= Seq(
  "-language:_",
  "-Ypartial-unification",
  "-Xfatal-warnings"
)

libraryDependencies ++= Seq(
  "com.github.mpilquist" %% "simulacrum"     % "0.12.0",
  "org.scalaz"           %% "scalaz-core"    % "7.2.22"
)

addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.6")
addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.1" cross CrossVersion.full)
#+END_SRC

In order to keep our snippets short, we will omit the =import=
section. Unless told otherwise, assume that all snippets have the
following imports:

#+BEGIN_SRC scala
import scalaz._, Scalaz._
import simulacrum._
#+END_SRC

* Mainmatter                                                          :final:
:PROPERTIES:
:EXPORT_FILE_NAME: mainmatter.md
:END:
{mainmatter}

* Introduction                                                        :final:
  :PROPERTIES:
  :EXPORT_FILE_NAME: introduction.md
  :END:
** Introduction

It is human instinct to be sceptical of a new paradigm. To put some
perspective on how far we have come, and the shifts we have already
accepted on the JVM, let's start with a quick recap of the last 20
years.

Java 1.2 introduced the Collections API, allowing us to write methods
that abstracted over mutable collections. It was useful for writing
general purpose algorithms and was the bedrock of our codebases.

But there was a problem, we had to perform runtime casting:

#+BEGIN_SRC java
public String first(Collection collection) {
  return (String)(collection.get(0));
}
#+END_SRC

In response, developers defined domain objects in their business logic
that were effectively =CollectionOfThings=, and the Collection API
became implementation detail.

In 2005, Java 5 introduced /generics/, allowing us to define
=Collection<Thing>=, abstracting over the container *and* its
elements. Generics changed how we wrote Java.

The author of the Java generics compiler, Martin Odersky, then created
Scala with a stronger type system, immutable data and multiple
inheritance. This brought about a fusion of object oriented (OOP) and
functional programming (FP).

For most developers, FP means using immutable data as much as
possible, but mutable state is still a necessary evil that must be
isolated and managed, e.g. with Akka actors or =synchronized= classes.
This style of FP results in simpler programs that are easier to
parallelise and distribute, an improvement over Java. But it is only
scratching the surface of the benefits of FP, as we'll discover in
this book.

Scala also brings =Future=, making it easy to write asynchronous
applications. But when a =Future= makes it into a return type,
/everything/ needs to be rewritten to accomodate it, including the
tests, which are now subject to arbitrary timeouts.

We have a problem similar to Java 1.0: there is no way of abstracting
over execution, much as we had no way of abstracting over collections.

*** Abstracting over Execution

Let's say we want to interact with the user over the command line
interface. We can =read= what the user types and we can =write= a
message to them.

#+BEGIN_SRC scala
trait TerminalSync {
  def read(): String
  def write(t: String): Unit
}

trait TerminalAsync {
  def read(): Future[String]
  def write(t: String): Future[Unit]
}
#+END_SRC

But how do we write generic code that does something as simple as echo
the user's input synchronously or asynchronously depending on our
runtime implementation?

We could write a synchronous version and wrap it with =Future= but now
we have to worry about which thread pool we should be using for the
work, or we could =Await.result= on the =Future= and introduce thread
blocking. In either case, it is a lot of boilerplate and we are
fundamentally dealing with different APIs that are not unified.

Let's try to solve the problem like Java 1.2 by introducing a common
parent. To do this, we need to use the /higher kinded types/ (HKT)
Scala language feature.

#+BEGIN_ASIDE

*Higher Kinded Types* allow us to use a /type constructor/ in our type
parameters, which looks like =C[_]=. This is a way of saying that
whatever =C= is, it must take a type parameter. For example:

#+BEGIN_SRC scala
trait Foo[C[_]] {
  def create(i: Int): C[Int]
}
#+END_SRC

=List= is a type constructor because it takes a type (e.g. =Int=) and
constructs a type (=List -> Int -> List[Int]=). We can implement =Foo=
using =List=:

#+BEGIN_SRC scala
object FooList extends Foo[List] {
  def create(i: Int): List[Int] = List(i)
}
#+END_SRC

We can implement =Foo= for anything with a type parameter hole, e.g.
=Either[String, _]=. Unfortunately it is a bit clunky and we have to
create a type alias to trick the compiler into accepting it:

#+BEGIN_SRC scala
type EitherString[T] = Either[String, T]
#+END_SRC

Type aliases don't define new types, they just use substitution and
don't provide extra type safety. The compiler substitutes
=EitherString[T]= with =Either[String, T]= everywhere. This technique
can be used to trick the compiler into accepting types with one hole
when it would otherwise think there are two, like when we implement
=Foo= with =EitherString=:

#+BEGIN_SRC scala
object FooEitherString extends Foo[EitherString] {
  def create(i: Int): Either[String, Int] = Right(i)
}
#+END_SRC

Alternatively, the [[https://github.com/non/kind-projector/][kind projector]] plugin allows us to avoid the =type=
alias and use =?= syntax to tell the compiler where the type hole is:

#+BEGIN_SRC scala
object FooEitherString extends Foo[Either[String, ?]] {
  def create(i: Int): Either[String, Int] = Right(i)
}
#+END_SRC

Finally, there is this one weird trick we can use when we want to
ignore the type constructor. Let's define a type alias to be equal to
its parameter:

#+BEGIN_SRC scala
type Id[T] = T
#+END_SRC

Before proceeding, convince yourself that =Id[Int]= is the same thing
as =Int=, by substituting =Int= into =T=. Because =Id= is a valid type
constructor we can use =Id= in an implementation of =Foo=

#+BEGIN_SRC scala
object FooId extends Foo[Id] {
  def create(i: Int): Int = i
}
#+END_SRC

#+END_ASIDE

We want to define =Terminal= for a type constructor =C[_]=. By
defining =Now= to construct to its type parameter (like =Id=), we can
implement a common interface for synchronous and asynchronous
terminals:

#+BEGIN_SRC scala
trait Terminal[C[_]] {
  def read: C[String]
  def write(t: String): C[Unit]
}

type Now[X] = X

object TerminalSync extends Terminal[Now] {
  def read: String = ???
  def write(t: String): Unit = ???
}

object TerminalAsync extends Terminal[Future] {
  def read: Future[String] = ???
  def write(t: String): Future[Unit] = ???
}
#+END_SRC

You can think of =C= as a /Context/ because we say "in the context of
executing =Now=" or "in the =Future=".

But we know nothing about =C= and we can't do anything with a
=C[String]=. What we need is a kind of execution environment that lets
us call a method returning =C[T]= and then be able to do something
with the =T=, including calling another method on =Terminal=. We also
need a way of wrapping a value as a =C[_]=. This signature works well:

#+BEGIN_SRC scala
trait Execution[C[_]] {
  def doAndThen[A, B](c: C[A])(f: A => C[B]): C[B]
  def create[B](b: B): C[B]
}
#+END_SRC

letting us write:

#+BEGIN_SRC scala
def echo[C[_]](t: Terminal[C], e: Execution[C]): C[String] =
  e.doAndThen(t.read) { in: String =>
    e.doAndThen(t.write(in)) { _: Unit =>
      e.create(in)
    }
  }
#+END_SRC

We can now share the =echo= implementation between synchronous and
asynchronous codepaths. We can write a mock implementation of
=Terminal[Now]= and use it in our tests without any timeouts.

Implementations of =Execution[Now]= and =Execution[Future]= are
reusable by generic methods like =echo=.

But the code for =echo= is horrible! Let's clean it up.

The =implicit class= Scala language feature gives =C= some methods.
We'll call these methods =flatMap= and =map= for reasons that will
become clearer in a moment. Each method takes an =implicit
Execution[C]=, but this is nothing more than the =flatMap= and =map=
that you're used to on =Seq=, =Option= and =Future=

#+BEGIN_SRC scala
object Execution {
  implicit class Ops[A, C[_]](c: C[A]) {
    def flatMap[B](f: A => C[B])(implicit e: Execution[C]): C[B] =
          e.doAndThen(c)(f)
    def map[B](f: A => B)(implicit e: Execution[C]): C[B] =
          e.doAndThen(c)(f andThen e.create)
  }
}

def echo[C[_]](implicit t: Terminal[C], e: Execution[C]): C[String] =
  t.read.flatMap { in: String =>
    t.write(in).map { _: Unit =>
      in
    }
  }
#+END_SRC

We can now reveal why we used =flatMap= as the method name: it lets us
use a /for comprehension/, which is just syntax sugar over nested
=flatMap= and =map=.

#+BEGIN_SRC scala
def echo[C[_]](implicit t: Terminal[C], e: Execution[C]): C[String] =
  for {
    in <- t.read
     _ <- t.write(in)
  } yield in
#+END_SRC

Our =Execution= has the same signature as a trait in scalaz called
=Monad=, except =doAndThen= is =flatMap= and =create= is =pure=. We
say that =C= is /monadic/ when there is an implicit =Monad[C]=
available. In addition, scalaz has the =Id= type alias.

The takeaway is: if we write methods that operate on monadic types,
then we can write sequential code that abstracts over its execution
context. Here, we have shown an abstraction over synchronous and
asynchronous execution but it can also be for the purpose of more
rigorous error handling (where =C[_]= is =Either[Error, _]=), managing
access to volatile state, performing I/O, or auditing of the session.

*** Pure Functional Programming

Functional Programming is the act of writing programs with /pure functions/.
Pure functions have three properties:

- *Total*: return a value for every possible input
- *Deterministic*: return the same value for the same input
- *Inculpable*: no (direct) interaction with the world or program state.

Together, these properties give us an unprecedented ability to reason about our
code. For example, input validation is easier to isolate with totality, caching
is possible when functions are deterministic, and interacting with the world is
easier to control, and test, when functions are inculpable.

The kinds of things that break these properties are /side effects/: directly
accessing or changing mutable state (e.g. maintaining a =var= in a class or
using a legacy API that is impure), communicating with external resources (e.g.
files or network lookup), or throwing exceptions.

We write pure functions by avoiding exceptions, and interacting with the world
only through a safe =F[_]= execution context.

In the previous section, we abstracted over execution and defined =echo[Id]= and
=echo[Future]=. We might reasonably expect that calling any =echo= will not
perform any side effects, because it is pure. However, if we use =Future= or
=Id= as the execution context, our application will start listening to stdin:

#+BEGIN_SRC scala
  val futureEcho: Future[String] = echo[Future]
#+END_SRC

We have broken purity and are no longer writing FP code: =futureEcho= is the
result of running =echo= once. =Future= conflates the definition of a program
with /interpreting/ it (running it). As a result, applications built with
=Future= are difficult to reason about.

#+BEGIN_ASIDE
An expression is /referentially transparent/ if it can be replaced with its
corresponding value without changing the program's behaviour.

Pure functions are referentially transparent, allowing for a great deal of code
reuse, performance optimisation, understanding, and control of a program.

Impure functions are not referentially transparent, unless we take a liberal
interpretation of "the program's behaviour". We cannot replace =echo[Future]=
with a value, such as =val futureEcho=, since the pesky user will probably type
something different the second time.
#+END_ASIDE

We can define a simple safe =F[_]= execution context

#+BEGIN_SRC scala
class IO[A](val interpret: () => A) {
  def map[B](f: A => B): IO[B] = IO(f(interpret()))
  def flatMap[B](f: A => IO[B]): IO[B] = f(interpret())
}
object IO {
  def apply[A](a: =>A): IO[A] = new IO(() => a)
}
#+END_SRC

which lazily evaluates a thunk. =IO= is just a data structure that references
(potentially) impure code, it isn't actually running anything. We can implement
=Terminal[IO]=

#+BEGIN_SRC scala
object TerminalIO extends Terminal[IO] {
  def read: IO[String]           = IO { io.StdIn.readLine }
  def write(t: String): IO[Unit] = IO { println(t) }
}
#+END_SRC

and call =echo[IO]= to get back a value

#+BEGIN_SRC scala
  val delayed: IO[String] = echo[IO]
#+END_SRC

This =val delayed= can be reused, it is just the definition of the work to be
done. We can map the =String= and compose additional programs, much as we would
map over a =Future=. =IO= keeps us honest that we are depending on some
interaction with the world, but does not prevent us from accessing the output of
that interaction.

The impure code inside the =IO= is only evaluated when we =.interpret()= the
value, which is an impure action

#+BEGIN_SRC scala
    delayed.interpret()
#+END_SRC

An application composed of =IO= programs is only interpreted once, in the =main=
method, which is also called /the end of the world/.

In this book, we expand on the concepts introduced in this chapter and show how
to write maintainable, pure functions, that achieve your business's objectives.

* Complete                                                            :final:
  :PROPERTIES:
  :EXPORT_FILE_NAME: complete.md
  :END:
** For Comprehensions

Scala's =for= comprehension is the ideal FP abstraction for sequential
programs that interact with the world. Since we'll be using it a lot,
we're going to relearn the principles of =for= and how scalaz can help
us to write cleaner code.

This chapter doesn't try to write pure programs and the techniques are
applicable to non-FP codebases.

*** Syntax Sugar

Scala's =for= is just a simple rewrite rule, also called /syntax
sugar/, that doesn't have any contextual information.

To see what a =for= comprehension is doing, we use the =show= and
=reify= feature in the REPL to print out what code looks like after
type inference.

#+BEGIN_SRC scala
scala> import scala.reflect.runtime.universe._
scala> val a, b, c = Option(1)
scala> show { reify {
         for { i <- a ; j <- b ; k <- c } yield (i + j + k)
       } }

res:
$read.a.flatMap(
  ((i) => $read.b.flatMap(
    ((j) => $read.c.map(
      ((k) => i.$plus(j).$plus(k)))))))
#+END_SRC

There is a lot of noise due to additional sugarings (e.g. =+= is
rewritten =$plus=, etc). We'll skip the =show= and =reify= for brevity
when the REPL line is =reify>=, and manually clean up the generated
code so that it doesn't become a distraction.

#+BEGIN_SRC scala
reify> for { i <- a ; j <- b ; k <- c } yield (i + j + k)

a.flatMap {
  i => b.flatMap {
    j => c.map {
      k => i + j + k }}}
#+END_SRC

The rule of thumb is that every =<-= (called a /generator/) is a
nested =flatMap= call, with the final generator a =map= containing the
=yield= body.

**** Assignment

We can assign values inline like =ij = i + j= (a =val= keyword is not
needed).

#+BEGIN_SRC scala
reify> for {
         i <- a
         j <- b
         ij = i + j
         k <- c
       } yield (ij + k)

a.flatMap {
  i => b.map { j => (j, i + j) }.flatMap {
    case (j, ij) => c.map {
      k => ij + k }}}
#+END_SRC

A =map= over the =b= introduces the =ij= which is flat-mapped along
with the =j=, then the final =map= for the code in the =yield=.

Unfortunately we cannot assign before any generators. It has been
requested as a language feature but has not been implemented:
https://github.com/scala/bug/issues/907

#+BEGIN_SRC scala
scala> for {
         initial = getDefault
         i <- a
       } yield initial + i
<console>:1: error: '<-' expected but '=' found.
#+END_SRC

We can workaround the limitation by defining a =val= outside the =for=

#+BEGIN_SRC scala
scala> val initial = getDefault
scala> for { i <- a } yield initial + i
#+END_SRC

or create an =Option= out of the initial assignment

#+BEGIN_SRC scala
scala> for {
         initial <- Option(getDefault)
         i <- a
       } yield initial + i
#+END_SRC

#+BEGIN_ASIDE

=val= doesn't have to assign to a single value, it can be anything
that works as a =case= in a pattern match.

#+BEGIN_SRC scala
scala> val (first, second) = ("hello", "world")
first: String = hello
second: String = world

scala> val list: List[Int] = ...
scala> val head :: tail = list
head: Int = 1
tail: List[Int] = List(2, 3)
#+END_SRC

The same is true for assignment in =for= comprehensions

#+BEGIN_SRC scala
scala> val maybe = Option(("hello", "world"))
scala> for {
         entry <- maybe
         (first, _) = entry
       } yield first
res: Some(hello)
#+END_SRC

But be careful that you don't miss any cases or you'll get a runtime
exception (a /totality/ failure).

#+BEGIN_SRC scala
scala> val a :: tail = list
caught scala.MatchError: List()
#+END_SRC
#+END_ASIDE

**** Filter

It is possible to put =if= statements after a generator to filter
values by a predicate

#+BEGIN_SRC scala
reify> for {
         i  <- a
         j  <- b
         if i > j
         k  <- c
       } yield (i + j + k)

a.flatMap {
  i => b.withFilter {
    j => i > j }.flatMap {
      j => c.map {
        k => i + j + k }}}
#+END_SRC

Older versions of scala used =filter=, but =Traversable.filter=
creates new collections for every predicate, so =withFilter= was
introduced as the more performant alternative.

We can accidentally trigger a =withFilter= by providing type
information: it is actually interpreted as a pattern match.

#+BEGIN_SRC scala
reify> for { i: Int <- a } yield i

a.withFilter {
  case i: Int => true
  case _      => false
}.map { case i: Int => i }
#+END_SRC

Like in assignment, a generator can use a pattern match on the left
hand side. But unlike assignment (which throws =MatchError= on
failure), generators are /filtered/ and will not fail at runtime.
However, there is an inefficient double application of the pattern.

#+BEGIN_ASIDE
The compiler plugin [[https://github.com/oleg-py/better-monadic-for][=better-monadic-for=]] produces alternative, *better*,
desugarings than the scala compiler. This example is interpreted as:

#+BEGIN_SRC scala
reify> for { i: Int <- a } yield i

a.map { (i: Int) => i}
#+END_SRC

instead of inefficient double matching (in the best case) and silent filtering
at runtime (in the worst case). Highly recommended.
#+END_ASIDE

**** For Each

Finally, if there is no =yield=, the compiler will use =foreach=
instead of =flatMap=, which is only useful for side-effects.

#+BEGIN_SRC scala
reify> for { i <- a ; j <- b } println(s"$i $j")

a.foreach { i => b.foreach { j => println(s"$i $j") } }
#+END_SRC

**** Summary

The full set of methods supported by =for= comprehensions do not share
a common super type; each generated snippet is independently compiled.
If there were a trait, it would roughly look like:

#+BEGIN_SRC scala
trait ForComprehensible[C[_]] {
  def map[A, B](f: A => B): C[B]
  def flatMap[A, B](f: A => C[B]): C[B]
  def withFilter[A](p: A => Boolean): C[A]
  def foreach[A](f: A => Unit): Unit
}
#+END_SRC

If the context (=C[_]=) of a =for= comprehension doesn't provide its
own =map= and =flatMap=, all is not lost. If an implicit
=scalaz.Bind[T]= is available for =T=, it will provide =map= and
=flatMap=.

#+BEGIN_ASIDE

It often surprises developers when inline =Future= calculations in a
=for= comprehension do not run in parallel:

#+BEGIN_SRC scala
import scala.concurrent._
import ExecutionContext.Implicits.global

for {
  i <- Future { expensiveCalc() }
  j <- Future { anotherExpensiveCalc() }
} yield (i + j)
#+END_SRC

This is because the =flatMap= spawning =anotherExpensiveCalc= is
strictly *after* =expensiveCalc=. To ensure that two =Future=
calculations begin in parallel, start them outside the =for=
comprehension.

#+BEGIN_SRC scala
val a = Future { expensiveCalc() }
val b = Future { anotherExpensiveCalc() }
for { i <- a ; j <- b } yield (i + j)
#+END_SRC

=for= comprehensions are fundamentally for defining sequential
programs. We will show a far superior way of defining parallel
computations in a later chapter. Spoiler: don't use =Future=.
#+END_ASIDE

*** Unhappy path

So far we've only looked at the rewrite rules, not what is happening
in =map= and =flatMap=. Let's consider what happens when the =for=
context decides that it can't proceed any further.

In the =Option= example, the =yield= is only called when =i,j,k= are
all defined.

#+BEGIN_SRC scala
for {
  i <- a
  j <- b
  k <- c
} yield (i + j + k)
#+END_SRC

If any of =a,b,c= are =None=, the comprehension short-circuits with
=None= but it doesn't tell us what went wrong.

#+BEGIN_ASIDE

How often have you seen a function that takes =Option= parameters but
requires them all to exist? An alternative to throwing a runtime
exception is to use a =for= comprehension, giving us totality (a
return value for every input):

#+BEGIN_SRC scala
def namedThings(
  someName  : Option[String],
  someNumber: Option[Int]
): Option[String] = for {
  name   <- someName
  number <- someNumber
} yield s"$number ${name}s"
#+END_SRC

but this is verbose, clunky and bad style. If a function requires
every input then it should make its requirement explicit, pushing the
responsibility of dealing with optional parameters to its caller ---
don't use =for= unless you need to.

#+BEGIN_SRC scala
def namedThings(name: String, num: Int) = s"$num ${name}s"
#+END_SRC
#+END_ASIDE

If we use =Either=, then a =Left= will cause the =for= comprehension
to short circuit with extra information, much better than =Option= for
error reporting:

#+BEGIN_SRC scala
scala> val a = Right(1)
scala> val b = Right(2)
scala> val c: Either[String, Int] = Left("sorry, no c")
scala> for { i <- a ; j <- b ; k <- c } yield (i + j + k)

Left(sorry, no c)
#+END_SRC

And lastly, let's see what happens with a =Future= that fails:

#+BEGIN_SRC scala
scala> import scala.concurrent._
scala> import ExecutionContext.Implicits.global
scala> for {
         i <- Future.failed[Int](new Throwable)
         j <- Future { println("hello") ; 1 }
       } yield (i + j)
scala> Await.result(f, duration.Duration.Inf)
caught java.lang.Throwable
#+END_SRC

The =Future= that prints to the terminal is never called because, like
=Option= and =Either=, the =for= comprehension short circuits.

Short circuiting for the unhappy path is a common and important theme.
=for= comprehensions cannot express resource cleanup: there is no way
to =try= / =finally=. This is good, in FP it puts a clear ownership of
responsibility for unexpected error recovery and resource cleanup onto
the context (which is usually a =Monad= as we'll see later), not the
business logic.

*** Gymnastics

Although it is easy to rewrite simple sequential code as a =for=
comprehension, sometimes we'll want to do something that appears to
require mental summersaults. This section collects some practical
examples and how to deal with them.

**** Fallback Logic

Let's say we are calling out to a method that returns an =Option= and
if it is not successful we want to fallback to another method (and so
on and so on), like when we're using a cache:

#+BEGIN_SRC scala
def getFromRedis(s: String): Option[String]
def getFromSql(s: String): Option[String]

getFromRedis(key) orElse getFromSql(key)
#+END_SRC

If we have to do this for an asynchronous version of the same API

#+BEGIN_SRC scala
def getFromRedis(s: String): Future[Option[String]]
def getFromSql(s: String): Future[Option[String]]
#+END_SRC

then we have to be careful not to do extra work because

#+BEGIN_SRC scala
for {
  cache <- getFromRedis(key)
  sql   <- getFromSql(key)
} yield cache orElse sql
#+END_SRC

will run both queries. We can pattern match on the first result but
the type is wrong

#+BEGIN_SRC scala
for {
  cache <- getFromRedis(key)
  res   <- cache match {
             case Some(_) => cache !!! wrong type !!!
             case None    => getFromSql(key)
           }
} yield res
#+END_SRC

We need to create a =Future= from the =cache=

#+BEGIN_SRC scala
for {
  cache <- getFromRedis(key)
  res   <- cache match {
             case Some(_) => Future.successful(cache)
             case None    => getFromSql(key)
           }
} yield res
#+END_SRC

=Future.successful= creates a new =Future=, much like an =Option= or
=List= constructor.

If functional programming was like this all the time, it'd be a
nightmare. Thankfully these tricky situations are the corner cases.

**** Early Exit

Let's say we have some condition that should exit early with a successful value.

If we want to exit early with an error, it is standard practice in OOP to throw
an exception

#+BEGIN_SRC scala
  def getA: Int = ...

  val a = getA
  require(a > 0, s"$a must be positive")
  a * 10
#+END_SRC

which can be rewritten async

#+BEGIN_SRC scala
  def getA: Future[Int] = ...
  def error(msg: String): Future[Nothing] =
    Future.failed(new RuntimeException(msg))

  for {
    a <- getA
    b <- if (a <= 0) error(s"$a must be positive")
         else Future.successful(a)
  } yield b * 10
#+END_SRC

But if we want to exit early with a successful return value, the simple
synchronous code:

#+BEGIN_SRC scala
  def getB: Int = ...

  val a = getA
  if (a <= 0) 0
  else a * getB
#+END_SRC

translates into a nested =for= comprehension when our dependencies are
asynchronous:

#+BEGIN_SRC scala
  def getB: Future[Int] = ...

  for {
    a <- getA
    c <- if (a <= 0) Future.successful(0)
         else for { b <- getB } yield a * b
  } yield c
#+END_SRC

#+BEGIN_ASIDE

If there is an implicit =Monad[T]= for =T[_]= (i.e. =T= is monadic) then scalaz
lets us create a =T[A]= from a value =a: A= by calling =a.pure[T]=.

Scalaz provides =Monad[Future]=, and =.pure[Future]= calls =Future.successful=.
Besides =pure= being slightly shorter to type, it is a general concept that
works beyond =Future=, and is therefore recommended.

#+BEGIN_SRC scala
  for {
    a <- getA
    c <- if (a <= 0) 0.pure[Future]
         else for { b <- getB } yield a * b
  } yield c
#+END_SRC
#+END_ASIDE

*** Incomprehensible

The context we're comprehending over must stay the same: we can't mix
contexts.

#+BEGIN_SRC scala
scala> def option: Option[Int] = ...
scala> def future: Future[Int] = ...
scala> for {
         a <- option
         b <- future
       } yield a * b
<console>:23: error: type mismatch;
 found   : Future[Int]
 required: Option[?]
         b <- future
              ^
#+END_SRC

Nothing can help us mix arbitrary contexts in a =for= comprehension
because the meaning is not well defined.

But when we have nested contexts the intention is usually obvious yet
the compiler still doesn't accept our code.

#+BEGIN_SRC scala
scala> def getA: Future[Option[Int]] = ...
scala> def getB: Future[Option[Int]] = ...
scala> for {
         a <- getA
         b <- getB
       } yield a * b
<console>:30: error: value * is not a member of Option[Int]
       } yield a * b
                 ^
#+END_SRC

Here we want =for= to take care of the outer context and let us write
our code on the inner =Option=. Hiding the outer context is exactly
what a /monad transformer/ does, and scalaz provides implementations
for =Option= and =Either= named =OptionT= and =EitherT= respectively.

The outer context can be anything that normally works in a =for=
comprehension, but it needs to stay the same throughout.

We create an =OptionT= from each method call. This changes the context
of the =for= from =Future[Option[_]]= to =OptionT[Future, _]=.

#+BEGIN_SRC scala
scala> val result = for {
         a <- OptionT(getA)
         b <- OptionT(getB)
       } yield a * b
result: OptionT[Future, Int] = OptionT(Future(<not completed>))
#+END_SRC

=.run= returns us to the original context

#+BEGIN_SRC scala
scala> result.run
res: Future[Option[Int]] = Future(<not completed>)
#+END_SRC

Alternatively, =OptionT[Future, Int]= has =getOrElse= and =getOrElseF=
methods, taking =Int= and =Future[Int]= respectively, returning a
=Future[Int]=.

The monad transformer also allows us to mix =Future[Option[_]]= calls with
methods that just return plain =Future= via =.liftM[OptionT]= (provided by
scalaz):

#+BEGIN_SRC scala
scala> def getC: Future[Int] = ...
scala> val result = for {
         a <- OptionT(getA)
         b <- OptionT(getB)
         c <- getC.liftM[OptionT]
       } yield a * b / c
result: OptionT[Future, Int] = OptionT(Future(<not completed>))
#+END_SRC

and we can mix with methods that return plain =Option= by wrapping
them in =Future.successful= (=.pure[Future]=) followed by =OptionT=

#+BEGIN_SRC scala
scala> def getD: Option[Int] = ...
scala> val result = for {
         a <- OptionT(getA)
         b <- OptionT(getB)
         c <- getC.liftM[OptionT]
         d <- OptionT(getD.pure[Future])
       } yield (a * b) / (c * d)
result: OptionT[Future, Int] = OptionT(Future(<not completed>))
#+END_SRC

It is messy again, but it is better than writing nested =flatMap= and
=map= by hand. We can clean it up with a DSL that handles all the
required conversions into =OptionT[Future, _]=

#+BEGIN_SRC scala
def liftFutureOption[A](f: Future[Option[A]]) = OptionT(f)
def liftFuture[A](f: Future[A]) = f.liftM[OptionT]
def liftOption[A](o: Option[A]) = OptionT(o.pure[Future])
def lift[A](a: A)               = liftOption(Option(a))
#+END_SRC

combined with the =|>= operator, which applies the function on the
right to the value on the left, to visually separate the logic from
the transformers

#+BEGIN_SRC scala
scala> val result = for {
         a <- getA       |> liftFutureOption
         b <- getB       |> liftFutureOption
         c <- getC       |> liftFuture
         d <- getD       |> liftOption
         e <- 10         |> lift
       } yield e * (a * b) / (c * d)
result: OptionT[Future, Int] = OptionT(Future(<not completed>))
#+END_SRC

#+BEGIN_ASIDE
=|>= is often called the /thrush operator/ because of its uncanny
resemblance to the cute bird.
#+END_ASIDE

This approach also works for =EitherT= (and others) as the inner
context, but their lifting methods are more complex and require
parameters. Scalaz provides monad transformers for a lot of its own
types, so it is worth checking if one is available.

Implementing a monad transformer is an advanced topic. Although
=ListT= exists, it should be avoided because it can unintentionally
reorder =flatMap= calls according to
https://github.com/scalaz/scalaz/issues/921. A better alternative is
=StreamT=, which we will visit later.

** Application Design

In this chapter we will write the business logic and tests for a
purely functional server application.

*** Specification

Our application will manage a just-in-time build farm on a shoestring
budget. It will listen to a [[https://github.com/drone/drone][Drone]] Continuous Integration server, and
spawn worker agents using [[https://cloud.google.com/container-engine/][Google Container Engine]] (GKE) to meet the
demand of the work queue.

#+BEGIN_SRC dot :cmd circo :file images/architecture.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Palatino, shape=box];

    Agents [shape=doubleoctagon];
    App [shape=trapezium];

    Google -> Agents;

    Github -> Drone;
    App -> Drone [label = "backlog\nagents"];
    App -> Google [label = "start/stop\nstatus\ncurrent time"];
    Drone -> App;
    Google -> App;

    Agents -> Drone [label = "subscribe"];
}
#+END_SRC

#+RESULTS:
[[file:images/architecture.png]]

Drone receives work when a contributor submits a github pull request
to a managed project. Drone assigns the work to its agents, each
processing one job at a time.

The goal of our app is to ensure that there are enough agents to
complete the work, with a cap on the number of agents, whilst
minimising the total cost. Our app needs to know the number of items
in the /backlog/ and the number of available /agents/.

Google can spawn /nodes/, each can host multiple drone agents. When an
agent starts up, it registers itself with drone and drone takes care
of the lifecycle (including keep-alive calls to detect removed
agents).

GKE charges a fee per minute of uptime, rounded up to the nearest hour
for each node. One does not simply spawn a new node for each job in
the work queue, we must re-use nodes and retain them until their 59th
minute to get the most value for money.

Our app needs to be able to start and stop nodes, as well as check
their status (e.g. uptimes, list of inactive nodes) and to know what
time GKE believes it to be.

In addition, there is no API to talk directly to an /agent/ so we do
not know if any individual agent is performing any work for the drone
server. If we accidentally stop an agent whilst it is performing work,
it is inconvenient and requires a human to restart the job.

Contributors can manually add agents to the farm, so counting agents
and nodes is not equivalent. We don't need to supply any nodes if
there are agents available.

The failure mode should always be to take the least costly option.

Both Drone and GKE have a JSON over REST API with OAuth 2.0
authentication.

*** Interfaces / Algebras

Let's codify the architecture diagram from the previous section.

In FP, an /algebra/ takes the place of an =interface= in Java, or the
set of valid messages for an =Actor= in Akka. This is the layer where
we define all side-effecting interactions of our system.

There is tight iteration between writing the business logic and the
algebra: it is a good level of abstraction to design a system.

#+BEGIN_SRC scala
package algebra

import java.time.Instant
import scalaz.NonEmptyList

trait Drone[F[_]] {
  def getBacklog: F[Int]
  def getAgents: F[Int]
}

final case class MachineNode(id: String)
trait Machines[F[_]] {
  def getTime: F[Instant]
  def getManaged: F[NonEmptyList[MachineNode]]
  def getAlive: F[Map[MachineNode, Instant]]
  def start(node: MachineNode): F[MachineNode]
  def stop(node: MachineNode): F[MachineNode]
}
#+END_SRC

We've used =NonEmptyList=, easily created by calling =.toNel= on the
stdlib's =List= (returning an =Option[NonEmptyList]=), otherwise
everything should be familiar.

#+BEGIN_ASIDE
It is good practice in FP to encode constraints in parameters *and* return types
--- it means we never need to handle situations that are impossible. However,
this often conflicts with /Postel's law/ "be liberal in what you accept from
others".

Although we agree that parameters should be as general as possible, we do not
agree that a function should take =Seq= unless it can handle empty =Seq=,
otherwise the only course of action would be to exception, breaking totality and
causing a side effect.

We prefer =NonEmptyList=, not because it is a =List=, but because of its
non-empty property. When we learn about scalaz's typeclass hierarchy, we will
see a better way to request non-emptyness.
#+END_ASIDE

*** Business Logic

Now we write the business logic that defines the application's
behaviour, considering only the happy path.

First, the imports

#+BEGIN_SRC scala
package logic

import java.time.Instant
import java.time.temporal.ChronoUnit

import scala.concurrent.duration._

import scalaz._
import Scalaz._

import algebra._
#+END_SRC

We need a =WorldView= class to hold a snapshot of our knowledge of the
world. If we were designing this application in Akka, =WorldView=
would probably be a =var= in a stateful =Actor=.

=WorldView= aggregates the return values of all the methods in the
algebras, and adds a /pending/ field to track unfulfilled requests.

#+BEGIN_SRC scala
final case class WorldView(
  backlog: Int,
  agents: Int,
  managed: NonEmptyList[MachineNode],
  alive: Map[MachineNode, Instant],
  pending: Map[MachineNode, Instant],
  time: Instant
)
#+END_SRC

Now we are ready to write our business logic, but we need to indicate
that we depend on =Drone= and =Machines=.

We create a /module/ to contain our main business logic. A module is
pure and depends only on other modules, algebras and pure functions.

#+BEGIN_SRC scala
final class DynAgents[F[_]](D: Drone[F], M: Machines[F])
                           (implicit F: Monad[F]) {
#+END_SRC

The implicit =Monad[F]= means that =F= is /monadic/, allowing us to
use =map=, =pure= and, of course, =flatMap= via =for= comprehensions.

We have access to the algebra of =Drone= and =Machines= as =D= and =M=,
respectively. Using a single capital letter name is a common naming convention
for monad and algebra implementations.

Our business logic will run in an infinite loop (pseudocode)

#+BEGIN_SRC python
state = initial()
while True:
  state = update(state)
  state = act(state)
#+END_SRC

We must write three functions: =initial=, =update= and =act=, all
returning an =F[WorldView]=.

**** initial

In =initial= we call all external services and aggregate their results
into a =WorldView=. We default the =pending= field to an empty =Map=.

#+BEGIN_SRC scala
  def initial: F[WorldView] = for {
    db <- D.getBacklog
    da <- D.getAgents
    mm <- M.getManaged
    ma <- M.getAlive
    mt <- M.getTime
  } yield WorldView(db, da, mm, ma, Map.empty, mt)
#+END_SRC

Recall from Chapter 1 that =flatMap= (i.e. when we use the =<-=
generator) allows us to operate on a value that is computed at
runtime. When we return an =F[_]= we are returning another program to
be interpreted at runtime, that we can then =flatMap=. This is how we
safely chain together sequential side-effecting code, whilst being
able to provide a pure implementation for tests. FP could be described
as Extreme Mocking.

**** update

=update= should call =initial= to refresh our world view, preserving
known =pending= actions.

If a node has changed state, we remove it from =pending= and if a
pending action is taking longer than 10 minutes to do anything, we
assume that it failed and forget that we asked to do it.

#+BEGIN_SRC scala
  def update(old: WorldView): F[WorldView] = for {
    snap <- initial
    changed = symdiff(old.alive.keySet, snap.alive.keySet)
    pending = (old.pending -- changed).filterNot {
      case (_, started) => timediff(started, snap.time) >= 10.minutes
    }
    update = snap.copy(pending = pending)
  } yield update

  private def symdiff[T](a: Set[T], b: Set[T]): Set[T] =
    (a union b) -- (a intersect b)

  private def timediff(from: Instant, to: Instant): FiniteDuration =
    ChronoUnit.MINUTES.between(from, to).minutes
#+END_SRC

Note that we use assignment for pure functions like =symdiff=,
=timediff= and =copy=. Pure functions don't need test mocks, they have
explicit inputs and outputs, so you could move all pure code into
standalone methods on a stateless =object=, testable in isolation.
We're happy testing only the public methods, preferring that our
business logic is easy to read.

**** act

The =act= method is slightly more complex, so we'll split it into two
parts for clarity: detection of when an action needs to be taken,
followed by taking action. This simplification means that we can only
perform one action per invocation, but that is reasonable because we
can control the invocations and may choose to re-run =act= until no
further action is taken.

We write the scenario detectors as extractors for =WorldView=, which
is nothing more than an expressive way of writing =if= / =else=
conditions.

We need to add agents to the farm if there is a backlog of work, we
have no agents, we have no nodes alive, and there are no pending
actions. We return a candidate node that we would like to start:

#+BEGIN_SRC scala
  private object NeedsAgent {
    def unapply(world: WorldView): Option[MachineNode] = world match {
      case WorldView(backlog, 0, managed, alive, pending, _)
           if backlog > 0 && alive.isEmpty && pending.isEmpty
             => Option(managed.head)
      case _ => None
    }
  }
#+END_SRC

If there is no backlog, we should stop all nodes that have become
stale (they are not doing any work). However, since Google charge per
hour we only shut down machines in their 58th+ minute to get the most
out of our money. We return the non-empty list of nodes to stop.

As a financial safety net, all nodes should have a maximum lifetime of
5 hours.

#+BEGIN_SRC scala
  private object Stale {
    def unapply(world: WorldView): Option[NonEmptyList[MachineNode]] =
      world match {
        case WorldView(backlog, _, _, alive, pending, time) if alive.nonEmpty =>
          (alive -- pending.keys).collect {
            case (n, started)
                if backlog == 0 && timediff(started, time).toMinutes % 60 >= 58 =>
              n
            case (n, started) if timediff(started, time) >= 5.hours => n
          }.toList.toNel

        case _ => None
      }
  }
#+END_SRC

Now that we have detected the scenarios that can occur, we can write
the =act= method. When we schedule a node to be started or stopped, we
add it to =pending= noting the time that we scheduled the action.

#+BEGIN_SRC scala
  def act(world: WorldView): F[WorldView] = world match {
    case NeedsAgent(node) =>
      for {
        _ <- M.start(node)
        update = world.copy(pending = Map(node -> world.time))
      } yield update

    case Stale(nodes) =>
      nodes.foldLeftM(world) { (world, n) =>
        for {
          _ <- M.stop(n)
          update = world.copy(pending = world.pending + (n -> world.time))
        } yield update
      }

    case _ => world.pure[F]
  }
#+END_SRC

Because =NeedsAgent= and =Stale= do not cover all possible situations,
we need a catch-all =case _= to do nothing. Recall from Chapter 2 that
=.pure= creates the =for='s (monadic) context from a value.

=foldLeftM= is like =foldLeft= over =nodes=, but each iteration of the
fold may return a monadic value. In our case, each iteration of the
fold returns =F[WorldView]=.

The =M= is for Monadic and you will find more of these /lifted/
methods that behave as one would expect, taking monadic values in
place of values.

*** Unit Tests

The FP approach to writing applications is a designer's dream: you can
delegate writing the implementations of algebras to your team members
while focusing on making your business logic meet the requirements.

Our application is highly dependent on timing and third party
webservices. If this was a traditional OOP application, we'd create
mocks for all the method calls, or test actors for the outgoing
mailboxes. FP mocking is equivalent to providing an alternative
implementation of dependency algebras. The algebras already isolate
the parts of the system that need to be mocked --- everything else is
pure.

We'll start with some test data

#+BEGIN_SRC scala
object Data {
  val node1   = MachineNode("1243d1af-828f-4ba3-9fc0-a19d86852b5a")
  val node2   = MachineNode("550c4943-229e-47b0-b6be-3d686c5f013f")
  val managed = NonEmptyList(node1, node2)

  import Instant.parse
  val time1 = parse("2017-03-03T18:07:00.000+01:00[Europe/London]")
  val time2 = parse("2017-03-03T18:59:00.000+01:00[Europe/London]") // +52 mins
  val time3 = parse("2017-03-03T19:06:00.000+01:00[Europe/London]") // +59 mins
  val time4 = parse("2017-03-03T23:07:00.000+01:00[Europe/London]") // +5 hours

  val needsAgents = WorldView(5, 0, managed, Map.empty, Map.empty, time1)
}
import Data._
#+END_SRC

We implement algebras by extending =Drone= and =Machines= with a specific
monadic context, =Id= being the simplest.

Our "mock" implementations simply play back a fixed =WorldView=. We've
isolated the state of our system, so we can use =var= to store the
state:

#+BEGIN_SRC scala
class Mutable(state: WorldView) {
  var started, stopped: Int = 0

  private val D: Drone[Id] = new Drone[Id] {
    def getBacklog: Int = state.backlog
    def getAgents: Int = state.agents
  }

  private val M: Machines[Id] = new Machines[Id] {
    def getAlive: Map[MachineNode, Instant] = state.alive
    def getManaged: NonEmptyList[MachineNode] = state.managed
    def getTime: Instant = state.time
    def start(node: MachineNode): MachineNode = { started += 1 ; node }
    def stop(node: MachineNode): MachineNode = { stopped += 1 ; node }
  }

  val program = new DynAgents[Id](D, M)
}
#+END_SRC

#+BEGIN_ASIDE
We will return to this code later on in the book and replace =var= with a
principled way of managing state.
#+END_ASIDE

When we write a unit test (here using =FlatSpec= from scalatest), we create an
instance of =Mutable= and then import all of its members.

Our implicit =drone= and =machines= both use the =Id= execution
context and therefore interpreting this program with them returns an
=Id[WorldView]= that we can assert on.

In this trivial case we just check that the =initial= method returns
the same value that we use in the static implementations:

#+BEGIN_SRC scala
  "Business Logic" should "generate an initial world view" in {
    val mutable = new Mutable(needsAgents)
    import mutable._

    program.initial shouldBe needsAgents
  }
#+END_SRC

We can create more advanced tests of the =update= and =act= methods,
helping us flush out bugs and refine the requirements:

#+BEGIN_SRC scala
  it should "remove changed nodes from pending" in {
    val world = WorldView(0, 0, managed, Map(node1 -> time3), Map.empty, time3)
    val mutable = new Mutable(world)
    import mutable._

    val old = world.copy(alive = Map.empty,
                         pending = Map(node1 -> time2),
                         time = time2)
    program.update(old) shouldBe world
  }

  it should "request agents when needed" in {
    val mutable = new Mutable(needsAgents)
    import mutable._

    val expected = needsAgents.copy(
      pending = Map(node1 -> time1)
    )

    program.act(needsAgents) shouldBe expected

    mutable.stopped shouldBe 0
    mutable.started shouldBe 1
  }
#+END_SRC

It would be boring to go through the full test suite. Convince
yourself with a thought experiment that the following tests are easy
to implement using the same approach:

- not request agents when pending
- don't shut down agents if nodes are too young
- shut down agents when there is no backlog and nodes will shortly incur new costs
- not shut down agents if there are pending actions
- shut down agents when there is no backlog if they are too old
- shut down agents, even if they are potentially doing work, if they are too old
- ignore unresponsive pending actions during update

All of these tests are synchronous and isolated to the test runner's
thread (which could be running tests in parallel). If we'd designed
our test suite in Akka, our tests would be subject to arbitrary
timeouts and failures would be hidden in logfiles.

The productivity boost of simple tests for business logic cannot be
overstated. Consider that 90% of an application developer's time
interacting with the customer is in refining, updating and fixing
these business rules. Everything else is implementation detail.

*** Parallel

The application that we have designed runs each of its algebraic
methods sequentially. But there are some obvious places where work can
be performed in parallel.

**** initial

In our definition of =initial= we could ask for all the information we
need at the same time instead of one query at a time.

As opposed to =flatMap= for sequential operations, scalaz uses
=Apply= syntax for parallel operations:

#+BEGIN_SRC scala
^^^^(D.getBacklog, D.getAgents, M.getManaged, M.getAlive, M.getTime)
#+END_SRC

which can also use infix notation:

#+BEGIN_SRC scala
(D.getBacklog |@| D.getAgents |@| M.getManaged |@| M.getAlive |@| M.getTime)
#+END_SRC

If each of the parallel operations returns a value in the same monadic
context, we can apply a function to the results when they all return.
Rewriting =update= to take advantage of this:

#+BEGIN_SRC scala
def initial: F[WorldView] =
  ^^^^(D.getBacklog, D.getAgents, M.getManaged, M.getAlive, M.getTime) {
    case (db, da, mm, ma, mt) => WorldView(db, da, mm, ma, Map.empty, mt)
  }
#+END_SRC

**** act

In the current logic for =act=, we are stopping each node
sequentially, waiting for the result, and then proceeding. But we
could stop all the nodes in parallel and then update our view of the
world.

A disadvantage of doing it this way is that any failures will cause us
to short-circuit before updating the =pending= field. But that's a
reasonable tradeoff since our =update= will gracefully handle the case
where a =node= is shut down unexpectedly.

We need a method that operates on =NonEmptyList= that allows us to
=map= each element into an =F[MachineNode]=, returning an
=F[NonEmptyList[MachineNode]]=. The method is called =traverse=, and
when we =flatMap= over it we get a =NonEmptyList[MachineNode]= that we
can deal with in a simple way:

#+BEGIN_SRC scala
      for {
        stopped <- nodes.traverse(M.stop)
        updates = stopped.map(_ -> world.time).toList.toMap
        update = world.copy(pending = world.pending ++ updates)
      } yield update
#+END_SRC

Arguably, this is easier to understand than the sequential version.

**** Parallel Interpretation

Marking something as suitable for parallel execution does not guarantee that it
will be executed in parallel: that is the responsibility of the implementation.
Not to state the obvious: parallel execution is supported by =Future=, but not
=Id=.

Of course, we need to be careful when implementing algebras such that they can
perform operations safely in parallel, perhaps requiring protecting internal
state with concurrency locks or actors.

*** Summary

1. /algebras/ define the interface between systems.
2. /modules/ define pure logic and depend on algebras and other modules.
3. Test implementations can mock out the side-effecting parts of the system,
   enabling a high level of test coverage for the business logic.
4. algebraic methods can be performed in parallel by taking their
   product or traversing sequences (caveat emptor, revisited later).

** Data and Functionality

From OOP we are used to thinking about data and functionality
together: class hierarchies carry methods, and traits can demand that
data fields exist. Runtime polymorphism of an object is in terms of
"is a" relationships, requiring classes to inherit from common
interfaces. This can get messy as a codebase grows. Simple data types
become obscured by hundreds of lines of methods, trait mixins suffer
from initialisation order errors, and testing / mocking of highly
coupled components becomes a chore.

FP takes a different approach, defining data and functionality
separately. In this chapter, we will cover the basics of data types
and the advantages of constraining ourselves to a subset of the Scala
language. We will also discover /typeclasses/ as a way to achieve
compiletime polymorphism: thinking about functionality of a data
structure in terms of "has a" rather than "is a" relationships.

*** Data

The fundamental building blocks of data types are

- =final case class= also known as /products/
- =sealed abstract class= also known as /coproducts/
- =case object= and =Int=, =Double=, =String= (etc) /values/

with no methods or fields other than the constructor parameters.

The collective name for /products/, /coproducts/ and /values/ is
/Algebraic Data Type/ (ADT).

We compose data types from the =AND= and =XOR= (exclusive =OR=)
Boolean algebra: a product contains every type that it is composed of,
but a coproduct can be only one. For example

- product: =ABC = a AND b AND c=
- coproduct: =XYZ = x XOR y XOR z=

written in Scala

#+BEGIN_SRC scala
// values
case object A
type B = String
type C = Int

// product
final case class ABC(a: A.type, b: B, c: C)

// coproduct
sealed abstract class XYZ
case object X extends XYZ
case object Y extends XYZ
final case class Z(b: B) extends XYZ
#+END_SRC

**** Generalised ADTs

When we introduce a type parameter into an ADT, we call it a
/Generalised Algebraic Data Type/ (GADT).

=scalaz.IList=, a safe alternative to the stdlib =List=, is a GADT:

#+BEGIN_SRC scala
sealed abstract class IList[A]
final case class INil[A]() extends IList[A]
final case class ICons[A](head: A, tail: IList[A]) extends IList[A]
#+END_SRC

If an ADT refers to itself, we call it a /recursive type/. =IList= is
recursive because =ICons= contains a reference to =IList=.

**** Functions on ADTs

ADTs can contain /pure functions/

#+BEGIN_SRC scala
final case class UserConfiguration(accepts: Int => Boolean)
#+END_SRC

But ADTs that contain functions come with some caveats as they don't
translate perfectly onto the JVM. For example, legacy =Serializable=,
=hashCode=, =equals= and =toString= do not behave as one might
reasonably expect.

Unfortunately, =Serializable= is used by popular frameworks, despite
far superior alternatives. A common pitfall is forgetting that
=Serializable= may attempt to serialise the entire closure of a
function, which can crash production servers. A similar caveat applies
to legacy Java classes such as =Throwable=, which can carry references
to arbitrary objects. This is one of the reasons why we restrict what
can live on an ADT.

We will explore alternatives to the legacy methods when we discuss the
scalaz library in the next chapter, at the cost of losing
interoperability with some legacy Java and Scala code.

**** Exhaustivity

It is important that we use =sealed abstract class=, not just
=abstract class=, when defining a data type. Sealing a =class= means
that all subtypes must be defined in the same file, allowing the
compiler to know about them in pattern match exhaustivity checks and
in macros that eliminate boilerplate. e.g.

#+BEGIN_SRC
scala> sealed abstract class Foo
       final case class Bar(flag: Boolean) extends Foo
       final case object Baz extends Foo

scala> def thing(foo: Foo) = foo match {
         case Bar(_) => true
       }
<console>:14: error: match may not be exhaustive.
It would fail on the following input: Baz
       def thing(foo: Foo) = foo match {
                             ^
#+END_SRC

This shows the developer what they have broken when they add a new
product to the codebase. We're using =-Xfatal-warnings=, otherwise
this is just a warning.

However, the compiler will not perform exhaustivity checking if the
=class= is not sealed or if there are guards, e.g.

#+BEGIN_SRC
scala> def thing(foo: Foo) = foo match {
         case Bar(flag) if flag => true
       }

scala> thing(Baz)
scala.MatchError: Baz (of class Baz$)
  at .thing(<console>:15)
#+END_SRC

To remain safe, don't use guards on =sealed= types.

# https://github.com/scalacenter/scalafix/issues/636

The [[https://github.com/scala/scala/pull/5617][=-Xstrict-patmat-analysis=]] flag has been proposed as a language
improvement to perform additional pattern matcher checks.

**** Alternative Products and Coproducts

Another form of product is a tuple, which is like an unlabelled =final
case class=.

=(A.type, B, C)= is equivalent to =ABC= in the above example but it is
best to use =final case class= when part of an ADT because the lack of
names is awkward to deal with.

Another form of coproduct is when we nest =Either= types. e.g.

#+BEGIN_SRC scala
Either[X.type, Either[Y.type, Z]]
#+END_SRC

equivalent to the =XYZ= sealed abstract class. A cleaner syntax to define
nested =Either= types is to create an alias type ending with a colon,
allowing infix notation with association from the right:

#+BEGIN_SRC scala
type |:[L,R] = Either[L, R]

X.type |: Y.type |: Z
#+END_SRC

This is useful to create anonymous coproducts when you can't put all
the implementations into the same source file.

#+BEGIN_SRC scala
type Accepted = String |: Long |: Boolean
#+END_SRC

Yet another alternative coproduct is to create a custom =sealed abstract class=
with =final case class= definitions that simply wrap the desired type:

#+BEGIN_SRC scala
sealed abstract class Accepted
final case class AcceptedString(value: String) extends Accepted
final case class AcceptedLong(value: Long) extends Accepted
final case class AcceptedBoolean(value: Boolean) extends Accepted
#+END_SRC

Pattern matching on these forms of coproduct can be tedious, which is why [[https://contributors.scala-lang.org/t/733][Union
Types]] are being explored in the Dotty next-generation scala compiler. Macros
such as [[https://github.com/propensive/totalitarian][totalitarian]] and [[https://github.com/frees-io/iota][iotaz]] exist as alternative ways of encoding anonymous
coproducts.

#+BEGIN_ASIDE
We can also use a =sealed trait= in place of a =sealed abstract class=
but there are binary compatibility advantages to using =abstract
class=. A =sealed trait= is only needed if you need to create a
complicated ADT with multiple inheritance.
#+END_ASIDE

**** Convey Information

Besides being a container for necessary business information, data
types can be used to encode constraints. For example,

#+BEGIN_SRC scala
final case class NonEmptyList[A](head: A, tail: IList[A])
#+END_SRC

can never be empty. This makes =scalaz.NonEmptyList= a useful data type despite
containing the same information as =List=.

Product types often contain types that are far more general than is allowed. In
traditional OOP this would be handled with input validation through assertions:

#+BEGIN_SRC scala
final case class Person(name: String, age: Int) {
  require(name.nonEmpty && age > 0) // breaks Totality, don't do this!
}
#+END_SRC

Instead, we can use the =Either= data type to provide =Right[Person]= for valid
instances and protect invalid instances from propagating. Note that the
constructor is =private=:

#+BEGIN_SRC scala
final case class Person private(name: String, age: Int)
object Person {
  def apply(name: String, age: Int): Either[String, Person] = {
    if (name.nonEmpty && age > 0) Right(new Person(name, age))
    else Left(s"bad input: $name, $age")
  }
}

def welcome(person: Person): String =
  s"${person.name} you look wonderful at ${person.age}!"

for {
  person <- Person("", -1)
} yield welcome(person)
#+END_SRC

***** Refined Data Types

A clean way to restrict the values of a general type is with the =refined=
library, providing a suite of restrictions to the contents of data. To install
refined, add the following to =build.sbt=

#+BEGIN_SRC scala
libraryDependencies += "eu.timepit" %% "refined-scalaz" % "0.8.7"
#+END_SRC

and the following imports

#+BEGIN_SRC scala
import eu.timepit.refined
import refined.api.Refined
#+END_SRC

=Refined= allows us to define =Person= using adhoc refined types to capture
requirements exactly (typically written =A Refined B= rather than =Refined[A,
B]=)

#+BEGIN_SRC scala
import refined.numeric.Positive
import refined.collection.NonEmpty

final case class Person(
  name: String Refined NonEmpty,
  age: Int Refined Positive
)
#+END_SRC

=A Refined B= can be read as "an =A= that meets the requirements defined in
=B=". The underlying value can be obtained with =.value=. We can construct a
value at runtime using =.refineV=

#+BEGIN_SRC scala
scala> import refined.refineV
scala> refineV[NonEmpty]("")
Left(Predicate isEmpty() did not fail.)

scala> refineV[NonEmpty]("Sam")
Right(Sam)
#+END_SRC

And if we add the following import

#+BEGIN_SRC scala
import refined.auto._
#+END_SRC

we can construct /valid/ values at compiletime and get a compile error if the
provided value does not meet the requirements

#+BEGIN_SRC scala
scala> val sam: String Refined NonEmpty = "Sam"
Sam

scala> val empty: String Refined NonEmpty = ""
<console>:21: error: Predicate isEmpty() did not fail.
#+END_SRC

More complex requirements can be captured, for example we can use the built-in
rule =MaxSize= with the following imports

#+BEGIN_SRC scala
import refined.W
import refined.boolean.And
import refined.collection.MaxSize
#+END_SRC

capturing the requirement that the =String= must be both non-empty and have a
maximum size of 10 characters:

#+BEGIN_SRC scala
type Name = NonEmpty And MaxSize[W.`10`.T]

final case class Person(
  name: String Refined Name,
  age: Int Refined Positive
)
#+END_SRC

#+BEGIN_ASIDE
The =W= notation is short for "witness". This syntax will be much simpler in
scala 2.13, which has support for /literal types/:

#+BEGIN_SRC scala
type Name = NonEmpty And MaxSize[10]
#+END_SRC
#+END_ASIDE

It is easy to define custom requirements that are not covered by the refined
library. For example, the requirement that a =String= contains a valid
=java.net.URL= is as simple as

#+BEGIN_SRC scala
final case class Url()
object Url {
  implicit def urlValidate: refined.Validate.Plain[String, Url] =
    Validate.fromPartial(new java.net.URL(_), "Url", Url())
}
#+END_SRC

which can be used as =String Refined Url=.

**** Simple to Share

By not providing any functionality, ADTs can have a minimal set of
dependencies. This makes them easy to publish and share with other
developers. By using a simple data modelling language, it makes it
possible to interact with cross-discipline teams, such as DBAs, UI
developers and business analysts, using the actual code instead of a
hand written document as the source of truth.

Furthermore, tooling can be more easily written to produce or consume
schemas from other programming languages and wire protocols.

**** Counting Complexity

The complexity of a data type is the number of instances that can
exist. A good data type has the least amount of complexity it needs to
hold the information it conveys, and no more.

Values have a built-in complexity:

- =Unit= has one instance (why it is called "unit")
- =Boolean= has two instances
- =Int= has 4,294,967,295 instances
- =String= has effectively infinite instances

To find the complexity of a product, we multiply the complexity of
each part.

- =(Boolean, Boolean)= has 4 instances (=2*2=)
- =(Boolean, Boolean, Boolean)= has 8 instances (=2*2*2=)

To find the complexity of a coproduct, we add the complexity of each
part.

- =(Boolean |: Boolean)= has 4 instances (=2+2=)
- =(Boolean |: Boolean |: Boolean)= has 6 instances (=2+2+2=)

To find the complexity of a GADT, multiply each part by the complexity
of the type parameter:

- =Option[Boolean]= has 3 instances, =Some[Boolean]= and =None= (=2+1=)

In FP, functions are /total/ and must return an instance for every
input, no =Exception=. Minimising the complexity of inputs and outputs
is the best way to achieve totality. As a rule of thumb, it is a sign
of a badly designed function when the complexity of a function's
return value is larger than the product of its inputs: it is a source
of entropy.

The complexity of a total function itself is the number of possible
functions that can satisfy the type signature: the output to the power
of the input.

- ~Unit => Boolean~ has complexity 2
- ~Boolean => Boolean~ has complexity 4
- ~Option[Boolean] => Option[Boolean]~ has complexity 27
- ~Boolean => Int~ is a mere quintillion going on a sextillion.
- ~Int => Boolean~ is so big that if all implementations were assigned a unique
  number, each would require 4 gigabytes to represent.

In reality, ~Int => Boolean~ will be something simple like ~isOdd~, ~isEven~ or
a sparse ~BitSet~. This function, when used in an ADT, could be better replaced
with a coproduct labelling the limited set of functions that are relevant.

When our complexity is "infinity in, infinity out" we should introduce
restrictive data types and validation closer to the point of input with
=Refined= from the previous section.

The ability to count the complexity of a type signature has one other practical
application: we can find simpler type signatures with High School algebra! To go
from a type signature to its algebra of complexity, simply replace

- ~Either[A, B]~ with ~a + b~
- ~(A, B)~ with ~a * b~
- ~A => B~ with ~b ^ a~

do some rearranging, and convert back. For example, say we've designed a
framework based on callbacks and we've managed to work ourselves into the
situation where we have created this type signature:

#+BEGIN_SRC scala
(A => C) => ((B => C) => C)
#+END_SRC

We can convert and rearrange

#+BEGIN_SRC
  (c ^ (c ^ b)) ^ (c ^ a)
= c ^ ((c ^ b) * (c ^ a))
= c ^ (c ^ (a + b))
#+END_SRC

then convert back to types and get

#+BEGIN_SRC scala
(Either[A, B] => C) => C
#+END_SRC

which is much simpler: we only need to ask the users of our framework to provide
a ~Either[A, B] => C~.

The same line of reasoning can be used to prove that

#+BEGIN_SRC scala
A => B => C
#+END_SRC

is equivalent to

#+BEGIN_SRC scala
(A, B) => C
#+END_SRC

also known as /Currying/.

**** Prefer Coproduct over Product

An archetypal modelling problem that comes up a lot is when there are
mutually exclusive configuration parameters =a=, =b= and =c=. The
product =(a: Boolean, b: Boolean, c: Boolean)= has complexity 8
whereas the coproduct

#+BEGIN_SRC scala
sealed abstract class Config
object Config {
  case object A extends Config
  case object B extends Config
  case object C extends Config
}
#+END_SRC

has a complexity of 3. It is better to model these configuration
parameters as a coproduct rather than allowing 5 invalid states to
exist.

The complexity of a data type also has implications on testing. It is
practically impossible to test every possible input to a function, but it is
easy to test a sample of values with the [[https://www.scalacheck.org/][scalacheck]] property testing framework.
If a random sample of a data type has a low probability of being valid, it is a
sign that the data is modelled incorrectly.

**** Optimisations

A big advantage of using a simplified subset of the Scala language to
represent data types is that tooling can optimise the JVM bytecode
representation.

For example, we can pack =Boolean= and =Option= fields into an =Array[Byte]=,
cache instances, memoise =hashCode=, optimise =equals=, use =@switch= statements
when pattern matching, and much more.

These optimisations are not applicable to OOP =class= hierarchies that
may be managing state, throwing exceptions, or providing adhoc method
implementations.

**** Generic Representation

We showed that product is synonymous with tuple and coproduct is
synonymous with nested =Either=. The [[https://github.com/milessabin/shapeless][shapeless]] library takes this
duality to the extreme and introduces a representation that is
/generic/ for all ADTs:

- =shapeless.HList= (symbolically =::=) for representing products
  (=scala.Product= already exists for another purpose)
- =shapeless.Coproduct= (symbolically =:+:=) for representing coproducts

Shapeless provides the ability to convert back and forth between a
generic representation and the ADT, allowing functions to be written
that work *for every* =final case class= and =sealed abstract class=.

#+BEGIN_SRC
scala> import shapeless._
       final case class Foo(a: String, b: Long)
       Generic[Foo].to(Foo("hello", 13L))
res: String :: Long :: HNil = hello :: 13 :: HNil

scala> Generic[Foo].from("hello" :: 13L :: HNil)
res: Foo = Foo(hello,13)

scala> sealed abstract class Bar
       case object Irish extends Bar
       case object English extends Bar

scala> Generic[Bar].to(Irish)
res: English.type :+: Irish.type :+: CNil = Inl(Irish)

scala> Generic[Bar].from(Inl(Irish))
res: Bar = Irish
#+END_SRC

=HNil= is the empty product and =CNil= is the empty coproduct.

It is not necessary to know how to write generic code to be able to
make use of shapeless. However, it is an important part of FP Scala so
we will return to it later with a dedicated chapter.

*** Functionality

Pure functions are typically defined as methods on an =object=.

#+BEGIN_SRC scala
package object math {
  def sin(x: Double): Double = java.lang.Math.sin(x)
  ...
}

math.sin(1.0)
#+END_SRC

However, it can be clunky to use =object= methods since it reads
inside-out, not left to right. In addition, a function on an =object=
steals the namespace. If we were to define =sin(t: T)= somewhere else
we get /ambiguous reference/ errors. This is the same problem as
Java's static methods vs class methods.

#+BEGIN_WARNING
If you like to put methods on a =trait=, requiring users to mix your
traits into their =classes= or =objects= with the /cake pattern/,
please get out of this nasty habit: you're leaking internal
implementation detail to public APIs, bloating your bytecode, and
creating a lot of noise for IDE autocompleters.
#+END_WARNING

With the =implicit class= language feature (also known as /extension
methodology/ or /syntax/), and a little boilerplate, we can get the
familiar style:

#+BEGIN_SRC scala
scala> implicit class DoubleOps(x: Double) {
         def sin: Double = math.sin(x)
       }

scala> 1.0.sin
res: Double = 0.8414709848078965
#+END_SRC

Often it is best to just skip the =object= definition and go straight
for an =implicit class=, keeping boilerplate to a minimum:

#+BEGIN_SRC scala
implicit class DoubleOps(x: Double) {
  def sin: Double = java.lang.Math.sin(x)
}
#+END_SRC

#+BEGIN_ASIDE
=implicit class= is syntax sugar for an implicit conversion:

#+BEGIN_SRC scala
implicit def DoubleOps(x: Double): DoubleOps = new DoubleOps(x)
class DoubleOps(x: Double) {
  def sin: Double = java.lang.Math.sin(x)
}
#+END_SRC

Which unfortunately has a runtime cost: each time the extension method
is called, an intermediate =DoubleOps= will be constructed and then
thrown away. This can contribute to GC pressure in hotspots.

There is a slightly more verbose form of =implicit class= that avoids
the allocation and is therefore preferred:

#+BEGIN_SRC scala
implicit final class DoubleOps(val x: Double) extends AnyVal {
  def sin: Double = java.lang.Math.sin(x)
}
#+END_SRC
#+END_ASIDE

**** Polymorphic Functions

The more common kind of function is a polymorphic function, which
lives in a /typeclass/. A typeclass is a trait that:

- holds no state
- has a type parameter
- has at least one abstract method (/primitive combinators/)
- may contain /generalised/ methods (/derived combinators/)
- may extend other typeclasses

There can only be one implementation of a typeclass for any given type
parameter, a property known as /typeclass coherence/. Typeclasses look
superficially similar to algebraic interfaces from the previous chapter, but
algebras do not have to be coherent.

#+BEGIN_ASIDE
Typeclass coherence is primarily about consistency, and the consistency gives us
the confidence to use =implicit= parameters. It would be difficult to reason
about code that performs differently depending on the implicit imports that are
in scope. Typeclass coherence effectively says that imports should not impact
the behaviour of the code.

Additionally, typeclass coherence allows us to globally cache implicits at
runtime and save memory allocations, gaining performance improvements from
reduced pressure on the garbage collector.
#+END_ASIDE

Typeclasses are used in the Scala stdlib. We'll explore a simplified
version of =scala.math.Numeric= to demonstrate the principle:

#+BEGIN_SRC scala
trait Ordering[T] {
  def compare(x: T, y: T): Int

  def lt(x: T, y: T): Boolean = compare(x, y) < 0
  def gt(x: T, y: T): Boolean = compare(x, y) > 0
}

trait Numeric[T] extends Ordering[T] {
  def plus(x: T, y: T): T
  def times(x: T, y: T): T
  def negate(x: T): T
  def zero: T

  def abs(x: T): T = if (lt(x, zero)) negate(x) else x
}
#+END_SRC

We can see all the key features of a typeclass in action:

- there is no state
- =Ordering= and =Numeric= have type parameter =T=
- =Ordering= has abstract =compare= and =Numeric= has abstract =plus=,
  =times=, =negate= and =zero=
- =Ordering= defines generalised =lt= and =gt= based on =compare=,
  =Numeric= defines =abs= in terms of =lt=, =negate= and =zero=.
- =Numeric= extends =Ordering=

We can now write functions for types that "have a" =Numeric=
typeclass:

#+BEGIN_SRC scala
def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {
  import N._
  times(negate(abs(t)), t)
}
#+END_SRC

We are no longer dependent on the OOP hierarchy of our input types,
i.e. we don't demand that our input "is a" =Numeric=, which is vitally
important if we want to support a third party class that we cannot
redefine.

Another advantage of typeclasses is that the association of
functionality to data is at compiletime, as opposed to OOP runtime
dynamic dispatch.

For example, whereas the =List= class can only have one implementation
of a method, a typeclass method allows us to have a different
implementation depending on the =List= contents and therefore offload
work to compiletime instead of leaving it to runtime.

**** Syntax

The syntax for writing =signOfTheTimes= is clunky, there are some
things we can do to clean it up.

Downstream users will prefer to see our method use /context bounds/,
since the signature reads cleanly as "takes a =T= that has a
=Numeric="

#+BEGIN_SRC scala
def signOfTheTimes[T: Numeric](t: T): T = ...
#+END_SRC

but now we have to use =implicitly[Numeric[T]]= everywhere. By
defining boilerplate on the companion of the typeclass

#+BEGIN_SRC scala
object Numeric {
  def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
}
#+END_SRC

we can obtain the implicit with less noise

#+BEGIN_SRC scala
def signOfTheTimes[T: Numeric](t: T): T = {
  val N = Numeric[T]
  import N._
  times(negate(abs(t)), t)
}
#+END_SRC

But it is still worse for us as the implementors. We have the
syntactic problem of inside-out static methods vs class methods. We
deal with this by introducing =ops= on the typeclass companion:

#+BEGIN_SRC scala
object Numeric {
  def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric

  object ops {
    implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {
      def +(o: T): T = N.plus(t, o)
      def *(o: T): T = N.times(t, o)
      def unary_-: T = N.negate(t)
      def abs: T = N.abs(t)

      // duplicated from Ordering.ops
      def <(o: T): T = N.lt(t, o)
      def >(o: T): T = N.gt(t, o)
    }
  }
}
#+END_SRC

Note that =-x= is expanded into =x.unary_-= by the compiler's syntax
sugar, which is why we define =unary_-= as an extension method. We can
now write the much cleaner:

#+BEGIN_SRC scala
import Numeric.ops._
def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
#+END_SRC

The good news is that we never need to write this boilerplate because
[[https://github.com/mpilquist/simulacrum][Simulacrum]] provides a =@typeclass= macro annotation to have the
companion =apply= and =ops= automatically generated. It even allows us
to define alternative (usually symbolic) names for common methods. In
full:

#+BEGIN_SRC scala
import simulacrum._

@typeclass trait Ordering[T] {
  def compare(x: T, y: T): Int
  @op("<") def lt(x: T, y: T): Boolean = compare(x, y) < 0
  @op(">") def gt(x: T, y: T): Boolean = compare(x, y) > 0
}

@typeclass trait Numeric[T] extends Ordering[T] {
  @op("+") def plus(x: T, y: T): T
  @op("*") def times(x: T, y: T): T
  @op("unary_-") def negate(x: T): T
  def zero: T
  def abs(x: T): T = if (lt(x, zero)) negate(x) else x
}

import Numeric.ops._
def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
#+END_SRC

**** Instances

/Instances/ of =Numeric= (which are also instances of =Ordering=) are
defined as an =implicit val= that extends the typeclass, and can
provide optimised implementations for the generalised methods:

#+BEGIN_SRC scala
implicit val NumericDouble: Numeric[Double] = new Numeric[Double] {
  def plus(x: Double, y: Double): Double = x + y
  def times(x: Double, y: Double): Double = x * y
  def negate(x: Double): Double = -x
  def zero: Double = 0.0
  def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)

  // optimised
  override def lt(x: Double, y: Double): Boolean = x < y
  override def gt(x: Double, y: Double): Boolean = x > y
  override def abs(x: Double): Double = java.lang.Math.abs(x)
}
#+END_SRC

Although we are using =+=, =*=, =unary_-=, =<= and =>= here, which are
the ops (and could be an infinite loop!), these methods exist already
on =Double=. Class methods are always used in preference to extension
methods. Indeed, the scala compiler performs special handling of
primitives and converts these method calls into raw =dadd=, =dmul=,
=dcmpl= and =dcmpg= bytecode instructions, respectively.

We can also implement =Numeric= for Java's =BigDecimal= class (avoid
=scala.BigDecimal=, [[https://github.com/scala/bug/issues/9670][it is fundamentally broken]])

#+BEGIN_SRC scala
import java.math.{ BigDecimal => BD }

implicit val NumericBD: Numeric[BD] = new Numeric[BD] {
  def plus(x: BD, y: BD): BD = x.add(y)
  def times(x: BD, y: BD): BD = x.multiply(y)
  def negate(x: BD): BD = x.negate
  def zero: BD = BD.ZERO
  def compare(x: BD, y: BD): Int = x.compareTo(y)
}
#+END_SRC

We could even take some liberties and create our own data structure
for complex numbers:

#+BEGIN_SRC scala
final case class Complex[T](r: T, i: T)
#+END_SRC

And derive a =Numeric[Complex[T]]= if =Numeric[T]= exists. Since these
instances depend on the type parameter, it is a =def=, not a =val=.

#+BEGIN_SRC scala
implicit def numericComplex[T: Numeric]: Numeric[Complex[T]] =
  new Numeric[Complex[T]] {
    type CT = Complex[T]
    def plus(x: CT, y: CT): CT = Complex(x.r + y.r, x.i + y.i)
    def times(x: CT, y: CT): CT =
      Complex(x.r * y.r + (-x.i * y.i), x.r * y.i + x.i * y.r)
    def negate(x: CT): CT = Complex(-x.r, -x.i)
    def zero: CT = Complex(Numeric[T].zero, Numeric[T].zero)
    def compare(x: CT, y: CT): Int = {
      val real = (Numeric[T].compare(x.r, y.r))
      if (real != 0) real
      else Numeric[T].compare(x.i, y.i)
    }
  }
#+END_SRC

The observant reader may notice that =abs= is not at all what a
mathematician would expect. The correct return value for =abs= should
be =T=, not =Complex[T]=.

=scala.math.Numeric= tries to do too much and does not generalise
beyond real numbers. This is a good lesson that smaller, well defined,
typeclasses are often better than a monolithic collection of overly
specific features.

If you need to write generic code that works for a wide range of
number types, prefer [[https://github.com/non/spire][spire]] to the stdlib. Indeed, in the next chapter
we will see that concepts such as having a zero element, or adding two
values, are worthy of their own typeclass.

**** Implicit Resolution

We've discussed implicits a lot: this section is to clarify what
implicits are and how they work.

/Implicit parameters/ are when a method requests that a unique
instance of a particular type is in the /implicit scope/ of the
caller, with special syntax for typeclass instances. Implicit
parameters are a clean way to thread configuration through an
application.

In this example, =foo= requires that typeclasses for =Numeric= and
shapeless' =Typeable= are available for =T=, as well as an implicit
(user-defined) =Config= object.

#+BEGIN_SRC scala
def foo[T: Numeric: Typeable](implicit conf: Config) = ...
#+END_SRC

/Implicit conversion/ is when an =implicit def= exists. One such use
of implicit conversions is to enable extension methodology. When the
compiler is resolving a call to a method, it first checks if the
method exists on the type, then its ancestors (Java-like rules). If it
fails to find a match, it will search the /implicit scope/ for
conversions to other types, then search for methods on those types.

Another use for implicit conversion is /typeclass derivation/. In the
previous section we wrote an =implicit def= that derived a
=Numeric[Complex[T]]= if a =Numeric[T]= is in the implicit scope. It
is possible to chain together many =implicit def= (including
recursively) which is the basis of /typeful programming/, allowing for
computations to be performed at compiletime rather than runtime.

The glue that combines implicit parameters (receivers) with implicit
conversion (providers) is implicit resolution.

First, the normal variable scope is searched for implicits, in order:

- local scope, including scoped imports (e.g. the block or method)
- outer scope, including scoped imports (e.g. members in the class)
- ancestors (e.g. members in the super class)
- the current package object
- ancestor package objects (only when using nested packages)
- the file's imports

If that fails to find a match, the special scope is searched, which
looks for implicit instances inside a type's companion, its package
object, outer objects (if nested), and then repeated for ancestors.
This is performed, in order, for the:

- given parameter type
- expected parameter type
- type parameter (if there is one)

If two matching implicits are found in the same phase of implicit
resolution, an /ambiguous implicit/ error is raised.

Implicits are often defined on a =trait=, which is then extended by an
object. This is to try and control the priority of an implicit
relative to another more specific one, to avoid ambiguous implicits.

The Scala Language Specification is rather vague for corner cases, and
the compiler implementation is the /de facto/ standard. There are some
rules of thumb that we will use throughout this book, e.g. prefer
=implicit val= over =implicit object= despite the temptation of less
typing. It is a [[https://github.com/scala/bug/issues/10411][quirk of implicit resolution]] that =implicit object= on
companion objects are not treated the same as =implicit val=.

Implicit resolution falls short when there is a hierarchy of
typeclasses, like =Ordering= and =Numeric=. If we write a function
that takes an implicit =Ordering=, and we call it for a type which has
an instance of =Numeric= defined on the =Numeric= companion, the
compiler will fail to find it. A workaround is to add implicit
conversions to the companion of =Ordering= that up-cast more specific
instances. [[https://github.com/lampepfl/dotty/issues/2047][Fixed In Dotty]].

Implicit resolution is particularly hit-or-miss [[https://github.com/scala/bug/issues/10582][if type aliases are used]] where
the /shape/ of the implicit parameters are changed. For example an implicit
parameter using an alias such as ~type Values[A] = List[Option[A]]~ will
probably fail to find implicits defined as raw =List[Option[A]]= because the
shape is changed from a /thing of things/ of =A= to a /thing/ of =A=.

# might also be fixed in scato
# https://github.com/aloiscochard/scato/issues/15

*** Modelling OAuth2

We will finish this chapter with a practical example of data modelling
and typeclass derivation, combined with algebra / module design from
the previous chapter.

In our =drone-dynamic-agents= application, we must communicate with
Drone and Google Cloud using JSON over REST. Both services use [[https://tools.ietf.org/html/rfc6749][OAuth2]]
for authentication. Although there are many ways to interpret OAuth2,
we'll focus on the version that works for Google Cloud (the Drone
version is even simpler).

**** Description

Every Google Cloud application needs to have an /OAuth 2.0 Client Key/
set up at

#+BEGIN_SRC
https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
#+END_SRC

You will be provided with a /Client ID/ and a /Client secret/.

The application can then obtain a one time /code/ by making the user
perform an /Authorization Request/ in their browser (yes, really, *in
their browser*). We need to make this page open in the browser:

#+BEGIN_SRC
https://accounts.google.com/o/oauth2/v2/auth?\
  redirect_uri={CALLBACK_URI}&\
  prompt=consent&\
  response_type=code&\
  scope={SCOPE}&\
  access_type=offline&\
  client_id={CLIENT_ID}
#+END_SRC

The /code/ is delivered to the ={CALLBACK_URI}= in a =GET= request. To
capture it in our application, we need to have a web server listening
on =localhost=.

Once we have the /code/, we can perform an /Access Token Request/:

#+BEGIN_SRC
POST /oauth2/v4/token HTTP/1.1
Host: www.googleapis.com
Content-length: {CONTENT_LENGTH}
content-type: application/x-www-form-urlencoded
user-agent: google-oauth-playground
code={CODE}&\
  redirect_uri={CALLBACK_URI}&\
  client_id={CLIENT_ID}&\
  client_secret={CLIENT_SECRET}&\
  scope={SCOPE}&\
  grant_type=authorization_code
#+END_SRC

which gives a JSON response payload

#+BEGIN_SRC json
{
  "access_token": "BEARER_TOKEN",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "REFRESH_TOKEN"
}
#+END_SRC

/Bearer tokens/ typically expire after an hour, and can be refreshed
by sending an HTTP request with any valid /refresh token/:

#+BEGIN_SRC
POST /oauth2/v4/token HTTP/1.1
Host: www.googleapis.com
Content-length: {CONTENT_LENGTH}
content-type: application/x-www-form-urlencoded
user-agent: google-oauth-playground
client_secret={CLIENT_SECRET}&
  grant_type=refresh_token&
  refresh_token={REFRESH_TOKEN}&
  client_id={CLIENT_ID}
#+END_SRC

responding with

#+BEGIN_SRC json
{
  "access_token": "BEARER_TOKEN",
  "token_type": "Bearer",
  "expires_in": 3600
}
#+END_SRC

Google expires all but the most recent 50 /bearer tokens/, so the
expiry times are just guidance. The /refresh tokens/ persist between
sessions and can be expired manually by the user. We can therefore
have a one-time setup application to obtain the refresh token and then
include the refresh token as configuration for the user's install of
the headless server.

**** Data

The first step is to model the data needed for OAuth2. We create an ADT with
fields having exactly the same name as required by the OAuth2 server. We will
use =String= and =Long= for brevity, but we could use refined types if they leak
into our business models.

#+BEGIN_SRC scala
package http.oauth2.client.api

import refined.api.Refined
import refined.string.Url

final case class AuthRequest(
  redirect_uri: String Refined Url,
  scope: String,
  client_id: String,
  prompt: String = "consent",
  response_type: String = "code",
  access_type: String = "offline"
)
final case class AccessRequest(
  code: String,
  redirect_uri: String Refined Url,
  client_id: String,
  client_secret: String,
  scope: String = "",
  grant_type: String = "authorization_code"
)
final case class AccessResponse(
  access_token: String,
  token_type: String,
  expires_in: Long,
  refresh_token: String
)
final case class RefreshRequest(
  client_secret: String,
  refresh_token: String,
  client_id: String,
  grant_type: String = "refresh_token"
)
final case class RefreshResponse(
  access_token: String,
  token_type: String,
  expires_in: Long
)
#+END_SRC

#+BEGIN_WARNING
Avoid using =java.net.URL= at all costs: it uses DNS to resolve the
hostname part when performing =toString=, =equals= or =hashCode=.

Apart from being insane, and *very very* slow, these methods can throw
I/O exceptions (are not /pure/), and can change depending on your
network configuration (are not /deterministic/).

The refined type =String Refined Url= allows us to perform equality checks based
on the =String= and we can safely construct a =URL= only if it is needed by a
legacy API.
#+END_WARNING

**** Functionality

We need to marshal the data classes we defined in the previous section
into JSON, URLs and POST-encoded forms. Since this requires
polymorphism, we will need typeclasses.

[[https://github.com/spray/spray-json][spray-json]] gives us an ADT for JSON and typeclasses to convert to/from that ADT
(paraphrased for brevity):

#+BEGIN_SRC scala
package spray.json

sealed abstract class JsValue
case object JsNull extends JsValue
final case class JsBoolean(value: Boolean) extends JsValue
final case class JsNumber(value: BigDecimal) extends JsValue
final case class JsString(value: String) extends JsValue
final case class JsArray(value: Vector[JsValue]) extends JsValue
final case class JsObject(fields: Map[String, JsValue]) extends JsValue

@typeclass trait JsonWriter[T] {
  def toJson(t: T): JsValue
}
@typeclass trait JsonReader[T] {
  def fromJson(j: JsValue): T
}
#+END_SRC

To depend on =spray-json= in our project we must add the following to
=build.sbt=:

#+BEGIN_SRC scala
libraryDependencies += "xyz.driver" %% "spray-json-derivation" % "0.4.1"
#+END_SRC

Because =spray-json-derivation= provides /derived/ typeclass instances, we can
conjure up a =JsonReader[AccessResponse]= and =JsonReader[RefreshResponse]=.
This is an example of parsing text into =AccessResponse=:

#+BEGIN_SRC scala
scala> import spray.json.ImplicitDerivedFormats._

       for {
         json     <- spray.json.JsonParser("""
                     {
                       "access_token": "BEARER_TOKEN",
                       "token_type": "Bearer",
                       "expires_in": 3600,
                       "refresh_token": "REFRESH_TOKEN"
                     }
                     """)
         response <- JsonReader[AccessResponse].fromJson(json)
       } yield response

res = AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
#+END_SRC

We need to write our own typeclasses for URL and POST encoding. The
following is a reasonable design:

#+BEGIN_SRC scala
package http.encoding

final case class UrlQuery(params: List[(String, String)]) {
  def forUrl(url: String Refined Url): String Refined Url = ...
}

@typeclass trait UrlQueryWriter[A] {
  def toUrlQuery(a: A): UrlQuery
}

@typeclass trait UrlEncodedWriter[A] {
  def toUrlEncoded(a: A): String
}
#+END_SRC

We need to provide typeclass instances for basic types:

#+BEGIN_SRC scala
object UrlEncodedWriter {
  import ops._
  implicit val string: UrlEncodedWriter[String] =
    { s => java.net.URLEncoder.encode(s, "UTF-8") }
  implicit val long: UrlEncodedWriter[Long] = _.toString
  implicit val stringySeq: UrlEncodedWriter[Seq[(String, String)]] =
    _.map { case (k, v) => s"${k.toUrlEncoded}=${v.toUrlEncoded}" }.mkString("&")
  implicit val url: UrlEncodedWriter[String Refined Url] =
    { s => java.net.URLEncoder.encode(s.value, "UTF-8") }
}
#+END_SRC

#+BEGIN_ASIDE
=UrlEncodedWriter= is making use of the /Single Abstract Method/ (SAM types)
Scala language feature. The full form of the above is

#+BEGIN_SRC scala
  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
#+END_SRC

When the Scala compiler expects a class (which has a single abstract
method) but receives a lambda, it fills in the boilerplate
automatically.

Prior to SAM types, a common pattern was to define a method named
=instance= on the typeclass companion

#+BEGIN_SRC scala
def instance[T](f: T => String): UrlEncodedWriter[T] =
  new UrlEncodedWriter[T] {
    override def toUrlEncoded(t: T): String = f(t)
  }
#+END_SRC

allowing for

#+BEGIN_SRC scala
implicit val string: UrlEncodedWriter[String] = instance { s => ... }
#+END_SRC

This pattern is still used in code that must support older versions of
Scala, or for typeclasses instances that need to provide more than one
method.
#+END_ASIDE

In a dedicated chapter on /Typeclass Derivation/ we will calculate instances of
=UrlQueryWriter= and =UrlEncodedWriter= automatically, but for now we will write
the boilerplate for the types we wish to convert:

#+BEGIN_SRC scala
  import UrlEncodedWriter.ops._
  object AuthRequest {
    private def stringify[T: UrlEncodedWriter](t: T) =
      java.net.URLDecoder.decode(t.toUrlEncoded, "UTF-8")

    implicit val query: UrlQueryWriter[AuthRequest] = { a =>
      UriQuery(List(
        ("redirect_uri"  -> stringify(a.redirect_uri)),
        ("scope"         -> stringify(a.scope)),
        ("client_id"     -> stringify(a.client_id)),
        ("prompt"        -> stringify(a.prompt)),
        ("response_type" -> stringify(a.response_type)),
        ("access_type"   -> stringify(a.access_type)))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =>
      Seq(
        "code"          -> a.code.toUrlEncoded,
        "redirect_uri"  -> a.redirect_uri.toUrlEncoded,
        "client_id"     -> a.client_id.toUrlEncoded,
        "client_secret" -> a.client_secret.toUrlEncoded,
        "scope"         -> a.scope.toUrlEncoded,
        "grant_type"    -> a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =>
      Seq(
        "client_secret" -> r.client_secret.toUrlEncoded,
        "refresh_token" -> r.refresh_token.toUrlEncoded,
        "client_id"     -> r.client_id.toUrlEncoded,
        "grant_type"    -> r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
#+END_SRC

**** Module

That concludes the data and functionality modelling required to
implement OAuth2. Recall from the previous chapter that we define
mockable components that need to interact with the world as algebras,
and we define pure business logic in a module.

We define our dependency algebras, and use context bounds to show that our
responses must have a =JsonReader= and our =POST= payload must have a
=UrlEncodedWriter=:

#+BEGIN_SRC scala
package http.client.algebra

final case class Response[T](header: HttpResponseHeader, body: T)

trait JsonHttpClient[F[_]] {
  def get[B: JsonReader](
    uri: String Refined Url,
    headers: List[HttpHeader] = Nil
  ): F[Response[B]]

  def postUrlencoded[A: UrlEncoded, B: JsonReader](
    uri: String Refined Url,
    payload: A,
    headers: List[HttpHeader] = Nil
  ): F[Response[B]]
}
#+END_SRC

#+BEGIN_SRC scala
package http.oauth2.client.algebra

final case class CodeToken(token: String, redirect_uri: String Refined Url)

trait UserInteraction[F[_]] {
  /** returns the URL of the local server */
  def start: F[String Refined Url]

  /** prompts the user to open this URL */
  def open(uri: String Refined Url): F[Unit]

  /** recover the code from the callback */
  def stop: F[CodeToken]
}

trait LocalClock[F[_]] {
  def now: F[java.time.LocalDateTime]
}
#+END_SRC

some convenient data classes

#+BEGIN_SRC scala
final case class ServerConfig(
  auth: String Refined Url,
  access: String Refined Url,
  refresh: String Refined Url,
  scope: String,
  clientId: String,
  clientSecret: String
)
final case class RefreshToken(token: String)
final case class BearerToken(token: String, expires: LocalDateTime)
#+END_SRC

and then write an OAuth2 client:

#+BEGIN_SRC scala
import java.time.temporal.ChronoUnit
import http.encoding.UrlQueryWriter.ops._
import spray.json.ImplicitDerivedFormats._

class OAuth2Client[F[_]: Monad](
  config: ServerConfig
)(
  implicit
  user: UserInteraction[F],
  client: JsonHttpClient[F],
  clock: LocalClock[F]
) {
  def authenticate: F[CodeToken] =
    for {
      callback <- user.start
      params   = AuthRequest(callback, config.scope, config.clientId)
      _        <- user.open(params.toUrlQuery.forUrl(config.auth))
      code     <- user.stop
    } yield code

  def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
    for {
      request <- AccessRequest(code.token,
                               code.redirect_uri,
                               config.clientId,
                               config.clientSecret).pure[F]
      response <- client.postUrlencoded[AccessRequest, AccessResponse](
                   config.access, request)
      time    <- clock.now
      msg     = response.body
      expires = time.plus(msg.expires_in, ChronoUnit.SECONDS)
      refresh = RefreshToken(msg.refresh_token)
      bearer  = BearerToken(msg.access_token, expires)
    } yield (refresh, bearer)

  def bearer(refresh: RefreshToken): F[BearerToken] =
    for {
      request <- RefreshRequest(config.clientSecret,
                                refresh.token,
                                config.clientId).pure[F]
      response <- client.postUrlencoded[RefreshRequest, RefreshResponse](
                   config.refresh, request)
      time    <- clock.now
      msg     = response.body
      expires = time.plus(msg.expires_in, ChronoUnit.SECONDS)
      bearer  = BearerToken(msg.access_token, expires)
    } yield bearer
}
#+END_SRC

*** Summary

- data types are defined as /products/ (=final case class=) and
  /coproducts/ (=sealed abstract class=).
- =Refined= types can enforce constraints on values
- specific functions are defined on =implicit class=
- polymorphic functions are defined as /typeclasses/. Functionality is
  provided via "has a" /context bounds/, rather than "is a" class
  hierarchies.
- /typeclass instances/ are implementations of the typeclass.
- =@simulacrum.typeclass= generates =.ops= on the companion, providing
  convenient syntax for types that have a typeclass instance.
- /typeclass derivation/ is compiletime composition of typeclass
  instances.
- /generic instances/ automatically derive instances for your data
  types.

** Scalaz Typeclasses

In this chapter we will tour most of the typeclasses in =scalaz-core=.
We don't use everything in =drone-dynamic-agents= so we will give
standalone examples when appropriate.

There has been criticism of the naming in scalaz, and functional
programming in general. Most names follow the conventions introduced
in the Haskell programming language, based on /Category Theory/. Feel
free to set up =type= aliases in your own codebase if you would prefer
to use verbs based on the primary functionality of the typeclass (e.g.
=Mappable=, =Pureable=, =FlatMappable=) until you are comfortable with
the standard names.

Before we introduce the typeclass hierarchy, we will peek at the four
most important methods from a control flow perspective: the methods we
will use the most in typical FP applications:

| Typeclass     | Method     | From   | Given       | To        |
|---------------+------------+--------+-------------+-----------|
| ~Functor~     | ~map~      | ~F[A]~ | ~A => B~    | ~F[B]~    |
| ~Applicative~ | ~pure~     | ~A~    |             | ~F[A]~    |
| ~Monad~       | ~flatMap~  | ~F[A]~ | ~A => F[B]~ | ~F[B]~    |
| ~Traverse~    | ~traverse~ | ~F[A]~ | ~A => G[B]~ | ~G[F[B]]~ |

We know that operations which return a =F[_]= can be run sequentially
in a =for= comprehension by =.flatMap=, defined on its =Monad[F]=. The
context =F[_]= can be thought of as a container for an intentional
/effect/ with =A= as the output: =flatMap= allows us to generate new
effects =F[B]= at runtime based on the results of evaluating previous
effects.

Of course, not all type constructors =F[_]= are effectful, even if
they have a =Monad[F]=. Often they are data structures. By using the
least specific abstraction, we can reuse code for =List=, =Either=,
=Future= and more.

If we only need to transform the output from an =F[_]=, that's just
=map=, introduced by =Functor=. In Chapter 3, we ran effects in
parallel by creating a product and mapping over them. In Functional
Programming, parallelisable computations are considered *less*
powerful than sequential ones.

In between =Monad= and =Functor= is =Applicative=, defining =pure=
that lets us lift a value into an effect, or create a data structure
from a single value.

=traverse= is useful for rearranging type constructors. If you find
yourself with an =F[G[_]]= but you really need a =G[F[_]]= then you
need =Traverse=. For example, say you have a =List[Future[Int]]= but
you need it to be a =Future[List[Int]]=, just call
=.traverse(identity)=, or its simpler sibling =.sequence=.

*** Agenda

This chapter is longer than usual and jam-packed with information: it
is perfectly reasonable to attack it over several sittings. You are
not expected to remember everything (doing so would require
super-human powers) so treat this chapter as a way of knowing where to
look for more information.

Notably absent are typeclasses that extend =Monad=, which get their
own chapter later.

Scalaz uses code generation, not simulacrum. However, for brevity, we present
code snippets with =@typeclass=. Equivalent syntax is available when we =import
scalaz._, Scalaz._= and is available under the =scalaz.syntax= package in the
scalaz source code.

#+BEGIN_SRC dot :file images/scalaz-core-tree.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Cobind;
    Comonad;
    Bind;
    Contravariant;
    Functor;
    InvariantFunctor;
    Functor;
    Divide;
    Divisible;
    Apply;
    Align;
    Applicative;
    Foldable1;
    Foldable;
    Traverse;
    Traverse1;
    Monad;
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Cobind -> Functor;
    Comonad -> Cobind;

    Bind -> Apply;

    Contravariant -> InvariantFunctor;
    Functor -> InvariantFunctor;

    Divide -> Contravariant;
    Divisible -> Divide;
    Apply -> Functor;
    Applicative -> Apply;

    Foldable1 -> Foldable;
    Traverse -> Functor;
    Traverse -> Foldable;
    Traverse1 -> Traverse;
    Traverse1 -> Foldable1;

    Align -> Functor;

    Monad -> Applicative;

    "Advanced Monads" [style=dashed];
    "Advanced Monads" -> Monad;

    Monad -> Bind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;

}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-core-tree.png]]

#+BEGIN_SRC dot :file images/scalaz-core-cliques.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Monoid -> Semigroup;
    Band -> Semigroup;

    Order -> Equal;
    Enum -> Order;

    Bitraverse -> Bifunctor;
    Bitraverse -> Bifoldable;

    Category -> Compose;
    Choice -> Category;
    Split -> Compose;
    Strong -> Profunctor;
    ProChoice -> Profunctor;
    Arrow -> Split;
    Arrow -> Strong;
    Arrow -> Category;
    Associative;
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-core-cliques.png]]

#+BEGIN_SRC dot :file images/scalaz-core-loners.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Zip;
    Unzip;
    Cozip;
    Show;
    Optional;
    Catchable;
}
#+END_SRC

#+CAPTION: 80
#+RESULTS:
[[file:images/scalaz-core-loners.png]]

*** Appendable Things

#+BEGIN_SRC dot :file images/scalaz-semigroup.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Monoid -> Semigroup;
    Band -> Semigroup;
}
#+END_SRC

#+ATTR_LATEX: :width 5cm
#+CAPTION: 25
#+RESULTS:
[[file:images/scalaz-semigroup.png]]

#+BEGIN_SRC scala
@typeclass trait Semigroup[A] {
  @op("|+|") def append(x: A, y: =>A): A

  def multiply1(value: F, n: Int): F = ...
}

@typeclass trait Monoid[A] extends Semigroup[A] {
  def zero: A

  def multiply(value: F, n: Int): F =
    if (n <= 0) zero else multiply1(value, n - 1)
}

@typeclass trait Band[A] extends Semigroup[A]
#+END_SRC

#+BEGIN_ASIDE
=|+|= is known as the TIE Fighter operator. There is an Advanced TIE
Fighter in an upcoming section, which is very exciting.
#+END_ASIDE

A =Semigroup= should exist for a type if two elements can be combined
to produce another element of the same type. The operation must be
/associative/, meaning that the order of nested operations should not
matter, i.e.

#+BEGIN_SRC scala
(a |+| b) |+| c == a |+| (b |+| c)

(1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)
#+END_SRC

A =Monoid= is a =Semigroup= with a /zero/ element (also called /empty/
or /identity/). Combining =zero= with any other =a= should give =a=.

#+BEGIN_SRC scala
a |+| zero == a

a |+| 0 == a
#+END_SRC

This is probably bringing back memories of =Numeric= from Chapter 4,
which tried to do too much and was unusable beyond the most basic of
number types. There are implementations of =Monoid= for all the
primitive numbers, but the concept of /appendable/ things is useful
beyond numbers.

#+BEGIN_SRC scala
scala> "hello" |+| " " |+| "world!"
res: String = "hello world!"

scala> List(1, 2) |+| List(3, 4)
res: List[Int] = List(1, 2, 3, 4)
#+END_SRC

=Band= has the law that the =append= operation of the same two
elements is /idempotent/, i.e. gives the same value. Examples are
anything that can only be one value, such as =Unit=, least upper
bounds, or a =Set=. =Band= provides no further methods yet users can
make use of the guarantees for performance optimisation.

#+BEGIN_ASIDE
Viktor Klang, of Lightbend fame, lays claim to the phrase
[[https://twitter.com/viktorklang/status/789036133434978304][effectively-once delivery]] for message processing with idempotent
operations, i.e. =Band.append=.
#+END_ASIDE

As a realistic example for =Monoid=, consider a trading system that
has a large database of reusable trade templates. Creating the default
values for a new trade involves selecting and combining templates with
a "last rule wins" merge policy (e.g. if templates have a value for
the same field).

We'll create a simple template schema to demonstrate the principle,
but keep in mind that a realistic system would have a more complicated
ADT.

#+BEGIN_SRC scala
sealed abstract class Currency
case object EUR extends Currency
case object USD extends Currency

final case class TradeTemplate(
  payments: List[java.time.LocalDate],
  ccy: Option[Currency],
  otc: Option[Boolean]
)
#+END_SRC

If we write a method that takes =templates: List[TradeTemplate]=, we
only need to call

#+BEGIN_SRC scala
val zero = Monoid[TradeTemplate].zero
templates.foldLeft(zero)(_ |+| _)
#+END_SRC

and our job is done!

But to get =zero= or call =|+|= we must have an instance of
=Monoid[TradeTemplate]=. Although we will generically derive this in a
later chapter, for now we'll create an instance on the companion:

#+BEGIN_SRC scala
object TradeTemplate {
  implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
    (a, b) => TradeTemplate(a.payments |+| b.payments,
                            a.ccy |+| b.ccy,
                            a.otc |+| b.otc),
    TradeTemplate(Nil, None, None)
  )
}
#+END_SRC

However, this doesn't do what we want because =Monoid[Option[A]]= will append
its contents, e.g.

#+BEGIN_SRC scala
scala> Option(2) |+| None
res: Option[Int] = Some(2)
scala> Option(2) |+| Option(1)
res: Option[Int] = Some(3)
#+END_SRC

whereas we want "last rule wins". We can override the default
=Monoid[Option[A]]= with our own:

#+BEGIN_SRC scala
implicit def lastWins[A]: Monoid[Option[A]] = Monoid.instance(
  {
    case (None, None)   => None
    case (only, None)   => only
    case (None, only)   => only
    case (_   , winner) => winner
  },
  None
)
#+END_SRC

Now everything compiles, let's try it out...

#+BEGIN_SRC scala
scala> import java.time.{LocalDate => LD}
scala> val templates = List(
         TradeTemplate(Nil,                     None,      None),
         TradeTemplate(Nil,                     Some(EUR), None),
         TradeTemplate(List(LD.of(2017, 8, 5)), Some(USD), None),
         TradeTemplate(List(LD.of(2017, 9, 5)), None,      Some(true)),
         TradeTemplate(Nil,                     None,      Some(false))
       )

scala> templates.foldLeft(zero)(_ |+| _)
res: TradeTemplate = TradeTemplate(
                       List(2017-08-05,2017-09-05),
                       Some(USD),
                       Some(false))
#+END_SRC

All we needed to do was implement one piece of business logic and
=Monoid= took care of everything else for us!

Note that the list of =payments= are concatenated. This is because the
default =Monoid[List]= uses concatenation of elements and happens to
be the desired behaviour. If the business requirement was different,
it would be a simple case of providing a custom
=Monoid[List[LocalDate]]=. Recall from Chapter 4 that with compiletime
polymorphism we can have a different implementation of =append=
depending on the =E= in =List[E]=, not just the base runtime class
=List=.

#+BEGIN_ASIDE
When we introduced typeclasses in Chapter 4 we said that there can only be one
implementation of a typeclass for a given type parameter, e.g. there is only one
=Monoid[Option[Boolean]]= in the application. /Orphan instances/ such as
=lastWins= are the easiest way to break coherence.

We could try to justify locally breaking typeclass coherence by making
=lastWins= private, but when we get to the =Plus= typeclass we will see a better
way to implement our =Monoid=. When we get to tagged types, we will see an even
better way: using =LastOption= instead of =Option= in our data model.

Please don't break typeclass coherence at home, kids.
#+END_ASIDE

*** Objecty Things

In the chapter on Data and Functionality we said that the JVM's notion
of equality breaks down for many things that we can put into an ADT.
The problem is that the JVM was designed for Java, and =equals= is
defined on =java.lang.Object= whether it makes sense or not. There is
no way to remove =equals= and no way to guarantee that it is
implemented.

However, in FP we prefer typeclasses for polymorphic functionality and
even concepts as simple equality are captured at compiletime.

#+BEGIN_SRC dot :file images/scalaz-comparable.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Show;
    Order -> Equal;
    Enum -> Order;
}
#+END_SRC

#+ATTR_LATEX: :width 5cm
#+CAPTION: 20
#+RESULTS:
[[file:images/scalaz-comparable.png]]

#+BEGIN_SRC scala
@typeclass trait Equal[F]  {
  @op("===") def equal(a1: F, a2: F): Boolean
  @op("/==") def notEqual(a1: F, a2: F): Boolean = !equal(a1, a2)
}
#+END_SRC

Indeed ~===~ (/triple equals/) is more typesafe than ~==~ (/double
equals/) because it can only be compiled when the types are the same
on both sides of the comparison. You'd be surprised how many bugs this
catches.

=equal= has the same implementation requirements as =Object.equals=

- /commutative/ ~f1 === f2~ implies ~f2 === f1~
- /reflexive/ ~f === f~
- /transitive/ ~f1 === f2 && f2 === f3~ implies ~f1 === f3~

By throwing away the universal concept of =Object.equals= we don't
take equality for granted when we construct an ADT, stopping us at
compiletime from expecting equality when there is none.

Continuing the trend of replacing old Java concepts, rather than data
/being a/ =java.lang.Comparable=, they now /have an/ =Order= according
to:

#+BEGIN_SRC scala
@typeclass trait Order[F] extends Equal[F] {
  @op("?|?") def order(x: F, y: F): Ordering

  override  def equal(x: F, y: F): Boolean = order(x, y) == Ordering.EQ
  @op("<" ) def lt(x: F, y: F): Boolean = ...
  @op("<=") def lte(x: F, y: F): Boolean = ...
  @op(">" ) def gt(x: F, y: F): Boolean = ...
  @op(">=") def gte(x: F, y: F): Boolean = ...

  def max(x: F, y: F): F = ...
  def min(x: F, y: F): F = ...
  def sort(x: F, y: F): (F, F) = ...
}

sealed abstract class Ordering
object Ordering {
  case object LT extends Ordering
  case object EQ extends Ordering
  case object GT extends Ordering
}
#+END_SRC

=Order= implements =.equal= in terms of the new primitive =.order=. When a
typeclass implements a parent's /primitive combinator/ with a /derived
combinator/, an *implied law of substitution* for the typeclass is added. If an
instance of =Order= were to override =.equal= for performance reasons, it must
behave identically the same as the original.

Things that have an order may also be discrete, allowing us to walk
successors and predecessors:

#+BEGIN_SRC scala
@typeclass trait Enum[F] extends Order[F] {
  def succ(a: F): F
  def pred(a: F): F
  def min: Option[F]
  def max: Option[F]

  @op("-+-") def succn(n: Int, a: F): F = ...
  @op("---") def predn(n: Int, a: F): F = ...

  @op("|->" ) def fromToL(from: F, to: F): List[F] = ...
  @op("|-->") def fromStepToL(from: F, step: Int, to: F): List[F] = ...
  @op("|=>" ) def fromToL(from: F, to: F): EphemeralStream[F] = ...
  @op("|==>") def fromStepToL(from: F, step: Int, to: F): EphemeralStream[F] = ...
}
#+END_SRC

#+BEGIN_SRC scala
scala> 10 |--> (2, 20)
res: List[Int] = List(10, 12, 14, 16, 18, 20)

scala> 'm' |-> 'u'
res: List[Char] = List(m, n, o, p, q, r, s, t, u)
#+END_SRC

#+BEGIN_ASIDE
~|==>~ is scalaz's Lightsaber. This is the syntax of a Functional
Programmer. Not as clumsy or random as =fromStepToL=. An elegant
syntax... for a more civilised age.
#+END_ASIDE

We'll discuss =EphemeralStream= in the next chapter, for now you just
need to know that it is a potentially infinite data structure that
avoids memory retention problems in the stdlib =Stream=.

Similarly to =Object.equals=, the concept of a =.toString= on every
=class= does not make sense in Java. We would like to enforce
stringyness at compiletime and this is exactly what =Show= achieves:

#+BEGIN_SRC scala
trait Show[F] {
  def show(f: F): Cord = ...
  def shows(f: F): String = ...
}
#+END_SRC

We'll explore =Cord= in more detail in the chapter on data types, you
need only know that it is an efficient data structure for storing and
manipulating =String=.

Unfortunately, due to Scala's default implicit conversions in
=Predef=, and language level support for =toString= in interpolated
strings, it can be incredibly hard to remember to use =shows= instead
of =toString=.

*** Mappable Things

We're focusing on things that can be mapped over, or traversed, in
some sense:

#+BEGIN_SRC dot :file images/scalaz-mappable.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind;
    Contravariant;
    Functor [fontcolor=black,color=black];
    InvariantFunctor;
    Functor;
    Divide;
    Divisible;
    Apply;
    Align [fontcolor=black,color=black];
    Applicative;
    Foldable1 [fontcolor=black,color=black];
    Foldable [fontcolor=black,color=black];
    Traverse [fontcolor=black,color=black];
    Traverse1 [fontcolor=black,color=black];
    Monad;
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Cobind -> Functor;
    Comonad -> Cobind;

    Bind -> Apply;

    Contravariant -> InvariantFunctor;
    Functor -> InvariantFunctor;

    Divide -> Contravariant;
    Divisible -> Divide;
    Apply -> Functor;
    Applicative -> Apply;

    Align -> Functor [color=black];

    Foldable1 -> Foldable [color=black];
    Traverse -> Functor [color=black];
    Traverse -> Foldable [color=black];
    Traverse1 -> Traverse [color=black];
    Traverse1 -> Foldable1 [color=black];

    Monad -> Applicative;
    "Advanced Monads" -> Monad;
    Monad -> Bind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;

}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-mappable.png]]

**** Functor

#+BEGIN_SRC scala
@typeclass trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]

  def void[A](fa: F[A]): F[Unit] = map(fa)(_ => ())
  def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)] = map(fa)(a => (a, f(a)))

  def fpair[A](fa: F[A]): F[(A, A)] = map(fa)(a => (a, a))
  def strengthL[A, B](a: A, f: F[B]): F[(A, B)] = map(f)(b => (a, b))
  def strengthR[A, B](f: F[A], b: B): F[(A, B)] = map(f)(a => (a, b))

  def lift[A, B](f: A => B): F[A] => F[B] = map(_)(f)
  def mapply[A, B](a: A)(f: F[A => B]): F[B] = map(f)((ff: A => B) => ff(a))
}
#+END_SRC

The only abstract method is =map=, and it must /compose/, i.e. mapping
with =f= and then again with =g= is the same as mapping once with the
composition of =f= and =g=:

#+BEGIN_SRC scala
fa.map(f).map(g) == fa.map(f.andThen(g))
#+END_SRC

The =map= should also perform a no-op if the provided function is
=identity= (i.e. =x => x=)

#+BEGIN_SRC scala
fa.map(identity) == fa

fa.map(x => x) == fa
#+END_SRC

=Functor= defines some convenience methods around =map= that can be
optimised by specific instances. The documentation has been
intentionally omitted in the above definitions to encourage you to
guess what a method does before looking at the implementation. Please
spend a moment studying only the type signature of the following
before reading further:

#+BEGIN_SRC scala
  def void[A](fa: F[A]): F[Unit]
  def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)]

  def fpair[A](fa: F[A]): F[(A, A)]
  def strengthL[A, B](a: A, f: F[B]): F[(A, B)]
  def strengthR[A, B](f: F[A], b: B): F[(A, B)]

  // harder
  def lift[A, B](f: A => B): F[A] => F[B]
  def mapply[A, B](a: A)(f: F[A => B]): F[B]
#+END_SRC

1. =void= takes an instance of the =F[A]= and always returns an
   =F[Unit]=, it forgets all the values whilst preserving the
   structure.
1. =fproduct= takes the same input as =map= but returns =F[(A, B)]=,
   i.e. it tuples the contents with the result of applying the
   function. This is useful when we wish to retain the input.
1. =fpair= twins all the elements of =A= into a tuple =F[(A, A)]=
1. =strengthL= pairs the contents of an =F[B]= with a constant =A= on
   the left.
1. =strengthR= pairs the contents of an =F[A]= with a constant =B= on
   the right.
1. =lift= takes a function =A => B= and returns a =F[A] => F[B]=. In
   other words, it takes a function over the contents of an =F[A]= and
   returns a function that operates *on* the =F[A]= directly.
1. =mapply= is a mind bender. Say you have an =F[_]= of functions =A
   => B= and a value =A=, then you can get an =F[B]=. It has a similar
   signature to =pure= but requires the caller to provide the =F[A =>
   B]=.

=fpair=, =strengthL= and =strengthR= look pretty useless, but they are
useful when we wish to retain some information that would otherwise be
lost to scope.

=Functor= has some special syntax:

#+BEGIN_SRC scala
implicit class FunctorOps[F[_]: Functor, A](self: F[A]) {
  def as[B](b: =>B): F[B] = Functor[F].map(self)(_ => b)
  def >|[B](b: =>B): F[B] = as(b)
}
#+END_SRC

=as= and =>|= are a way of replacing the output with a constant.

In our example application, as a nasty hack (which we didn't even
admit to until now), we defined =start= and =stop= to return their
input:

#+BEGIN_SRC scala
  def start(node: MachineNode): F[MachineNode]
  def stop (node: MachineNode): F[MachineNode]
#+END_SRC

This allowed us to write terse business logic such as

#+BEGIN_SRC scala
for {
  _      <- m.start(node)
  update = world.copy(pending = Map(node -> world.time))
} yield update
#+END_SRC

and

#+BEGIN_SRC scala
for {
  stopped <- nodes.traverse(m.stop)
  updates = stopped.map(_ -> world.time).toList.toMap
  update  = world.copy(pending = world.pending ++ updates)
} yield update
#+END_SRC

But this hack pushes unnecessary complexity into the implementations. It is
better if we let our algebras return =F[Unit]= and use =as=:

#+BEGIN_SRC scala
m.start(node) as world.copy(pending = Map(node -> world.time))
#+END_SRC

and

#+BEGIN_SRC scala
for {
  stopped <- nodes.traverse(a => m.stop(a) as a)
  updates = stopped.map(_ -> world.time).toList.toMap
  update  = world.copy(pending = world.pending ++ updates)
} yield update
#+END_SRC

As a bonus, we are now using the less powerful =Functor= instead of
=Monad= when starting a node.

**** Foldable

Technically, =Foldable= is for data structures that can be walked to
produce a summary value. However, this undersells the fact that it is
a one-typeclass army that can provide most of what you'd expect to see
in a Collections API.

There are so many methods we are going to have to split them out,
beginning with the abstract methods:

#+BEGIN_SRC scala
@typeclass trait Foldable[F[_]] {
  def foldMap[A, B: Monoid](fa: F[A])(f: A => B): B
  def foldRight[A, B](fa: F[A], z: =>B)(f: (A, =>B) => B): B
  def foldLeft[A, B](fa: F[A], z: B)(f: (B, A) => B): B = ...
#+END_SRC

An instance of =Foldable= need only implement =foldMap= and
=foldRight= to get all of the functionality in this typeclass,
although methods are typically optimised for specific data structures.

You might recognise =foldMap= by its marketing buzzword name, *MapReduce*. Given
an =F[A]=, a function from =A= to =B=, and a way to combine =B= (provided by the
=Monoid=, along with a zero =B=), we can produce a summary value of type =B=.
There is no enforced operation order, allowing for parallel computation.

=foldRight= does not require its parameters to have a =Monoid=,
meaning that it needs a starting value =z= and a way to combine each
element of the data structure with the summary value. The order for
traversing the elements is from right to left and therefore it cannot
be parallelised.

#+BEGIN_ASIDE

=foldRight= is conceptually the same as the =foldRight= in the Scala
stdlib. However, there is a problem with the stdlib =foldRight=
signature, solved in scalaz: very large data structures can stack
overflow. =List.foldRight= cheats by implementing =foldRight= as a
reversed =foldLeft=

#+BEGIN_SRC scala
override def foldRight[B](z: B)(op: (A, B) => B): B =
  reverse.foldLeft(z)((right, left) => op(left, right))
#+END_SRC

but the concept of reversing is not universal and this workaround
cannot be used for all data structures. Let's say we want to find
out if there is a small number in a =Stream=, with an early exit:

#+BEGIN_SRC scala
scala> def isSmall(i: Int): Boolean = i < 10
scala> (1 until 100000).toStream.foldRight(false) {
         (el, acc) => isSmall(el) || acc
       }
java.lang.StackOverflowError
  at scala.collection.Iterator.toStream(Iterator.scala:1403)
  ...
#+END_SRC

Scalaz solves the problem by taking a /byname/ parameter for the
aggregate value

#+BEGIN_SRC scala
scala> (1 |=> 100000).foldRight(false)(el => acc => isSmall(el) || acc )
res: Boolean = true
#+END_SRC

which means that the =acc= is not evaluated unless it is needed.

It is worth baring in mind that not all operations are stack safe in
=foldRight=. If we were to require evaluation of all elements, we can
also get a =StackOverflowError= with scalaz's =EphemeralStream=

#+BEGIN_SRC scala
scala> (1L |=> 100000L).foldRight(0L)(el => acc => el |+| acc )
java.lang.StackOverflowError
  at scalaz.Foldable.$anonfun$foldr$1(Foldable.scala:100)
  ...
#+END_SRC
#+END_ASIDE

=foldLeft= traverses elements from left to right. =foldLeft= can be
implemented in terms of =foldMap=, but most instances choose to
implement it because it is such a basic operation. Since it is usually
implemented with tail recursion, there are no /byname/ parameters.

The only law for =Foldable= is that =foldLeft= and =foldRight= should
each be consistent with =foldMap= for monoidal operations. e.g.
appending an element to a list for =foldLeft= and prepending an
element to a list for =foldRight=. However, =foldLeft= and =foldRight=
do not need to be consistent with each other: in fact they often
produce the reverse of each other.

The simplest thing to do with =foldMap= is to use the =identity=
function, giving =fold= (the natural sum of the monoidal elements),
with left/right variants to allow choosing based on performance
criteria:

#+BEGIN_SRC scala
  def fold[A: Monoid](t: F[A]): A = ...
  def sumr[A: Monoid](fa: F[A]): A = ...
  def suml[A: Monoid](fa: F[A]): A = ...
#+END_SRC

Recall that when we learnt about =Monoid=, we wrote this:

#+BEGIN_SRC scala
scala> templates.foldLeft(Monoid[TradeTemplate].zero)(_ |+| _)
#+END_SRC

We now know this is silly and we should have written:

#+BEGIN_SRC scala
scala> templates.toIList.fold
res: TradeTemplate = TradeTemplate(
                       List(2017-08-05,2017-09-05),
                       Some(USD),
                       Some(false))
#+END_SRC

=.fold= doesn't work on stdlib =List= because it already has a method
called =fold= that does it is own thing in its own special way.

The strangely named =intercalate= inserts a specific =A= between each
element before performing the =fold=

#+BEGIN_SRC scala
  def intercalate[A: Monoid](fa: F[A], a: A): A = ...
#+END_SRC

which is a generalised version of the stdlib's =mkString=:

#+BEGIN_SRC scala
scala> List("foo", "bar").intercalate(",")
res: String = "foo,bar"
#+END_SRC

The =foldLeft= provides the means to obtain any element by traversal
index, including a bunch of other related methods:

#+BEGIN_SRC scala
  def index[A](fa: F[A], i: Int): Option[A] = ...
  def indexOr[A](fa: F[A], default: =>A, i: Int): A = ...
  def length[A](fa: F[A]): Int = ...
  def count[A](fa: F[A]): Int = length(fa)
  def empty[A](fa: F[A]): Boolean = ...
  def element[A: Equal](fa: F[A], a: A): Boolean = ...
#+END_SRC

Scalaz is a pure library of only /total functions/, whereas the stdlib =.apply=
returns =A= and can throw an exception, =Foldable.index= returns an =Option[A]=
with the convenient =.indexOr= returning an =A= when a default value is
provided. =.element= is similar to the stdlib =.contains= but uses =Equal=
rather than ill-defined JVM equality.

These methods /really/ sound like a collections API. And, of course,
anything with a =Foldable= can be converted into a =List=

#+BEGIN_SRC scala
  def toList[A](fa: F[A]): List[A] = ...
#+END_SRC

There are also conversions to other stdlib and scalaz data types such
as =.toSet=, =.toVector=, =.toStream=, =.to[T <: TraversableLike]=,
=.toIList= and so on.

There are useful predicate checks

#+BEGIN_SRC scala
  def filterLength[A](fa: F[A])(f: A => Boolean): Int = ...
  def all[A](fa: F[A])(p: A => Boolean): Boolean = ...
  def any[A](fa: F[A])(p: A => Boolean): Boolean = ...
#+END_SRC

=filterLength= is a way of counting how many elements are =true= for a
predicate, =all= and =any= return =true= if all (or any) element meets
the predicate, and may exit early.

#+BEGIN_ASIDE
We've seen the =NonEmptyList= in previous chapters. For the sake of
brevity we use a type alias =Nel= in place of =NonEmptyList=.

We've also seen =IList= in previous chapters, recall that it is an
alternative to stdlib =List= with impure methods, like =apply=,
removed.
#+END_ASIDE

We can split an =F[A]= into parts that result in the same =B= with
=splitBy=

#+BEGIN_SRC scala
  def splitBy[A, B: Equal](fa: F[A])(f: A => B): IList[(B, Nel[A])] = ...
  def splitByRelation[A](fa: F[A])(r: (A, A) => Boolean): IList[Nel[A]] = ...
  def splitWith[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...
  def selectSplit[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...

  def findLeft[A](fa: F[A])(f: A => Boolean): Option[A] = ...
  def findRight[A](fa: F[A])(f: A => Boolean): Option[A] = ...
#+END_SRC

for example

#+BEGIN_SRC scala
scala> IList("foo", "bar", "bar", "faz", "gaz", "baz").splitBy(_.charAt(0))
res = [(f, [foo]), (b, [bar, bar]), (f, [faz]), (g, [gaz]), (b, [baz])]
#+END_SRC

noting that there are two parts indexed by =f=.

=splitByRelation= avoids the need for an =Equal= but we must provide
the comparison operator.

=splitWith= splits the elements into groups that alternatively satisfy
and don't satisfy the predicate. =selectSplit= selects groups of
elements that satisfy the predicate, discarding others. This is one of
those rare occasions when two methods share the same type signature
but have different meanings.

=findLeft= and =findRight= are for extracting the first element (from
the left, or right, respectively) that matches a predicate.

Making further use of =Equal= and =Order=, we have the =distinct=
methods which return groupings.

#+BEGIN_SRC scala
  def distinct[A: Order](fa: F[A]): IList[A] = ...
  def distinctE[A: Equal](fa: F[A]): IList[A] = ...
  def distinctBy[A, B: Equal](fa: F[A])(f: A => B): IList[A] =
#+END_SRC

=distinct= is implemented more efficiently than =distinctE= because it
can make use of ordering and therefore use a quicksort-esque algorithm
that is much faster than the stdlib's naive =List.distinct=. Data
structures (such as sets) can implement =distinct= in their =Foldable=
without doing any work.

=distinctBy= allows grouping by the result of applying a function to
the elements. For example, grouping names by their first letter.

We can make further use of =Order= by extracting the minimum or
maximum element (or both extrema) including variations using the =Of=
or =By= pattern to first map to another type or to use a different
type to do the order comparison.

#+BEGIN_SRC scala
  def maximum[A: Order](fa: F[A]): Option[A] = ...
  def maximumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def maximumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...

  def minimum[A: Order](fa: F[A]): Option[A] = ...
  def minimumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def minimumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...

  def extrema[A: Order](fa: F[A]): Option[(A, A)] = ...
  def extremaOf[A, B: Order](fa: F[A])(f: A => B): Option[(B, B)] = ...
  def extremaBy[A, B: Order](fa: F[A])(f: A => B): Option[(A, A)] =
#+END_SRC

For example we can ask which =String= is maximum =By= length, or what
is the maximum length =Of= the elements.

#+BEGIN_SRC scala
scala> List("foo", "fazz").maximumBy(_.length)
res: Option[String] = Some(fazz)

scala> List("foo", "fazz").maximumOf(_.length)
res: Option[Int] = Some(4)
#+END_SRC

This concludes the key features of =Foldable=. You are forgiven for
already forgetting all the methods you've just seen: the key takeaway
is that anything you'd expect to find in a collection library is
probably on =Foldable= and if it isn't already, it [[https://github.com/scalaz/scalaz/issues/1448][probably should be]].

We'll conclude with some variations of the methods we've already seen.
First there are methods that take a =Semigroup= instead of a =Monoid=:

#+BEGIN_SRC scala
  def fold1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def foldMap1Opt[A, B: Semigroup](fa: F[A])(f: A => B): Option[B] = ...
  def sumr1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def suml1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  ...
#+END_SRC

returning =Option= to account for empty data structures (recall that
=Semigroup= does not have a =zero=).

#+BEGIN_ASIDE
The methods read "one-Option", not =10 pt= as in typesetting.
#+END_ASIDE

The typeclass =Foldable1= contains a lot more =Semigroup= variants of
the =Monoid= methods shown here (all suffixed =1=) and makes sense for
data structures which are never empty, without requiring a =Monoid= on
the elements.

Very importantly, there are variants that take monadic return values.
We already used =foldLeftM= when we first wrote the business logic of
our application, now you know that =Foldable= is where it came from:

#+BEGIN_SRC scala
def foldLeftM[G[_]: Monad, A, B](fa: F[A], z: B)(f: (B, A) => G[B]): G[B] = ...
def foldRightM[G[_]: Monad, A, B](fa: F[A], z: =>B)(f: (A, =>B) => G[B]): G[B] = ...
def foldMapM[G[_]: Monad, A, B: Monoid](fa: F[A])(f: A => G[B]): G[B] = ...
def findMapM[M[_]: Monad, A, B](fa: F[A])(f: A => M[Option[B]]): M[Option[B]] = ...
def allM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
def anyM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
...
#+END_SRC

You may also see Curried versions, e.g.

#+BEGIN_SRC scala
def foldl[A, B](fa: F[A], z: B)(f: B => A => B): B = ...
def foldr[A, B](fa: F[A], z: =>B)(f: A => (=> B) => B): B = ...
...
#+END_SRC

**** Traverse

=Traverse= is what happens when you cross a =Functor= with a =Foldable=

#+BEGIN_SRC scala
trait Traverse[F[_]] extends Functor[F] with Foldable[F] {
  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]
  def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] = ...

  def reverse[A](fa: F[A]): F[A] = ...

  def zipL[A, B](fa: F[A], fb: F[B]): F[(A, Option[B])] = ...
  def zipR[A, B](fa: F[A], fb: F[B]): F[(Option[A], B)] = ...
  def indexed[A](fa: F[A]): F[(Int, A)] = ...
  def zipWithL[A, B, C](fa: F[A], fb: F[B])(f: (A, Option[B]) => C): F[C] = ...
  def zipWithR[A, B, C](fa: F[A], fb: F[B])(f: (Option[A], B) => C): F[C] = ...

  def mapAccumL[S, A, B](fa: F[A], z: S)(f: (S, A) => (S, B)): (S, F[B]) = ...
  def mapAccumR[S, A, B](fa: F[A], z: S)(f: (S, A) => (S, B)): (S, F[B]) = ...
}
#+END_SRC

At the beginning of the chapter we showed the importance of =traverse=
and =sequence= for swapping around type constructors to fit a
requirement (e.g. =List[Future[_]]= to =Future[List[_]]=). You will
use these methods more than you could possibly imagine.

In =Foldable= we weren't able to assume that =reverse= was a universal
concept, but now we can reverse a thing.

We can also =zip= together two things that have a =Traverse=, getting
back =None= when one side runs out of elements, using =zipL= or =zipR=
to decide which side to truncate when the lengths don't match. A
special case of =zip= is to add an index to every entry with
=indexed=.

=zipWithL= and =zipWithR= allow combining the two sides of a =zip=
into a new type, and then returning just an =F[C]=.

=mapAccumL= and =mapAccumR= are regular =map= combined with an
accumulator. If you find your old Java sins are making you want to
reach for a =var=, and refer to it from a =map=, you want =mapAccumL=.

For example, let's say we have a list of words and we want to blank
out words we've already seen. The filtering algorithm is not allowed
to process the list of words a second time so it can be scaled to an
infinite stream:

#+BEGIN_SRC scala
scala> val freedom =
"""We campaign for these freedoms because everyone deserves them.
   With these freedoms, the users (both individually and collectively)
   control the program and what it does for them."""
   .split("\\s+")
   .toList

scala> def clean(s: String): String = s.toLowerCase.replaceAll("[,.()]+", "")

scala> freedom
       .mapAccumL(Set.empty[String]) { (seen, word) =>
         val cleaned = clean(word)
         (seen + cleaned, if (seen(cleaned)) "_" else word)
       }
       ._2
       .intercalate(" ")

res: String =
"""We campaign for these freedoms because everyone deserves them.
   With _ _ the users (both individually and collectively)
   control _ program _ what it does _ _"""
#+END_SRC

Finally =Traverse1=, like =Foldable1=, provides variants of these
methods for data structures that cannot be empty, accepting the weaker
=Semigroup= instead of a =Monoid=, and an =Apply= instead of an
=Applicative=.

**** Align

=Align= is about merging and padding anything with a =Functor=. Before
looking at =Align=, meet the ~\&/~ data type (spoken as /These/, or
/hurray!/).

#+BEGIN_SRC scala
sealed abstract class \&/[+A, +B]
final case class This[A](aa: A) extends (A \&/ Nothing)
final case class That[B](bb: B) extends (Nothing \&/ B)
final case class Both[A, B](aa: A, bb: B) extends (A \&/ B)
#+END_SRC

i.e. it is a data encoding of inclusive logical =OR=.

#+BEGIN_SRC scala
@typeclass trait Align[F[_]] extends Functor[F] {
  def alignWith[A, B, C](f: A \&/ B => C): (F[A], F[B]) => F[C]
  def align[A, B](a: F[A], b: F[B]): F[A \&/ B] = ...

  def merge[A: Semigroup](a1: F[A], a2: F[A]): F[A] = ...

  def pad[A, B]: (F[A], F[B]) => F[(Option[A], Option[B])] = ...
  def padWith[A, B, C](f: (Option[A], Option[B]) => C): (F[A], F[B]) => F[C] = ...
#+END_SRC

Hopefully by this point you are becoming more capable of reading type
signatures to understand the purpose of a method.

=alignWith= takes a function from either an =A= or a =B= (or both) to
a =C= and returns a lifted function from a tuple of =F[A]= and =F[B]=
to an =F[C]=. =align= constructs a ~\&/~ out of two =F[_]=.

=merge= allows us to combine two =F[A]= when =A= has a =Semigroup=. For example,
the implementation of =Semigroup[Map[K, V]]= defers to =Semigroup[V]=, combining
two entries results in combining their values, having the consequence that
=Map[K, List[A]]= behaves like a multimap:

#+BEGIN_SRC scala
scala> Map("foo" -> List(1)) merge Map("foo" -> List(1), "bar" -> List(2))
res = Map(foo -> List(1, 1), bar -> List(2))
#+END_SRC

and a =Map[K, Int]= simply tally their contents when merging:

#+BEGIN_SRC scala
scala> Map("foo" -> 1) merge Map("foo" -> 1, "bar" -> 2)
res = Map(foo -> 2, bar -> 2)
#+END_SRC

=.pad= and =.padWith= are for partially merging two data structures that might
be missing values on one side. For example if we wanted to aggregate independent
votes and retain the knowledge of where the votes came from

#+BEGIN_SRC scala
scala> Map("foo" -> 1) pad Map("foo" -> 1, "bar" -> 2)
res = Map(foo -> (Some(1),Some(1)), bar -> (None,Some(2)))

scala> Map("foo" -> 1, "bar" -> 2) pad Map("foo" -> 1)
res = Map(foo -> (Some(1),Some(1)), bar -> (Some(2),None))
#+END_SRC

There are convenient variants of =align= that make use of the
structure of =\&/=

#+BEGIN_SRC scala
  ...
  def alignSwap[A, B](a: F[A], b: F[B]): F[B \&/ A] = ...
  def alignA[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
  def alignB[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
  def alignThis[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
  def alignThat[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
  def alignBoth[A, B](a: F[A], b: F[B]): F[Option[(A, B)]] = ...
}
#+END_SRC

which should make sense from their type signatures. Examples:

#+BEGIN_SRC scala
scala> List(1,2,3) alignSwap List(4,5)
res = List(Both(4,1), Both(5,2), That(3))

scala> List(1,2,3) alignA List(4,5)
res = List(Some(1), Some(2), Some(3))

scala> List(1,2,3) alignB List(4,5)
res = List(Some(4), Some(5), None)

scala> List(1,2,3) alignThis List(4,5)
res = List(None, None, Some(3))

scala> List(1,2,3) alignThat List(4,5)
res = List(None, None, None)

scala> List(1,2,3) alignBoth List(4,5)
res = List(Some((1,4)), Some((2,5)), None)
#+END_SRC

Note that the =A= and =B= variants use inclusive =OR=, whereas the
=This= and =That= variants are exclusive, returning =None= if there is
a value in both sides, or no value on either side.

*** Variance

We must return to =Functor= for a moment and discuss an ancestor that
we previously ignored:

#+BEGIN_SRC dot :file images/scalaz-variance.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind;
    Apply;
    Contravariant [fontcolor=black,color=black];
    Functor [fontcolor=black,color=black];
    InvariantFunctor [fontcolor=black,color=black];
    Functor;
    Divide;
    Divisible;
    Apply;
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative;
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad;
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Cobind -> Functor;
    Comonad -> Cobind;

    Bind -> Apply;

    Contravariant -> InvariantFunctor [color=black];
    Functor -> InvariantFunctor [color=black];

    Divide -> Contravariant;
    Divisible -> Divide;
    Apply -> Functor;
    Applicative -> Apply;

    Align -> Functor [color=lightslategray];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative;
    "Advanced Monads" -> Monad;
    Monad -> Bind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-variance.png]]

=InvariantFunctor=, also known as the /exponential functor/, has a
method =xmap= which says that given a function from =A= to =B=, and a
function from =B= to =A=, then we can convert =F[A]= to =F[B]=.

=Functor= is a short name for what should be /covariant functor/. But
since =Functor= is so popular it gets the nickname. Likewise
=Contravariant= should really be /contravariant functor/.

=Functor= implements =xmap= with =map= and ignores the function from
=B= to =A=. =Contravariant=, on the other hand, implements =xmap= with
=contramap= and ignores the function from =A= to =B=:

#+BEGIN_SRC scala
@typeclass trait InvariantFunctor[F[_]] {
  def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B]
  ...
}

@typeclass trait Functor[F[_]] extends InvariantFunctor[F] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
  def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B] = map(fa)(f)
  ...
}

@typeclass trait Contravariant[F[_]] extends InvariantFunctor[F] {
  def contramap[A, B](fa: F[A])(f: B => A): F[B]
  def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B] = contramap(fa)(g)
  ...
}
#+END_SRC

It is important to note that, although related at a theoretical level,
the words /covariant/, /contravariant/ and /invariant/ do not directly
refer to Scala type variance (i.e. =+= and =-= prefixes that may be
written in type signatures). /Invariance/ here means that it is
possible to map the contents of a structure =F[A]= into =F[B]=. Using
=identity= we can see that =A= can be safely downcast (or upcast) into
=B= depending on the variance of the functor.

This sounds so hopelessly abstract that it needs a practical example
immediately, before we can take it seriously. In Chapter 4 we used
=spray-json-derivation= to derive a JSON encoder for our data types and we gave
a brief description of the =JsonWriter= typeclass. This is an expanded version:

#+BEGIN_SRC scala
@typeclass trait JsonWriter[A] { self =>
  def toJson(a: A): JsValue

  def contramap[B](f: B => A): JsonWriter[B] = new JsonWriter[B] {
    def toJson(b: B): JsValue = self.toJson(f(b))
  }
}
#+END_SRC

Now consider the case where we want to write an instance of an =JsonWriter[B]=
in terms of another =JsonWriter[A]=, for example if we have a data type =Alpha=
that simply wraps a =Double=. This is exactly what =contramap= is for:

#+BEGIN_SRC scala
final case class Alpha(value: Double)

object Alpha {
  implicit val encoder: JsonWriter[Alpha] = JsonWriter[Double].contramap(_.value)
}
#+END_SRC

On the other hand, a =JsonReader= typically has a =Functor=:

#+BEGIN_SRC scala
@typeclass trait JsonReader[A] { self =>
  def fromJson(j: JsValue): A

  def map[B](f: A => B): JsonReader[B] = new JsonReader[B] {
    def fromJson(j: JsValue): B = f(self.fromJson(j))
  }
}
#+END_SRC

Methods on a typeclass can have their type parameters in
/contravariant position/ (method parameters) or in /covariant
position/ (return type). If a typeclass has a combination of covariant
and contravariant positions, it might have an /invariant functor/.

Consider what happens if we combine =JsonWriter= and =JsonReader= into one
typeclass. We can no longer construct a =Format= by using =map= or =contramap=
alone, we need =xmap=:

#+BEGIN_SRC scala
@typeclass trait JsonFormat[A] extends JsonWriter[A] with JsonReader[A] { self =>
  def xmap[B](f: A => B, g: B => A): JsonFormat[B] = new JsonFormat[B] {
    def toJson(b: B): JsValue = self.toJson(g(b))
    def fromJson(j: JsValue): B = f(self.fromJson(j))
  }
}
#+END_SRC

#+BEGIN_ASIDE
Although =JsonWriter= implements =contramap=, =JsonReader= implements =map=, and
=Format= implements =xmap= we are not saying that these typeclasses extend
=InvariantFunctor=, rather they /have an/ =InvariantFunctor=.

We could implement instances of

- =Functor[JsonReader]=
- =Contravariant[JsonWriter]=
- =InvariantFunctor[JsonFormat]=

on our companions, and use scalaz syntax to have the exact same =map=,
=contramap= and =xmap=.

However, since we don't need anything else that the invariants provide
(and it is a lot of boilerplate for a textbook), we just implement the
bare minimum on the typeclasses themselves. The invariant instance
[[https://github.com/mpilquist/simulacrum/issues/85][could be generated automatically]].
#+END_ASIDE

One of the most compelling uses for =xmap= is to provide typeclasses
for /value types/. A value type is a compiletime wrapper for another
type, that does not incur any object allocation costs (subject to some
rules of use).

For example we can provide context around some numbers to avoid
getting them mixed up:

#+BEGIN_SRC scala
final case class Alpha(value: Double) extends AnyVal
final case class Beta (value: Double) extends AnyVal
final case class Rho  (value: Double) extends AnyVal
final case class Nu   (value: Double) extends AnyVal
#+END_SRC

If we want to put these types in a JSON message, we'd need to write a
custom =Format= for each type, which is tedious. But our =Format=
implements =xmap=, allowing =Format= to be constructed from a simple
pattern:

#+BEGIN_SRC scala
implicit val double: JsonFormat[Double] = ...

implicit val alpha: JsonFormat[Alpha] = double.xmap(Alpha(_), _.value)
implicit val beta : JsonFormat[Beta]  = double.xmap(Beta(_) , _.value)
implicit val rho  : JsonFormat[Rho]   = double.xmap(Rho(_)  , _.value)
implicit val nu   : JsonFormat[Nu]    = double.xmap(Nu(_)   , _.value)
#+END_SRC

Macros can automate the construction of these instances, so we don't
need to write them: we'll revisit this later in a dedicated chapter on
Typeclass Derivation.

**** Composition

Invariants can be composed via methods with intimidating type
signatures. There are many permutations of =compose= on most
typeclasses, we will not list them all.

#+BEGIN_SRC scala
@typeclass trait Functor[F[_]] extends InvariantFunctor[F] {
  def compose[G[_]: Functor]: Functor[λ[α => F[G[α]]]] = ...
  def icompose[G[_]: Contravariant]: Contravariant[λ[α => F[G[α]]]] = ...
  ...
}
@typeclass trait Contravariant[F[_]] extends InvariantFunctor[F] {
  def compose[G[_]: Contravariant]: Functor[λ[α => F[G[α]]]] = ...
  def icompose[G[_]: Functor]: Contravariant[λ[α => F[G[α]]]] = ...
  ...
}
#+END_SRC

The ~α =>~ type syntax is a ~kind-projector~ /type lambda/ that says if
~Functor[F]~ is composed with a type ~G[_]~ (that has a ~Functor[G]~), we get a
~Functor[F[G[_]]]~ that operates on the ~A~ in ~F[G[A]]~.

An example of =Functor.compose= is where =F[_]= is =List=, =G[_]= is
=Option=, and we want to be able to map over the =Int= inside a
=List[Option[Int]]= without changing the two structures:

#+BEGIN_SRC scala
scala> val lo = List(Some(1), None, Some(2))
scala> Functor[List].compose[Option].map(lo)(_ + 1)
res: List[Option[Int]] = List(Some(2), None, Some(3))
#+END_SRC

This lets us jump into nested effects and structures and apply a
function at the layer we want.

*** Apply and Bind

Consider this the warm-up act to =Applicative= and =Monad=

#+BEGIN_SRC dot :file images/scalaz-apply.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind [fontcolor=black,color=black];
    Apply [fontcolor=black,color=black];
    Contravariant [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    InvariantFunctor [fontcolor=lightslategray,color=lightslategray];
    Functor;
    Divide;
    Divisible;
    Apply;
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative;
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad;
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Cobind -> Functor;
    Comonad -> Cobind;

    Bind -> Apply [color=black];

    Contravariant -> InvariantFunctor [color=lightslategray];
    Functor -> InvariantFunctor [color=lightslategray];

    Divide -> Contravariant;
    Divisible -> Divide;
    Apply -> Functor [color=black];
    Applicative -> Apply;

    Align -> Functor [color=lightslategray];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative;
    "Advanced Monads" -> Monad;
    Monad -> Bind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-apply.png]]

**** Apply

=Apply= extends =Functor= by adding a method named =ap= which is
similar to =map= in that it applies a function to values. However,
with =ap=, the function is in a similar context to the values.

#+BEGIN_SRC scala
@typeclass trait Apply[F[_]] extends Functor[F] {
  @op("<*>") def ap[A, B](fa: =>F[A])(f: =>F[A => B]): F[B]
  ...
#+END_SRC

# https://mobile.twitter.com/mrkgrnao/status/962030468093767681

#+BEGIN_ASIDE
~<*>~ is the Advanced TIE Fighter, as flown by Darth Vader. Appropriate since it
looks like an angry parent.
#+END_ASIDE

It is worth taking a moment to consider what that means for a simple data
structure like =Option[A]=, having the following implementation of =.ap=

#+BEGIN_SRC scala
implicit def option[A]: Apply[Option[A]] = new Apply[Option[A]] {
  override def ap[A, B](fa: =>Option[A])(f: =>Option[A => B]) = f match {
    case Some(ff) => fa.map(ff)
    case None    => None
  }
  ...
}
#+END_SRC

To implement ~.ap~, we must first extract the function ~ff: A => B~ from ~f:
Option[A => B]~, then we can map over ~fa~. The extraction of the function from
the context is the important power that ~Apply~ brings, allowing multiple
function to be combined inside the context.

Returning to =Apply=, we find =.applyX= boilerplate that allows us to combine
parallel functions and then map over their combined output:

#+BEGIN_SRC scala
@typeclass trait Apply[F[_]] extends Functor[F] {
  ...
  def apply2[A,B,C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C): F[C] = ...
  def apply3[A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: (A,B,C) =>D): F[D] = ...
  ...
  def apply12[...]
#+END_SRC

Read =.apply2= as a contract promising: "if you give me an =F= of =A= and an =F=
of =B=, with a way of combining =A= and =B= into a =C=, then I can give you an
=F= of =C=". There are many uses for this contract and the two most important are:

- constructing some typeclasses for a product type =C= from its constituents =A=
  and =B=
- performing /effects/ in parallel, like the drone and google algebras we
  created in Chapter 3, and then combining their results.

Indeed, =Apply= is so useful that it has special syntax:

#+BEGIN_SRC scala
implicit class ApplyOps[F[_]: Apply, A](self: F[A]) {
  def *>[B](fb: F[B]): F[B] = Apply[F].apply2(self,fb)((_,b) => b)
  def <*[B](fb: F[B]): F[A] = Apply[F].apply2(self,fb)((a,_) => a)
  def |@|[B](fb: F[B]): ApplicativeBuilder[F, A, B] = ...
}

class ApplicativeBuilder[F[_]: Apply, A, B](a: F[A], b: F[B]) {
  def tupled: F[(A, B)] = Apply[F].apply2(a, b)(Tuple2(_))
  def |@|[C](cc: F[C]): ApplicativeBuilder3[C] = ...

  sealed abstract class ApplicativeBuilder3[C](c: F[C]) {
    ..ApplicativeBuilder4
      ...
        ..ApplicativeBuilder12
}
#+END_SRC

which is exactly what we used in Chapter 3:

#+BEGIN_SRC scala
(d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)
#+END_SRC

#+BEGIN_ASIDE
The =|@|= operator has many names. Some call it the /Cartesian Product
Syntax/, others call it the /Cinnamon Bun/, the /Admiral Ackbar/ or
the /Macaulay Culkin/. We prefer to call it /The Scream/ operator,
after the Munch painting, because it is also the sound your CPU makes
when it is parallelising All The Things.
#+END_ASIDE

The syntax =<*= and =*>= (left bird and right bird) offer a convenient way to
ignore the output from one of two parallel effects.

Unfortunately, although the =|@|= syntax is clear, there is a problem
in that a new =ApplicativeBuilder= object is allocated for each
additional effect. If the work is I/O-bound, the memory allocation
cost is insignificant. However, when performing CPU-bound work, use
the alternative /lifting with arity/ syntax, which does not produce
any intermediate objects:

#+BEGIN_SRC scala
def ^[F[_]: Apply,A,B,C](fa: =>F[A],fb: =>F[B])(f: (A,B) =>C): F[C] = ...
def ^^[F[_]: Apply,A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: (A,B,C) =>D): F[D] = ...
...
def ^^^^^^[F[_]: Apply, ...]
#+END_SRC

used like

#+BEGIN_SRC scala
^^^^(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
#+END_SRC

or directly call =applyX=

#+BEGIN_SRC scala
Apply[F].apply5(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
#+END_SRC

Despite being of most value for dealing with effects, =Apply= provides
convenient syntax for dealing with data structures. Consider rewriting

#+BEGIN_SRC scala
  for {
    foo <- data.foo: Option[String]
    bar <- data.bar: Option[Int]
  } yield foo + bar.shows
#+END_SRC

as

#+BEGIN_SRC scala
(data.foo |@| data.bar)(_ + _.shows) : Option[String]

#+END_SRC

If we only want the combined output as a tuple, methods exist to do
just that:

#+BEGIN_SRC scala
  @op("tuple") def tuple2[A,B](fa: =>F[A],fb: =>F[B]): F[(A,B)] = ...
  def tuple3[A,B,C](fa: =>F[A],fb: =>F[B],fc: =>F[C]): F[(A,B,C)] = ...
  ...
  def tuple12[...]
#+END_SRC

#+BEGIN_SRC scala
(data.foo tuple data.bar) : Option[(String, Int)]
#+END_SRC

There are also the generalised versions of =ap= for more than two
parameters:

#+BEGIN_SRC scala
  def ap2[A,B,C](fa: =>F[A],fb: =>F[B])(f: F[(A,B) => C]): F[C] = ...
  def ap3[A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: F[(A,B,C) => D]): F[D] = ...
  ...
  def ap12[...]
#+END_SRC

along with =lift= methods that take normal functions and lift them into the
=F[_]= context, the generalisation of =Functor.lift=

#+BEGIN_SRC scala
  def lift2[A,B,C](f: (A,B) => C): (F[A],F[B]) => F[C] = ...
  def lift3[A,B,C,D](f: (A,B,C) => D): (F[A],F[B],F[C]) => F[D] = ...
  ...
  def lift12[...]
#+END_SRC

and =apF=, a partially applied syntax for =ap=

#+BEGIN_SRC scala
  def apF[A,B](f: =>F[A => B]): F[A] => F[B] = ...
#+END_SRC

Finally =forever=

#+BEGIN_SRC scala
  def forever[A, B](fa: F[A]): F[B] = ...
#+END_SRC

repeating an effect without stopping. The instance of =Apply= must be
stack safe or we'll get =StackOverflowError=.

**** Bind

=Bind= introduces =bind=, synonymous with =flatMap=, which allows
functions over the result of an effect to return a new effect, or for
functions over the values of a data structure to return new data
structures that are then joined.

#+BEGIN_SRC scala
@typeclass trait Bind[F[_]] extends Apply[F] {

  @op(">>=") def bind[A, B](fa: F[A])(f: A => F[B]): F[B]
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B] = bind(fa)(f)

  override def ap[A, B](fa: => F[A])(f: => F[A => B]): F[B] =
    bind(f)(x => map(fa)(x))
  override def apply2[A, B, C](fa: => F[A], fb: => F[B])(f: (A, B) => C): F[C] =
    bind(fa)(a => map(fb)(b => f(a, b)))

  def join[A](ffa: F[F[A]]): F[A] = bind(ffa)(identity)

  def mproduct[A, B](fa: F[A])(f: A => F[B]): F[(A, B)] = ...
  def ifM[B](value: F[Boolean], t: =>F[B], f: =>F[B]): F[B] = ...

}
#+END_SRC

The =.join= may be familiar if you have ever used =.flatten= in the stdlib, it
takes a nested context and squashes it into one.

Although not necessarily implemented as such, we can think of =.bind= as being a
=Functor.map= followed by =.join=

#+BEGIN_SRC scala
def bind[A, B](fa: F[A])(f: A => F[B]): F[B] = join(map(fa)(f))
#+END_SRC

Derived combinators are introduced for =.ap= and =.apply2= that require
consistency with =.bind=. We will see later that this law has consequences for
parallelisation strategies.

=mproduct= is like =Functor.fproduct= and pairs the function's input
with its output, inside the =F=.

=ifM= is a way to construct a conditional data structure or effect:

#+BEGIN_SRC scala
scala> List(true, false, true).ifM(List(0), List(1, 1))
res: List[Int] = List(0, 1, 1, 0)
#+END_SRC

=ifM= and =ap= are optimised to cache and reuse code branches, compare
to the longer form

#+BEGIN_SRC scala
scala> List(true, false, true).flatMap { b => if (b) List(0) else List(1, 1) }
#+END_SRC

which produces a fresh =List(0)= or =List(1, 1)= every time the branch
is invoked.

#+BEGIN_ASIDE
These kinds of optimisations are possible in FP because all methods
are deterministic, also known as /referentially transparent/.

If a method returns a different value every time it is called, it is
/impure/ and breaks the reasoning and optimisations that we can
otherwise make.

If the =F= is an effect, perhaps one of our drone or Google algebras,
it does not mean that the output of the call to the algebra is cached.
Rather the reference to the operation is cached. The performance
optimisation of =ifM= is only noticeable for data structures, and more
pronounced with the difficulty of the work in each branch.

We will explore the concept of determinism and value caching in more
detail in the next chapter.
#+END_ASIDE

=Bind= also has some special syntax

#+BEGIN_SRC scala
implicit class BindOps[F[_]: Bind, A] (self: F[A]) {
  def >>[B](b: =>F[B]): F[B] = Bind[F].bind(self)(_ => b)
  def >>![B](f: A => F[B]): F[A] = Bind[F].bind(self)(a => f(a).map(_ => a))
}
#+END_SRC

=>>= is when we wish to discard the input to =bind= and =>>!= is when
we want to run an effect but discard its output.

*** Applicative and Monad

From a functionality point of view, =Applicative= is =Apply= with a
=pure= method, and =Monad= extends =Applicative= with =Bind=.

#+BEGIN_SRC dot :file images/scalaz-applicative.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind [fontcolor=lightslategray,color=lightslategray];
    Apply [fontcolor=lightslategray,color=lightslategray];
    Contravariant [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    InvariantFunctor [fontcolor=lightslategray,color=lightslategray];
    Functor;
    Divide;
    Divisible;
    Apply;
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative [fontcolor=black,color=black];
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad [fontcolor=black,color=black];
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Bind -> Apply [color=lightslategray];

    Contravariant -> InvariantFunctor [color=lightslategray];
    Functor -> InvariantFunctor [color=lightslategray];

    Divide -> Contravariant;
    Divisible -> Divide;
    Apply -> Functor [color=lightslategray];
    Applicative -> Apply [color=black];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative [color=black];
    "Advanced Monads" -> Monad;
    Monad -> Bind [color=black];

    Cobind -> Functor;
    Comonad -> Cobind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;

    Align -> Functor [color=lightslategray];
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-applicative.png]]

#+BEGIN_SRC scala
@typeclass trait Applicative[F[_]] extends Apply[F] {
  def point[A](a: =>A): F[A]
  def pure[A](a: =>A): F[A] = point(a)
}

@typeclass trait Monad[F[_]] extends Applicative[F] with Bind[F]
#+END_SRC

In many ways, =Applicative= and =Monad= are the culmination of everything we've
seen in this chapter. =.pure= (or =.point= as it is more commonly known for data
structures) allows us to create effects or data structures from values.

Instances of =Applicative= must meet some laws, effectively asserting
that all the methods are consistent:

- *Identity*: ~fa <*> pure(identity) === fa~, (where ~fa~ is an ~F[A]~) i.e.
  applying ~pure(identity)~ does nothing.
- *Homomorphism*: ~pure(a) <*> pure(ab) === pure(ab(a))~ (where ~ab~ is an ~A =>
  B~), i.e. applying a ~pure~ function to a ~pure~ value is the same as applying
  the function to the value and then using ~pure~ on the result.
- *Interchange*: ~pure(a) <*> fab === fab <*> pure(f => f(a))~, (where ~fab~ is
  an ~F[A => B]~), i.e. ~pure~ is a left and right identity
- *Mappy*: ~map(fa)(f) === fa <*> pure(f)~

=Monad= adds additional laws:

- *Left Identity*: ~pure(a).bind(f) === f(a)~
- *Right Identity*: ~a.bind(pure(_)) === a~
- *Associativity*: ~fa.bind(f).bind(g) === fa.bind(a => f(a).bind(g))~ where
  ~fa~ is an ~F[A]~, ~f~ is an ~A => F[B]~ and ~g~ is a ~B => F[C]~.

Associativity says that chained =bind= calls must agree with nested
=bind=. However, it does not mean that we can rearrange the order,
which would be /commutativity/. For example, recalling that =flatMap=
is an alias to =bind=, we cannot rearrange

#+BEGIN_SRC scala
for {
  _ <- machine.start(node1)
  _ <- machine.stop(node1)
} yield true
#+END_SRC

as

#+BEGIN_SRC scala
for {
  _ <- machine.stop(node1)
  _ <- machine.start(node1)
} yield true
#+END_SRC

=start= and =stop= are *non*-/commutative/, because the intended
effect of starting then stopping a node is different to stopping then
starting it!

But =start= is commutative with itself, and =stop= is commutative with
itself, so we can rewrite

#+BEGIN_SRC scala
for {
  _ <- machine.start(node1)
  _ <- machine.start(node2)
} yield true
#+END_SRC

as

#+BEGIN_SRC scala
for {
  _ <- machine.start(node2)
  _ <- machine.start(node1)
} yield true
#+END_SRC

which are equivalent. We're making a lot of assumptions about the
Google Container API here, but this is a reasonable choice to make.

A practical consequence is that a =Monad= must be /commutative/ if its
=applyX= methods can be allowed to run in parallel. We cheated in
Chapter 3 when we ran these effects in parallel

#+BEGIN_SRC scala
(d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)
#+END_SRC

because we know that they are commutative among themselves. When it comes to
interpreting our application, later in the book, we will have to provide
evidence that these effects are in fact commutative, or an asynchronous
implementation may choose to sequence the operations to be on the safe side.

The subtleties of how we deal with (re)-ordering of effects, and what
those effects are, deserves a dedicated chapter on Advanced Monads.

*** Divide and Conquer

#+BEGIN_SRC dot :file images/scalaz-divide.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind [fontcolor=lightslategray,color=lightslategray];
    Apply [fontcolor=lightslategray,color=lightslategray];
    Contravariant [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    InvariantFunctor [fontcolor=lightslategray,color=lightslategray];
    Functor;
    Divide [fontcolor=black,color=black];
    Divisible [fontcolor=black,color=black];
    Apply;
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative [fontcolor=lightslategray,color=lightslategray];
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad [fontcolor=lightslategray,color=lightslategray];
    "Advanced Monads" [style=dashed];
    Plus;
    PlusEmpty;
    IsEmpty;
    ApplicativePlus;
    MonadPlus;

    Bind -> Apply [color=lightslategray];

    Contravariant -> InvariantFunctor [color=lightslategray];
    Functor -> InvariantFunctor [color=lightslategray];

    Divide -> Contravariant [color=black];
    Divisible -> Divide [color=black];
    Apply -> Functor [color=lightslategray];
    Applicative -> Apply [color=lightslategray];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative [color=lightslategray];
    "Advanced Monads" -> Monad;
    Monad -> Bind [color=lightslategray];

    Cobind -> Functor;
    Comonad -> Cobind;

    PlusEmpty -> Plus;
    IsEmpty -> PlusEmpty;

    ApplicativePlus -> Applicative;
    ApplicativePlus -> PlusEmpty;
    MonadPlus -> ApplicativePlus;
    MonadPlus -> Monad;

    Align -> Functor [color=lightslategray];
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-divide.png]]

=Divide= is the =Contravariant= analogue of =Apply=

#+BEGIN_SRC scala
@typeclass trait Divide[F[_]] extends Contravariant[F] {
  def divide[A, B, C](fa: F[A], fb: F[B])(f: C => (A, B)): F[C] = divide2(fa, fb)(f)

  def divide1[A1, Z](a1: F[A1])(f: Z => A1): F[Z] = ...
  def divide2[A, B, C](fa: F[A], fb: F[B])(f: C => (A, B)): F[C] = ...
  ...
  def divide22[...] = ...
#+END_SRC

=divide= says that if we can break a =C= into an =A= and a =B=, and
we're given an =F[A]= and an =F[B]=, then we can get an =F[C]=. Hence,
/divide and conquer/.

This is a great way to generate contravariant typeclass instances for
product types by breaking the products into their parts. Scalaz has an
instance of =Divide[Equal]=, let's construct an =Equal= for a new
product type =Foo=

#+BEGIN_SRC scala
scala> case class Foo(s: String, i: Int)
scala> implicit val fooEqual: Equal[Foo] =
         Divide[Equal].divide2(Equal[String], Equal[Int]) {
           (foo: Foo) => (foo.s, foo.i)
         }
scala> Foo("foo", 1) === Foo("bar", 1)
res: Boolean = false
#+END_SRC

It is a good moment to look again at =Apply=

#+BEGIN_SRC scala
@typeclass trait Apply[F[_]] extends Functor[F] {
  ...
  def apply2[A, B, C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C): F[C] = ...
  def apply3[A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: (A,B,C) =>D): F[D] = ...
  ...
  def apply12[...]
  ...
}
#+END_SRC

It is now easier to spot that =applyX= is how we can derive typeclasses
for covariant typeclasses.

Mirroring =Apply=, =Divide= also has terse syntax for tuples. A softer
/divide so that you may reign/ approach to world domination:

#+BEGIN_SRC scala
  ...
  def tuple2[A1, A2](a1: F[A1], a2: F[A2]): F[(A1, A2)] = ...
  ...
  def tuple22[...] = ...

  def deriving2[A1: F, A2: F, Z](f: Z => (A1, A2)): F[Z] = ...
  ...
  def deriving22[...] = ...
}
#+END_SRC

and =deriving=, which is even more convenient to use for typeclass
derivation:

#+BEGIN_SRC scala
implicit val fooEqual: Equal[Foo] = Divide[Equal].deriving2(f => (f.s, f.i))
#+END_SRC

Generally, if encoder typeclasses can provide an instance of =Divide=,
rather than stopping at =Contravariant=, it makes it possible to
derive instances for any =case class=. Similarly, decoder typeclasses
can provide an =Apply= instance. We will explore this in a dedicated
chapter on Typeclass Derivation.

=Divisible= is the =Contravariant= analogue of =Applicative= and
introduces =conquer=, the equivalent of =pure=

#+BEGIN_SRC scala
@typeclass trait Divisible[F[_]] extends Divide[F] {
  def conquer[A]: F[A]
}
#+END_SRC

=conquer= allows creating fallback implementations that effectively ignore the
type parameter. Such values are called /universally quantified/. For example,
the =Divisible[Equal].conquer[String]= returns a trivial implementation of
=Equal= that always returns =true=, which allows us to implement =contramap= in
terms of =divide=

#+BEGIN_SRC scala
  override def contramap[A, B](fa: F[A])(f: B => A): F[B] =
    divide(conquer[Unit], fa)(c => ((), f(c)))
#+END_SRC

# https://github.com/scalaz/scalaz/issues/1481

*** Plus

#+BEGIN_SRC dot :file images/scalaz-plus.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind;
    Comonad;
    Bind [fontcolor=lightslategray,color=lightslategray];
    Apply [fontcolor=lightslategray,color=lightslategray];
    Contravariant [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    InvariantFunctor [fontcolor=lightslategray,color=lightslategray];
    Functor;
    Divide [fontcolor=lightslategray,color=lightslategray];
    Divisible [fontcolor=lightslategray,color=lightslategray];
    Apply;
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative [fontcolor=lightslategray,color=lightslategray];
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad [fontcolor=lightslategray,color=lightslategray];
    "Advanced Monads" [style=dashed];
    Plus [fontcolor=black,color=black];
    PlusEmpty [fontcolor=black,color=black];
    IsEmpty [fontcolor=black,color=black];
    ApplicativePlus [fontcolor=black,color=black];
    MonadPlus [fontcolor=black,color=black];

    Bind -> Apply [color=lightslategray];

    Contravariant -> InvariantFunctor [color=lightslategray];
    Functor -> InvariantFunctor [color=lightslategray];

    Divide -> Contravariant [color=lightslategray];
    Divisible -> Divide [color=lightslategray];
    Apply -> Functor [color=lightslategray];
    Applicative -> Apply [color=lightslategray];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative [color=lightslategray];
    "Advanced Monads" -> Monad;
    Monad -> Bind [color=lightslategray];

    Cobind -> Functor;
    Comonad -> Cobind;

    PlusEmpty -> Plus [color=black];
    IsEmpty -> PlusEmpty [color=black];

    ApplicativePlus -> Applicative [color=black];
    ApplicativePlus -> PlusEmpty [color=black];
    MonadPlus -> ApplicativePlus [color=black];
    MonadPlus -> Monad [color=black];

    Align -> Functor [color=lightslategray];
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-plus.png]]

=Plus= is =Semigroup= but for type constructors, and =PlusEmpty= is
the equivalent of =Monoid= (they even have the same laws) whereas
=IsEmpty= is novel and allows us to query if an =F[A]= is empty:

#+BEGIN_SRC scala
@typeclass trait Plus[F[_]] {
  @op("<+>") def plus[A](a: F[A], b: =>F[A]): F[A]
}
@typeclass trait PlusEmpty[F[_]] extends Plus[F] {
  def empty[A]: F[A]
}
@typeclass trait IsEmpty[F[_]] extends PlusEmpty[F] {
  def isEmpty[A](fa: F[A]): Boolean
}
#+END_SRC

#+BEGIN_ASIDE
=<+>= is the TIE Interceptor, and now we're almost out of TIE
Fighters...
#+END_ASIDE

Although it may look on the surface as if =<+>= behaves like =|+|=

#+BEGIN_SRC scala
scala> List(2,3) |+| List(7)
res = List(2, 3, 7)

scala> List(2,3) <+> List(7)
res = List(2, 3, 7)
#+END_SRC

it is best to think of it as operating only at the =F[_]= level, never looking
into the contents. =Plus= has the convention that it should ignore failures and
"pick the first winner". =<+>= can therefore be used as a mechanism for early
exit (losing information) and failure-handling via fallbacks:

#+BEGIN_SRC scala
scala> Option(1) |+| Option(2)
res = Some(3)

scala> Option(1) <+> Option(2)
res = Some(1)

scala> Option.empty[Int] <+> Option(1)
res = Some(1)
#+END_SRC

For example, if we have a =NonEmptyList[Option[Int]]= and we want to ignore
=None= values (failures) and pick the first winner (=Some=), we can call =<+>=
from =Foldable1.foldRight1=:

#+BEGIN_SRC scala
scala> NonEmptyList(None, None, Some(1), Some(2), None)
       .foldRight1(_ <+> _)
res: Option[Int] = Some(1)
#+END_SRC

In fact, now that we know about =Plus=, we release that we didn't need to break
typeclass coherence (when we defined a locally scoped =Monoid[Option[A]]=) in
the section on Appendable Things. Our objective was to "pick the last winner",
which is the same as "pick the winner" if the arguments are swapped. Note the
use of the TIE Interceptor for =ccy= and =otc= and that =b= comes before =a= in

#+BEGIN_SRC scala
implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
  (a, b) =>
    TradeTemplate(a.payments |+| b.payments,
                  b.ccy <+> a.ccy,
                  b.otc <+> a.otc),
  TradeTemplate(Nil, None, None)
)
#+END_SRC

=Applicative= and =Monad= have specialised versions of =PlusEmpty=

#+BEGIN_SRC scala
@typeclass trait ApplicativePlus[F[_]] extends Applicative[F] with PlusEmpty[F]

@typeclass trait MonadPlus[F[_]] extends Monad[F] with ApplicativePlus[F] {
  def unite[T[_]: Foldable, A](ts: F[T[A]]): F[A] = ...

  def withFilter[A](fa: F[A])(f: A => Boolean): F[A] = ...
}
#+END_SRC

=ApplicativePlus= is also known as =Alternative=.

=unite= looks a =Foldable.fold= on the contents of =F[_]= but is
folding with the =PlusEmpty[F].monoid= (not the =Monoid[A]=). For
example, uniting =List[Either[_, _]]= means =Left= becomes =empty=
(=Nil=) and the contents of =Right= become single element =List=,
which are then concatenated:

#+BEGIN_SRC scala
scala> List(Right(1), Left("boo"), Right(2)).unite
res: List[Int] = List(1, 2)

scala> val boo: Either[String, Int] = Left("boo")
       boo.foldMap(a => a.pure[List])
res: List[String] = List()

scala> val n: Either[String, Int] = Right(1)
       n.foldMap(a => a.pure[List])
res: List[Int] = List(1)
#+END_SRC

=withFilter= allows us to make use of =for= comprehension language
support as discussed in Chapter 2. It is fair to say that the Scala
language has built-in language support for =MonadPlus=, not just
=Monad=!

Returning to =Foldable= for a moment, we can reveal some methods that
we did not discuss earlier

#+BEGIN_SRC scala
@typeclass trait Foldable[F[_]] {
  ...
  def msuml[G[_]: PlusEmpty, A](fa: F[G[A]]): G[A] = ...
  def collapse[X[_]: ApplicativePlus, A](x: F[A]): X[A] = ...
  ...
}
#+END_SRC

=msuml= does a =fold= using the =Monoid= from the =PlusEmpty[G]= and
=collapse= does a =foldRight= using the =PlusEmpty= of the target
type:

#+BEGIN_SRC scala
scala> IList(Option(1), Option.empty[Int], Option(2)).fold
res: Option[Int] = Some(3) // uses Monoid[Option[Int]]

scala> IList(Option(1), Option.empty[Int], Option(2)).msuml
res: Option[Int] = Some(1) // uses PlusEmpty[Option].monoid

scala> IList(1, 2).collapse[Option]
res: Option[Int] = Some(1)
#+END_SRC

*** Lone Wolves

Some of the typeclasses in scalaz are stand-alone and not part of the
larger hierarchy.

#+BEGIN_SRC dot :file images/scalaz-loners.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Zip;
    Unzip;
    Cozip [fontcolor=lightgray,color=lightgray];
    Show [fontcolor=lightslategray,color=lightslategray];
    Optional;
    Catchable;
}
#+END_SRC

#+CAPTION: 80
#+RESULTS:
[[file:images/scalaz-loners.png]]

**** Zippy

#+BEGIN_SRC scala
@typeclass trait Zip[F[_]]  {
  def zip[A, B](a: =>F[A], b: =>F[B]): F[(A, B)]

  def zipWith[A, B, C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C)
                      (implicit F: Functor[F]): F[C] = ...

  def ap(implicit F: Functor[F]): Apply[F] = ...

  @op("<*|*>") def apzip[A, B](f: =>F[A] => F[B], a: =>F[A]): F[(A, B)] = ...

}
#+END_SRC

The core method is =zip= which is a less powerful version of
=Divide.tuple2=, and if a =Functor[F]= is provided then =zipWith= can
behave like =Apply.apply2=. Indeed, an =Apply[F]= can be created from
a =Zip[F]= and a =Functor[F]= by calling =ap=.

~apzip~ takes an ~F[A]~ and a lifted function from ~F[A] => F[B]~,
producing an ~F[(A, B)]~ similar to ~Functor.fproduct~.

#+BEGIN_ASIDE
~<*|*>~ is the creepy Jawa operator.
#+END_ASIDE

#+BEGIN_SRC scala
@typeclass trait Unzip[F[_]]  {
  @op("unfzip") def unzip[A, B](a: F[(A, B)]): (F[A], F[B])

  def firsts[A, B](a: F[(A, B)]): F[A] = ...
  def seconds[A, B](a: F[(A, B)]): F[B] = ...

  def unzip3[A, B, C](x: F[(A, (B, C))]): (F[A], F[B], F[C]) = ...
  ...
  def unzip7[A ... H](x: F[(A, (B, ... H))]): ...
}
#+END_SRC

The core method is =unzip= with =firsts= and =seconds= allowing for
selecting either the first or second element of a tuple in the =F=.
Importantly, =unzip= is the opposite of =zip=.

The methods =unzip3= to =unzip7= are repeated applications of =unzip=
to save on boilerplate. For example, if handed a bunch of nested
tuples, the =Unzip[Id]= is a handy way to flatten them:

#+BEGIN_SRC scala
scala> Unzip[Id].unzip7((1, (2, (3, (4, (5, (6, 7)))))))
res = (1,2,3,4,5,6,7)
#+END_SRC

In a nutshell, =Zip= and =Unzip= are less powerful versions of
=Divide= and =Apply=, providing useful features without requiring the
=F= to make too many promises.

**** Optional

=Optional= is a generalisation of data structures that can optionally
contain a value, like =Option= and =Either=.

Recall that =\/= (/disjunction/) is scalaz's improvement of
=scala.Either=. We will also see =Maybe=, scalaz's improvement of
=scala.Option=

#+BEGIN_SRC scala
sealed abstract class Maybe[A]
final case class Empty[A]()    extends Maybe[A]
final case class Just[A](a: A) extends Maybe[A]
#+END_SRC

#+BEGIN_SRC scala
@typeclass trait Optional[F[_]] {
  def pextract[B, A](fa: F[A]): F[B] \/ A

  def getOrElse[A](fa: F[A])(default: =>A): A = ...
  def orElse[A](fa: F[A])(alt: =>F[A]): F[A] = ...

  def isDefined[A](fa: F[A]): Boolean = ...
  def nonEmpty[A](fa: F[A]): Boolean = ...
  def isEmpty[A](fa: F[A]): Boolean = ...

  def toOption[A](fa: F[A]): Option[A] = ...
  def toMaybe[A](fa: F[A]): Maybe[A] = ...
}
#+END_SRC

These are methods that should be familiar, except perhaps =pextract=,
which is a way of letting the =F[_]= return some implementation
specific =F[B]= or the value. For example, =Optional[Option].pextract=
returns =Option[Nothing] \/ A=, i.e. =None \/ A=.

Scalaz gives a ternary operator to things that have an =Optional=

#+BEGIN_SRC scala
implicit class OptionalOps[F[_]: Optional, A](fa: F[A]) {
  def ?[X](some: =>X): Conditional[X] = new Conditional[X](some)
  final class Conditional[X](some: =>X) {
    def |(none: =>X): X = if (Optional[F].isDefined(fa)) some else none
  }
}
#+END_SRC

for example

#+BEGIN_SRC scala
scala> val knock_knock: Option[String] = ...
       knock_knock ? "who's there?" | "<tumbleweed>"
#+END_SRC

Next time you write a function that takes an =Option=, consider
rewriting it to take =Optional= instead: it'll make it easier to
migrate to data structures that have better error handling without any
loss of functionality.

**** Catchable

Our grand plans to write total functions that return a value for every
input may be in ruins when exceptions are the norm in the Java
standard library, the Scala standard library, and the myriad of legacy
systems that we must interact with.

scalaz does not magically handle exceptions automatically, but it does
provide the mechanism to protect against bad legacy systems.

#+BEGIN_SRC scala
@typeclass trait Catchable[F[_]] {
  def attempt[A](f: F[A]): F[Throwable \/ A]
  def fail[A](err: Throwable): F[A]
}
#+END_SRC

=attempt= will catch any exceptions inside =F[_]= and make the JVM
=Throwable= an explicit return type that can be mapped into an error
reporting ADT, or left as an indicator to downstream callers that
/Here be Dragons/.

=fail= permits callers to throw an exception in the =F[_]= context
and, since this breaks purity, will be removed from scalaz. Exceptions
that are raised via =fail= must be later handled by =attempt= since it
is just as bad as calling legacy code that throws an exception.

It is worth noting that =Catchable[Id]= cannot be implemented. An
=Id[A]= cannot exist in a state that may contain an exception.
However, there are instances for both =scala.concurrent.Future=
(asynchronous) and =scala.Either= (synchronous), allowing =Catchable=
to abstract over the unhappy path. =MonadError=, as we will see in a
later chapter, is a superior replacement.

*** Co-things

A /co-thing/ typically has some opposite type signature to whatever
/thing/ does, but is not necessarily its inverse. To highlight the
relationship between /thing/ and /co-thing/, we will include the type
signature of /thing/ wherever we can.

#+BEGIN_SRC dot :file images/scalaz-cothings.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];
    node [fontcolor=lightgray,color=lightgray];
    edge [color=lightgray]

    Cobind [fontcolor=black,color=black];
    Comonad [fontcolor=black,color=black];
    Bind [fontcolor=lightslategray,color=lightslategray];
    Apply [fontcolor=lightslategray,color=lightslategray];
    Contravariant [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    InvariantFunctor [fontcolor=lightslategray,color=lightslategray];
    Functor [fontcolor=lightslategray,color=lightslategray];
    Divide [fontcolor=lightslategray,color=lightslategray];
    Divisible [fontcolor=lightslategray,color=lightslategray];
    Apply [fontcolor=lightslategray,color=lightslategray];
    Align [fontcolor=lightslategray,color=lightslategray];
    Applicative [fontcolor=lightslategray,color=lightslategray];
    Foldable1 [fontcolor=lightslategray,color=lightslategray];
    Foldable [fontcolor=lightslategray,color=lightslategray];
    Traverse [fontcolor=lightslategray,color=lightslategray];
    Traverse1 [fontcolor=lightslategray,color=lightslategray];
    Monad [fontcolor=lightslategray,color=lightslategray];
    "Advanced Monads" [style=dashed];
    Plus [fontcolor=lightslategray,color=lightslategray];
    PlusEmpty [fontcolor=lightslategray,color=lightslategray];
    IsEmpty [fontcolor=lightslategray,color=lightslategray];
    ApplicativePlus [fontcolor=lightslategray,color=lightslategray];
    MonadPlus [fontcolor=lightslategray,color=lightslategray];

    Bind -> Apply [color=lightslategray];

    Contravariant -> InvariantFunctor [color=lightslategray];
    Functor -> InvariantFunctor [color=lightslategray];

    Divide -> Contravariant [color=lightslategray];
    Divisible -> Divide [color=lightslategray];
    Apply -> Functor [color=lightslategray];
    Applicative -> Apply [color=lightslategray];

    Foldable1 -> Foldable [color=lightslategray];
    Traverse -> Functor [color=lightslategray];
    Traverse -> Foldable [color=lightslategray];
    Traverse1 -> Traverse [color=lightslategray];
    Traverse1 -> Foldable1 [color=lightslategray];

    Monad -> Applicative [color=lightslategray];
    "Advanced Monads" -> Monad;
    Monad -> Bind [color=lightslategray];

    Cobind -> Functor [color=black];
    Comonad -> Cobind [color=black];

    PlusEmpty -> Plus [color=lightslategray];
    IsEmpty -> PlusEmpty [color=lightslategray];

    ApplicativePlus -> Applicative [color=lightslategray];
    ApplicativePlus -> PlusEmpty [color=lightslategray];
    MonadPlus -> ApplicativePlus [color=lightslategray];
    MonadPlus -> Monad [color=lightslategray];

    Align -> Functor [color=lightslategray];
}
#+END_SRC

#+CAPTION: 100
#+RESULTS:
[[file:images/scalaz-cothings.png]]

#+BEGIN_SRC dot :file images/scalaz-coloners.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Zip [fontcolor=lightslategray,color=lightslategray];
    Unzip [fontcolor=lightslategray,color=lightslategray];
    Cozip [fontcolor=black,color=black];
    Show [fontcolor=lightslategray,color=lightslategray];
    Optional [fontcolor=lightslategray,color=lightslategray];
    Catchable [fontcolor=lightslategray,color=lightslategray];
}
#+END_SRC

#+CAPTION: 80
#+RESULTS:
[[file:images/scalaz-coloners.png]]

**** Cobind

#+BEGIN_SRC scala
@typeclass trait Cobind[F[_]] extends Functor[F] {
  def cobind[A, B](fa: F[A])(f: F[A] => B): F[B]
//def   bind[A, B](fa: F[A])(f: A => F[B]): F[B]

  def cojoin[A](fa: F[A]): F[F[A]] = ...
//def   join[A](ffa: F[F[A]]): F[A] = ...
}
#+END_SRC

~cobind~ (also known as ~coflatmap~) takes an ~F[A] => B~ that acts on
an ~F[A]~ rather than its elements. But this is not necessarily the
full ~fa~, it is usually some substructure as defined by ~cojoin~
(also known as ~coflatten~) which expands a data structure.

Compelling use-cases for =Cobind= are rare, although when shown in the
=Functor= permutation table (for =F[_]=, =A= and =B=) it is difficult
to argue why any method should be less important than the others:

| method      | parameter          |
|-------------+--------------------|
| ~map~       | ~A => B~           |
| ~contramap~ | ~B => A~           |
| ~xmap~      | ~(A => B, B => A)~ |
| ~ap~        | ~F[A => B]~        |
| ~bind~      | ~A => F[B]~        |
| ~cobind~    | ~F[A] => B~        |

**** Comonad

#+BEGIN_SRC scala
@typeclass trait Comonad[F[_]] extends Cobind[F] {
  def copoint[A](p: F[A]): A
//def   point[A](a: =>A): F[A]
}
#+END_SRC

=copoint= (also =copure=) unwraps an element from a context. When
interpreting a pure program, we typically require a =Comonad= to run
the interpreter inside the application's =def main= entry point. For
example, =Comonad[Future].copoint= will =await= the execution of a
=Future[Unit]=.

Far more interesting is the =Comonad= of a /data structure/. This is a
way to construct a view of all elements alongside their neighbours.
Consider a /neighbourhood/ (=Hood= for short) for a list containing
all the elements to the left of an element (=lefts=), the element
itself (the =focus=), and all the elements to its right (=rights=).

#+BEGIN_SRC scala
final case class Hood[A](lefts: IList[A], focus: A, rights: IList[A])
#+END_SRC

#+BEGIN_ASIDE
We use scalaz data structures =IList= and =Maybe=, instead of stdlib
=List= and =Option=, to protect us from accidentally calling impure
methods.
#+END_ASIDE

The =lefts= and =rights= should each be ordered with the nearest to
the =focus= at the head, such that we can recover the original =IList=
via =.toList=

#+BEGIN_SRC scala
object Hood {
  implicit class Ops[A](hood: Hood[A]) {
    def toList: IList[A] = hood.lefts.reverse ::: hood.focus :: hood.rights
#+END_SRC

We can write methods that let us move the focus one to the left
(=previous=) and one to the right (=next=)

#+BEGIN_SRC scala
...
    def previous: Maybe[Hood[A]] = hood.lefts match {
      case INil() => Empty()
      case ICons(head, tail) =>
        Just(Hood(tail, head, hood.focus :: hood.rights))
    }
    def next: Maybe[Hood[A]] = hood.rights match {
      case INil() => Empty()
      case ICons(head, tail) =>
        Just(Hood(hood.focus :: hood.lefts, head, tail))
    }
#+END_SRC

By introducing =more= to repeatedly apply an optional function to
=Hood= we can calculate /all/ the =positions= that =Hood= can take in
the list

#+BEGIN_SRC scala
...
    def more(f: Hood[A] => Maybe[Hood[A]]): IList[Hood[A]] =
      f(hood) match {
        case Empty() => INil()
        case Just(r) => ICons(r, r.more(f))
      }
    def positions: Hood[Hood[A]] = {
      val left  = hood.more(_.previous)
      val right = hood.more(_.next)
      Hood(left, hood, right)
    }
  }
#+END_SRC

We can now implement =Comonad[Hood]=

#+BEGIN_SRC scala
...
  implicit val comonad: Comonad[Hood] = new Comonad[Hood] {
    def map[A, B](fa: Hood[A])(f: A => B): Hood[B] =
      Hood(fa.lefts.map(f), f(fa.focus), fa.rights.map(f))
    def cobind[A, B](fa: Hood[A])(f: Hood[A] => B): Hood[B] =
      fa.positions.map(f)
    def copoint[A](fa: Hood[A]): A = fa.focus
  }
}
#+END_SRC

=cojoin= gives us a =Hood[Hood[IList]]= containing all the possible
neighbourhoods in our initial =IList=

#+BEGIN_SRC scala
scala> val middle = Hood(IList(4, 3, 2, 1), 5, IList(6, 7, 8, 9))
       println(middle.cojoin)

res = Hood(
        [Hood([3,2,1],4,[5,6,7,8,9]),
         Hood([2,1],3,[4,5,6,7,8,9]),
         Hood([1],2,[3,4,5,6,7,8,9]),
         Hood([],1,[2,3,4,5,6,7,8,9])],
        Hood([4,3,2,1],5,[6,7,8,9]),
        [Hood([5,4,3,2,1],6,[7,8,9]),
         Hood([6,5,4,3,2,1],7,[8,9]),
         Hood([7,6,5,4,3,2,1],8,[9]),
         Hood([8,7,6,5,4,3,2,1],9,[])])
#+END_SRC

Indeed, =cojoin= is just =positions=! We can =override= it with a more
direct (and performant) implementation

#+BEGIN_SRC scala
override def cojoin[A](fa: Hood[A]): Hood[Hood[A]] = fa.positions
#+END_SRC

=Comonad= generalises the concept of =Hood= to arbitrary data
structures. =Hood= is an example of a /zipper/ (unrelated to =Zip=).
Scalaz comes with a =Zipper= data type for streams (i.e. infinite 1D
data structures), which we will discuss in the next chapter.

One application of a zipper is for /cellular automata/, which compute
the value of each cell in the next generation by performing a
computation based on the neighbourhood of that cell.

**** Cozip

#+BEGIN_SRC scala
@typeclass trait Cozip[F[_]] {
  def cozip[A, B](x: F[A \/ B]): F[A] \/ F[B]
//def   zip[A, B](a: =>F[A], b: =>F[B]): F[(A, B)]
//def unzip[A, B](a: F[(A, B)]): (F[A], F[B])

  def cozip3[A, B, C](x: F[A \/ (B \/ C)]): F[A] \/ (F[B] \/ F[C]) = ...
  ...
  def cozip7[A ... H](x: F[(A \/ (... H))]): F[A] \/ (... F[H]) = ...
}
#+END_SRC

Although named =cozip=, it is perhaps more appropriate to talk about
its symmetry with =unzip=. Whereas =unzip= splits =F[_]= of tuples
(products) into tuples of =F[_]=, =cozip= splits =F[_]= of
disjunctions (coproducts) into disjunctions of =F[_]=.

*** Bi-things

Sometimes we may find ourselves with a thing that has two type holes
and we want to =map= over both sides. For example we might be tracking
failures in the left of an =Either= and we want to do something with the
failure messages.

The =Functor= / =Foldable= / =Traverse= typeclasses have bizarro
relatives that allow us to map both ways.

#+BEGIN_SRC dot :file images/scalaz-bithings.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Bitraverse -> Bifunctor;
    Bitraverse -> Bifoldable;
}
#+END_SRC

#+CAPTION: 30
#+RESULTS:
[[file:images/scalaz-bithings.png]]

#+BEGIN_SRC scala
@typeclass trait Bifunctor[F[_, _]] {
  def bimap[A, B, C, D](fab: F[A, B])(f: A => C, g: B => D): F[C, D]

  @op("<-:") def leftMap[A, B, C](fab: F[A, B])(f: A => C): F[C, B] = ...
  @op(":->") def rightMap[A, B, D](fab: F[A, B])(g: B => D): F[A, D] = ...
  @op("<:>") def umap[A, B](faa: F[A, A])(f: A => B): F[B, B] = ...
}

@typeclass trait Bifoldable[F[_, _]] {
  def bifoldMap[A, B, M: Monoid](fa: F[A, B])(f: A => M)(g: B => M): M

  def bifoldRight[A,B,C](fa: F[A, B], z: =>C)(f: (A, =>C) => C)(g: (B, =>C) => C): C
  def bifoldLeft[A,B,C](fa: F[A, B], z: C)(f: (C, A) => C)(g: (C, B) => C): C = ...

  def bifoldMap1[A, B, M: Semigroup](fa: F[A,B])(f: A => M)(g: B => M): Option[M] = ...
}

@typeclass trait Bitraverse[F[_, _]] extends Bifunctor[F] with Bifoldable[F] {
  def bitraverse[G[_]: Applicative, A, B, C, D](fab: F[A, B])
                                               (f: A => G[C])
                                               (g: B => G[D]): G[F[C, D]]

  def bisequence[G[_]: Applicative, A, B](x: F[G[A], G[B]]): G[F[A, B]] = ...
}
#+END_SRC

#+BEGIN_ASIDE
=<-:= and =:->= are the happy operators!
#+END_ASIDE

Although the type signatures are verbose, these are nothing more than
the core methods of =Functor=, =Foldable= and =Bitraverse= taking two
functions instead of one, often requiring both functions to return the
same type so that their results can be combined with a =Monoid= or
=Semigroup=.

#+BEGIN_SRC scala
scala> val a: Either[String, Int] = Left("fail")
       val b: Either[String, Int] = Right(13)

scala> b.bimap(_.toUpperCase, _ * 2)
res: Either[String, Int] = Right(26)

scala> a.bimap(_.toUpperCase, _ * 2)
res: Either[String, Int] = Left(FAIL)

scala> b :-> (_ * 2)
res: Either[String,Int] = Right(26)

scala> a :-> (_ * 2)
res: Either[String, Int] = Left(fail)

scala> { s: String => s.length } <-: a
res: Either[Int, Int] = Left(4)

scala> a.bifoldMap(_.length)(identity)
res: Int = 4

scala> b.bitraverse(s => Future(s.length), i => Future(i))
res: Future[Either[Int, Int]] = Future(<not completed>)
#+END_SRC

In addition, we can revisit =MonadPlus= (recall it is =Monad= with the
ability to =filterWith= and =unite=) and see that it can =separate=
=Bifoldable= contents of a =Monad=

#+BEGIN_SRC scala
@typeclass trait MonadPlus[F[_]] {
  ...
  def separate[G[_, _]: Bifoldable, A, B](value: F[G[A, B]]): (F[A], F[B]) = ...
  ...
}
#+END_SRC

This is very useful if we have a collection of bi-things and we want
to reorganise them into a collection of =A= and a collection of =B=

#+BEGIN_SRC scala
scala> val list: List[Either[Int, String]] =
         List(Right("hello"), Left(1), Left(2), Right("world"))

scala> list.separate
res: (List[Int], List[String]) = (List(1, 2), List(hello, world))
#+END_SRC

*** Very Abstract Things

What remains of the typeclass hierarchy are things that allow us to
meta-reason about functional programming and scalaz. We are not going
to discuss these yet as they deserve a full chapter on Category Theory
and are not needed in typical FP applications.

#+BEGIN_SRC dot :file images/scalaz-abstract.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    Category -> Compose;
    Choice -> Category;
    Split -> Compose;
    Strong -> Profunctor;
    ProChoice -> Profunctor;
    Arrow -> Split;
    Arrow -> Strong;
    Arrow -> Category;
    Associative;
}
#+END_SRC

#+RESULTS:
[[file:images/scalaz-abstract.png]]

*** Summary

That was a lot of material! We have just explored a standard library
of polymorphic functionality. But to put it into perspective: there
are more traits in the Scala stdlib Collections API than typeclasses
in scalaz.

It is normal for an FP application to only touch a small percentage of
the typeclass hierarchy, with most functionality coming from
domain-specific typeclasses. Even if the domain-specific typeclasses
are just specialised clones of something in scalaz, it is better to
write the code and later refactor it, than to over-abstract too early.

To help, we have included a cheat-sheet of the typeclasses and their
primary methods in the Appendix, inspired by Adam Rosien's [[http://arosien.github.io/scalaz-cheatsheets/typeclasses.pdf][Scalaz
Cheatsheet]]. These cheat-sheets make an excellent replacement for the
family portrait on your office desk.

To help further, Valentin Kasas explains how to [[https://twitter.com/ValentinKasas/status/879414703340081156][combine =N= things]]:

#+BEGIN_SRC dot :file images/shortest-fp-book.png :exports results
digraph G {
    graph [dpi=100, rankdir=TB];

    things [label="combine N things",shape=oval];
    type [label="same (or no)\n type parameter",shape=diamond,height=1.2];
    parallel [label="parallel",shape=diamond,height=0.7];
    gtzero [label="N > 0", fontname=Hack,shape=diamond,height=0.7];

    Monad [fontname=Hack];
    Apply [fontname=Hack];

    Semigroup [fontname=Hack];
    hkt [label="early exit",shape=diamond,height=0.7];
    Plus [fontname=Hack];

    effonce [label="effectively once",shape=diamond,height=0.7];
    Monoid [fontname=Hack];
    Band [fontname=Hack]

    things -> type;
    type -> gtzero [label=" yes"];
    hkt -> Plus [label=" yes"]
    hkt -> Semigroup [label=" no"]

    gtzero -> hkt [label=" no"]
    gtzero -> effonce [label=" yes"]

    effonce -> Monoid [label=" no"];
    effonce -> Band [label=" yes"]

    type -> parallel [label=" no"];
    parallel -> Apply [label=" yes"];
    parallel -> Monad [label=" no"];
}
#+END_SRC

#+CAPTION: 70
#+RESULTS:
[[file:images/shortest-fp-book.png]]

** Scalaz Data Types

Who doesn't love a good data structure? The answer is /nobody/, because data
structures are awesome.

In this chapter we'll explore the /collection-like/ data types in scalaz, as
well as data types that augment the Scala language with useful semantics and
additional type safety.

The primary reason we care about having lots of collections at our disposal is
performance. A vector and a list can do the same things, but their performance
characteristics are different: a vector has constant lookup cost whereas a list
must be traversed.

#+BEGIN_WARNING
Performance estimates - including claims in this chapter - should be taken with
a pinch of salt. Modern processor design, memory pipelining, and JVM garbage
collection can invalidate intuitive reasoning based on operation counting.

A hard truth of modern computers is that empirical performance tests, for a
specific task, can shock and surprise: e.g. lookup in a =List= is often faster
in practice than in a =Vector=. Use a tool such as [[http://openjdk.java.net/projects/code-tools/jmh/][JMH]] when performance testing.
#+END_WARNING

All of the collections presented here are /persistent/: if we add or remove an
element we can still use the old version. Structural sharing is essential to the
performance of persistent data structures, otherwise the entire collection is
rebuilt with every operation.

Unlike the Java and Scala collections, there is no hierarchy to the data types
in scalaz: these collections are much simpler to understand. Polymorphic
functionality is provided by optimised instances of the typeclasses we studied
in the previous chapter. This makes it a lot easier to swap implementations for
performance reasons, and to provide our own.

*** Type Variance

# https://failex.blogspot.co.uk/2016/09/the-missing-diamond-of-scala-variance.html?spref=tw
# https://typelevel.org/blog/2016/09/19/variance-phantom.html

Many of scalaz's data types are /invariant/ in their type parameters.
For example, =IList[A]= is *not* a subtype of =IList[B]= when =A <:
B=.

**** Covariance

The problem with /covariant/ type parameters, such as =class
List[+A]=, is that =List[A]= is a subtype of =List[Any]= and it is
easy to accidentally lose type information.

#+BEGIN_SRC scala
scala> List("hello") ++ List(' ') ++ List("world!")
res: List[Any] = List(hello,  , world!)
#+END_SRC

Note that the second list is a =List[Char]= and the compiler has
unhelpfully inferred the /Least Upper Bound/ (LUB) to be =Any=.
Compare to =IList=, which requires explicit =.widen[Any]= to permit
the heinous crime:

#+BEGIN_SRC scala
scala> IList("hello") ++ IList(' ') ++ IList("world!")
<console>:35: error: type mismatch;
 found   : Char(' ')
 required: String

scala> IList("hello").widen[Any]
         ++ IList(' ').widen[Any]
         ++ IList("world!").widen[Any]
res: IList[Any] = [hello, ,world!]
#+END_SRC

Similarly, when the compiler infers a type =with Product with
Serializable= it is a strong indicator that accidental widening has
occurred due to covariance.

Unfortunately we must be careful when constructing invariant data
types because LUB calculations are performed on the parameters:

#+BEGIN_SRC scala
scala> IList("hello", ' ', "world")
res: IList[Any] = [hello, ,world]
#+END_SRC

Another similar problem arises from Scala's =Nothing= type, which is a subtype
of all other types, including =sealed= ADTs, =final= classes, primitives and
=null=.

There are no values of type =Nothing=: functions that take a =Nothing= as a
parameter cannot be run and functions that return =Nothing= will never return.
=Nothing= was introduced as a mechanism to enable covariant type parameters, but
a consequence is that we can write un-runnable code, by accident. Scalaz says we
do not need covariant type parameters which means that we are limiting ourselves
to writing practical code that can be run.

**** Contrarivariance

On the other hand, /contravariant/ type parameters, such as =trait
Thing[-A]=, can expose devastating [[https://issues.scala-lang.org/browse/SI-2509][bugs in the compiler]]. Consider Paul
Phillips' (ex-=scalac= team) demonstration of what he calls
/contrarivariance/:

#+BEGIN_SRC scala
scala> :paste
       trait Thing[-A]
       def f(x: Thing[ Seq[Int]]): Byte   = 1
       def f(x: Thing[List[Int]]): Short  = 2

scala> f(new Thing[ Seq[Int]] { })
       f(new Thing[List[Int]] { })

res = 1
res = 2
#+END_SRC

As expected, the compiler is finding the most specific argument in
each call to =f=. However, implicit resolution gives unexpected
results:

#+BEGIN_SRC scala
scala> :paste
       implicit val t1: Thing[ Seq[Int]] =
         new Thing[ Seq[Int]] { override def toString = "1" }
       implicit val t2: Thing[List[Int]] =
         new Thing[List[Int]] { override def toString = "2" }

scala> implicitly[Thing[ Seq[Int]]]
       implicitly[Thing[List[Int]]]

res = 1
res = 1
#+END_SRC

Implicit resolution flips its definition of "most specific" for
contravariant types, rendering them useless for typeclasses or
anything that requires polymorphic functionality.

**** Limitations of subtyping

=scala.Option= has a method =.flatten= which will convert
=Option[Option[B]]= into an =Option[B]=. However, Scala's type system
is unable to let us write the required type signature. Consider the
following that appears correct, but has a subtle bug:

#+BEGIN_SRC scala
sealed abstract class Option[+A] {
  def flatten[B, A <: Option[B]]: Option[B] = ...
}
#+END_SRC

The =A= introduced on =.flatten= is shadowing the =A= introduced on
the class. It is equivalent to writing

#+BEGIN_SRC scala
sealed abstract class Option[+A] {
  def flatten[B, C <: Option[B]]: Option[B] = ...
}
#+END_SRC

which is not the constraint we want.

To workaround this limitation, Scala defines infix classes =<:<= and
~=:=~ along with implicit evidence that always creates a /witness/

#+BEGIN_SRC scala
sealed abstract class <:<[-From, +To] extends (From => To)
implicit def conforms[A]: A <:< A = new <:<[A, A] { def apply(x: A): A = x }

sealed abstract class =:=[ From,  To] extends (From => To)
implicit def tpEquals[A]: A =:= A = new =:=[A, A] { def apply(x: A): A = x }
#+END_SRC

~=:=~ can be used to require that two type parameters are exactly the
same and =<:<= is used to describe subtype relationships, letting us
implement =.flatten= as

#+BEGIN_SRC scala
sealed abstract class Option[+A] {
  def flatten[B](implicit ev: A <:< Option[B]): Option[B] = this match {
    case None        => None
    case Some(value) => ev(value)
  }
}
final case class Some[+A](value: A) extends Option[A] 
case object None                    extends Option[Nothing]
#+END_SRC

Scalaz improves on =<:<= and ~=:=~ with /Liskov/ (aliased to =<~<=)
and /Leibniz/ (~===~).

#+BEGIN_SRC scala
sealed abstract class Liskov[-A, +B] {
  def apply(a: A): B = ...
  def subst[F[-_]](p: F[B]): F[A]

  def andThen[C](that: Liskov[B, C]): Liskov[A, C] = ...
  def onF[X](fa: X => A): X => B = ...
  ...
}
object Liskov {
  type <~<[-A, +B] = Liskov[A, B]
  type >~>[+B, -A] = Liskov[A, B]

  implicit def refl[A]: (A <~< A) = ...
  implicit def isa[A, B >: A]: A <~< B = ...

  implicit def witness[A, B](lt: A <~< B): A => B = ...
  ...
}

// type signatures have been simplified
sealed abstract class Leibniz[A, B] {
  def apply(a: A): B = ...
  def subst[F[_]](p: F[A]): F[B]

  def flip: Leibniz[B, A] = ...
  def andThen[C](that: Leibniz[B, C]): Leibniz[A, C] = ...
  def onF[X](fa: X => A): X => B = ...
  ...
}
object Leibniz {
  type ===[A, B] = Leibniz[A, B]

  implicit def refl[A]: Leibniz[A, A] = ...

  implicit def subst[A, B](a: A)(implicit f: A === B): B = ...
  implicit def witness[A, B](f: A === B): A => B = ...
  ...
}
#+END_SRC

Other than generally useful methods and implicit conversions, the
scalaz =<~<= and ~===~ evidence is more principled than in the stdlib.

#+BEGIN_ASIDE
Liskov is named after Barbara Liskov of /Liskov substitution
principle/ fame, the foundation of Object Oriented Programming.

Gottfried Wilhelm Leibniz basically invented /everything/ in the 17th
century. He believed in a [[https://en.wikipedia.org/wiki/Monad_(philosophy)][God called Monad]]. Eugenio Moggi later reused
the name for what we know as =scalaz.Monad=. Not a God, just a mere
mortal like you and me.
#+END_ASIDE

*** Evaluation

Java is a /strict/ evaluation language: all the parameters to a method
must be evaluated to a /value/ before the method is called. Scala
introduces the notion of /by-name/ parameters on methods with ~a: =>A~
syntax. These parameters are wrapped up as a zero argument function
which is called every time the =a= is referenced. We seen /by-name/ a
lot in the typeclasses.

Scala also has /by-need/ evaluation of values, with the =lazy=
keyword: the computation is evaluated at most once to produce the
value. Unfortunately, scala does not support /by-need/ evaluation of
method parameters.

#+BEGIN_ASIDE
If the calculation of a =lazy val= throws an exception, it is retried
every time it is accessed. Because exceptions can break referential
transparency, we limit our discussion to =lazy val= calculations that
do not throw exceptions.
#+END_ASIDE

Scalaz formalises the three evaluation strategies with an ADT

#+BEGIN_SRC scala
sealed abstract class Name[A] {
  def value: A
}
object Name {
  def apply[A](a: =>A) = new Name[A] { def value = a }
  ...
}

sealed abstract class Need[A] extends Name[A]
object Need {
  def apply[A](a: =>A): Need[A] = new Need[A] {
    private lazy val value0: A = a
    def value = value0
  }
  ...
}

final case class Value[A](value: A) extends Need[A]
#+END_SRC

The weakest form of evaluation is =Name=, giving no computational
guarantees. Next is =Need=, guaranteeing /at most once/ evaluation,
whereas =Value= is pre-computed and therefore /exactly once/
evaluation.

If we wanted to be super-pedantic we could go back to all the
typeclasses and make their methods take =Name=, =Need= or =Value=
parameters. Instead we can assume that normal parameters can always be
wrapped in a =Value=, and /by-name/ parameters can be wrapped with
=Name=.

When we write /pure programs/, we are free to replace any =Name= with
=Need= or =Value=, and vice versa, with no change to the correctness
of the program. This is the essence of /referential transparency/: the
ability to replace a computation by its value, or a value by its
computation.

In functional programming we almost always want =Value= or =Need=
(also known as /strict/ and /lazy/): there is little value in =Name=.
Because there is no language level support for lazy method parameters,
methods typically ask for a /by-name/ parameter and then convert it
into a =Need= internally, getting a boost to performance.

#+BEGIN_ASIDE
=Lazy= (with a capital =L=) is often used in core Scala libraries for
data types with /by-name/ semantics: a misnomer that has stuck.

More generally, we're all pretty lazy about how we talk about laziness: it can
be good to seek clarification about what kind of laziness is being discussed. Or
don't. Because, lazy.
#+END_ASIDE

=Name= provides instances of the following typeclasses

- =Monad=
- =Comonad=
- =Distributive=
- =Traverse1=
- =Align=
- =Zip= / =Unzip= / =Cozip=

#+BEGIN_ASIDE
/by-name/ and /lazy/ are not the free lunch they appear to be. When
Scala converts /by-name/ parameters and =lazy val= into bytecode,
there is an object allocation overhead.

Before rewriting everything to use /by-name/ parameters, ensure that
the cost of the overhead does not eclipse the saving. There is no
benefit unless there is the possibility of *not* evaluating. High
performance code that runs in a tight loop and always evaluates will
suffer.
#+END_ASIDE

*** Memoisation

Scalaz has the capability to memoise functions, formalised by =Memo=,
which doesn't make any guarantees about evaluation because of the
diversity of implementations:

#+BEGIN_SRC scala
sealed abstract class Memo[K, V] {
  def apply(z: K => V): K => V
}
object Memo {
  def memo[K, V](f: (K => V) => K => V): Memo[K, V]

  def nilMemo[K, V]: Memo[K, V] = memo[K, V](identity)

  def arrayMemo[V >: Null : ClassTag](n: Int): Memo[Int, V] = ...
  def doubleArrayMemo(n: Int, sentinel: Double = 0.0): Memo[Int, Double] = ...

  def immutableHashMapMemo[K, V]: Memo[K, V] = ...
  def immutableTreeMapMemo[K: scala.Ordering, V]: Memo[K, V] = ...
}
#+END_SRC

=memo= allows us to create custom implementations of =Memo=, =nilMemo=
doesn't memoise, evaluating the function normally. The remaining
implementations intercept calls to the function and cache results
backed by stdlib collection implementations.

To use =Memo= we simply wrap a function with a =Memo= implementation
and then call the memoised function:

#+BEGIN_SRC scala
scala> def foo(n: Int): String = {
         println("running")
         if (n > 10) "wibble" else "wobble"
       }

scala> val mem = Memo.arrayMemo[String](100)
       val mfoo = mem(foo)

scala> mfoo(1)
running // evaluated
res: String = wobble

scala> mfoo(1)
res: String = wobble // memoised
#+END_SRC

If the function takes more than one parameter, we must =tupled= the
method, with the memoised version taking a tuple.

#+BEGIN_SRC scala
scala> def bar(n: Int, m: Int): String = "hello"
       val mem = Memo.immutableHashMapMemo[(Int, Int), String]
       val mbar = mem((bar _).tupled)

scala> mbar((1, 2))
res: String = "hello"
#+END_SRC

=Memo= is typically treated as a special construct and the usual rule
about /purity/ is relaxed for implementations. To be pure only
requires that our implementations of =Memo= are referential
transparent in the evaluation of ~K => V~. We may use mutable data and
perform I/O in the implementation of ~Memo~, e.g. with an LRU or
distributed cache, without having to declare an effect in the type
signature. Other functional programming languages have automatic
memoisation managed by their runtime environment and ~Memo~ is our way
of extending the JVM to have similar support, unfortunately only on an
opt-in basis.

*** Tagging

In the section introducing =Monoid= we built a =Monoid[TradeTemplate]= and
realised that scalaz does not do what we wanted with =Monoid[Option[A]]=. This
is not an oversight of scalaz: often we find that a data type can implement a
fundamental typeclass in multiple valid ways and that the default implementation
doesn't do what we want, or simply isn't defined.

Basic examples are =Monoid[Boolean]= (conjunction ~&&~ vs disjunction ~||~) and
=Monoid[Int]= (multiplication vs addition).

To implement =Monoid[TradeTemplate]= we found ourselves either breaking
typeclass coherency, or using a different typeclass.

=scalaz.Tag= is designed to address the multiple typeclass implementation
problem without breaking typeclass coherency.

The definition is quite contorted, but the syntax to use it is very clean. This
is how we trick the compiler into allowing us to define an infix type =A @@ T=
that is erased to =A= at runtime:

#+BEGIN_SRC scala
type @@[A, T] = Tag.k.@@[A, T]

object Tag {
  @inline val k: TagKind = IdTagKind
  @inline def apply[A, T](a: A): A @@ T = k(a)
  ...

  final class TagOf[T] private[Tag]() { ... }
  def of[T]: TagOf[T] = new TagOf[T]
}
sealed abstract class TagKind {
  type @@[A, T]
  def apply[A, T](a: A): A @@ T
  ...
}
private[scalaz] object IdTagKind extends TagKind {
  type @@[A, T] = A
  @inline override def apply[A, T](a: A): A = a
  ...
}
#+END_SRC

#+BEGIN_ASIDE
i.e. we tag things with Princess Leia hair buns ~@@~.
#+END_ASIDE

Some useful tags are provided in the =Tags= object

#+BEGIN_SRC scala
object Tags {
  sealed trait First
  val First = Tag.of[First]

  sealed trait Last
  val Last = Tag.of[Last]

  sealed trait Multiplication
  val Multiplication = Tag.of[Multiplication]

  sealed trait Disjunction
  val Disjunction = Tag.of[Disjunction]

  sealed trait Conjunction
  val Conjunction = Tag.of[Conjunction]

  ...
}
#+END_SRC

=First= / =Last= are used to select =Monoid= instances that pick the first or
last non-zero operand. =Multiplication= is for numeric multiplication instead of
addition. =Disjunction= / =Conjunction= are to select =&&= or =||=,
respectively.

In our =TradeTemplate=, instead of using =Option[Currency]= we can use
=Option[Currency] @@ Tags.Last=. Indeed this is so common that we can use the
built-in alias, =LastOption=

#+BEGIN_SRC scala
type LastOption[A] = Option[A] @@ Tags.Last
#+END_SRC

letting us write a much cleaner =Monoid[TradeTemplate]=

#+BEGIN_SRC scala
final case class TradeTemplate(
  payments: List[java.time.LocalDate],
  ccy: LastOption[Currency],
  otc: LastOption[Boolean]
)
object TradeTemplate {
  implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
    (a, b) =>
      TradeTemplate(a.payments |+| b.payments,
                    a.ccy |+| b.ccy,
                    a.otc |+| b.otc),
      TradeTemplate(Nil, Tag(None), Tag(None))
  )
}
#+END_SRC

To create a raw value of type =LastOption=, we apply =Tag= to an =Option=. Here
we are calling =Tag(None)=.

In the chapter on typeclass derivation, we'll go one step further and
automatically derive the =monoid=.

It is tempting to use =Tag= to markup data types for some form of validation
(e.g. =String @@ PersonName=), but this should be avoided because there are no
checks on the content of the runtime value. =Tag= should only be used for
typeclass selection purposes, and we will dedicate a chapter on /type
refinement/ which is how we can mark up types with arbitrary value-level
constraints.

*** Natural Transformations

A function from one type to another is written as ~A => B~ in scala, which is
syntax sugar for a ~Function1[A, B]~. Scalaz provides similar syntax sugar =F ~>
G= for functions over type constructors =F[_]= to =G[_]=.

These =F ~> G= are called /natural transformations/ and are /universally
quantified/ because they don't care about the contents of =F[_]=.

#+BEGIN_SRC scala
type ~>[-F[_], +G[_]] = NaturalTransformation[F, G]
trait NaturalTransformation[-F[_], +G[_]] {
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~> F): E ~> G = ...
  def andThen[H[_]](f: G ~> H): F ~> H = ...
}
#+END_SRC

An example of a natural transformation is a function that converts an =IList=
into a =List=

#+BEGIN_SRC scala
scala> val convert = new (IList ~> List) {
         def apply[A](fa: IList[A]): List[A] = fa.toList
       }

scala> convert(IList(1, 2, 3))
res: List[Int] = List(1, 2, 3)
#+END_SRC

Or, more concisely, making use of =kind-projector='s syntax sugar:

#+BEGIN_SRC scala
scala> val convert = λ[IList ~> List](_.toList)

scala> val convert = Lambda[IList ~> List](_.toList)
#+END_SRC

However, in day-to-day development, it is far more likely that we will use a
natural transformation to map between algebras. For example, in
=drone-dynamic-agents= we may want to implement our Google Container Engine
=Machines= algebra with an off-the-shelf algebra, =BigMachines=. Instead of
changing all our business logic and tests to use this new =BigMachines=
interface, we may be able to write a transformation from =Machines ~>
BigMachines=. We will return to this idea in the chapter on Advanced Monads.

There is also a natural transformation for type constructors with two type
holes:

#+BEGIN_SRC scala
type ~~>[-F[_,_], +G[_,_]] = BiNaturalTransformation[F, G]
trait BiNaturalTransformation[-F[_, _], +G[_, _]] {
  def apply[A, B](f: F[A, B]): G[A, B]
  def compose[E[_, _]](f: E ~~> F) = ...
}
#+END_SRC

*** =Isomorphism=

Sometimes we have two types that are really the same thing, causing
compatibility problems because the compiler doesn't know what we know. This
typically happens when we use third party code that is the same as something we
already have.

This is when =Isomorphism= can help us out. An isomorphism defines a formal "is
equivalent to" relationship between two types. There are three variants, to
account for types of different shapes:

#+BEGIN_SRC scala
object Isomorphism {
  trait Iso[Arr[_, _], A, B] {
    def to: Arr[A, B]
    def from: Arr[B, A]
  }
  type IsoSet[A, B] = Iso[Function1, A, B]
  type <=>[A, B] = IsoSet[A, B]
  object IsoSet {
    def apply[A, B](to: A => B, from: B => A): A <=> B = ...
  }

  trait Iso2[Arr[_[_], _[_]], F[_], G[_]] {
    def to: Arr[F, G]
    def from: Arr[G, F]
  }
  type IsoFunctor[F[_], G[_]] = Iso2[NaturalTransformation, F, G]
  type <~>[F[_], G[_]] = IsoFunctor[F, G]
  object IsoFunctor {
    def apply[F[_], G[_]](to: F ~> G, from: G ~> F): F <~> G = ...
  }

  trait Iso3[Arr[_[_, _], _[_, _]], F[_, _], G[_, _]] {
    def to: Arr[F, G]
    def from: Arr[G, F]
  }
  type IsoBifunctor[F[_, _], G[_, _]] = Iso3[~~>, F, G]
  type <~~>[F[_, _], G[_, _]] = IsoBifunctor[F, G]

  ...
}
#+END_SRC

The type aliases =IsoSet=, =IsoFunctor= and =IsoBifunctor= cover the common
cases: a regular function, natural transformation and binatural. Convenience
functions allow us to generate instances from existing functions or natural
transformations. However, it is often easier to use one of the abstract
=Template= classes to define an isomorphism. For example:

#+BEGIN_SRC scala
  val listIListIso: List <~> IList =
    new IsoFunctorTemplate[List, IList] {
      def to[A](fa: List[A]) = fromList(fa)
      def from[A](fa: IList[A]) = fa.toList
    }
#+END_SRC

If we introduce an isomorphism, we can generate many of the standard
typeclasses. For example

#+BEGIN_SRC scala
trait IsomorphismSemigroup[F, G] extends Semigroup[F] {
  implicit def G: Semigroup[G]
  def iso: F <=> G
  def append(f1: F, f2: => F): F = iso.from(G.append(iso.to(f1), iso.to(f2)))
}
#+END_SRC

allows us to derive a =Semigroup[F]= for a type =F= if we have an ~F <=> G~ and
a =Semigroup[G]=. Almost all the typeclasses in the hierarchy provide an
isomorphic variant. If we find ourselves copying and pasting a typeclass
implementation, it is worth considering if =Isomorphism= is the better solution.

# these should be easier to use!
# https://github.com/scalaz/scalaz/issues/1662

*** Containers

**** Maybe

We have already encountered scalaz's improvement over =scala.Option=,
called =Maybe=. It is an improvement because it does not have any
unsafe methods like =Option.get=, which can throw an exception, and is
invariant.

It is typically used to represent when a thing may be
present or not without giving any extra context as to why it may be
missing.

#+BEGIN_SRC scala
sealed abstract class Maybe[A] { ... }
object Maybe {
  final case class Empty[A]()    extends Maybe[A]
  final case class Just[A](a: A) extends Maybe[A]

  def empty[A]: Maybe[A] = Empty()
  def just[A](a: A): Maybe[A] = Just(a)

  def fromOption[A](oa: Option[A]): Maybe[A] = ...
  def fromNullable[A](a: A): Maybe[A] = if (null == a) empty else just(a)
  ...
}
#+END_SRC

The =.empty= and =.just= companion methods are preferred to creating
raw =Empty= or =Just= instances because they return a =Maybe=, helping
with type inference. This pattern is often referred to as returning a
/sum type/, which is when we have multiple implementations of a
=sealed trait= but never use a specific subtype in a method signature.

A convenient =implicit class= allows us to call =.just= on any value
and receive a =Maybe=

#+BEGIN_SRC scala
implicit class MaybeOps[A](self: A) {
  def just: Maybe[A] = Maybe.just(self)
}
#+END_SRC

=Maybe= has a typeclass instance for all the things

- =Align=
- =Traverse=
- =MonadPlus= / =IsEmpty=
- =Cobind=
- =Cozip= / =Zip= / =Unzip=
- =Optional=

and delegate instances depending on =A=

- =Monoid= / =Band= / =SemiLattice=
- =Equal= / =Order= / =Show=

In addition to the above, =Maybe= has some niche functionality that is
not supported by a polymorphic typeclass.

#+BEGIN_SRC scala
sealed abstract class Maybe[A] {
  def cata[B](f: A => B, b: =>B): B = this match {
    case Just(a) => f(a)
    case Empty() => b
  }

  def |(a: =>A): A = cata(identity, a)
  def toLeft[B](b: =>B): A \/ B = cata(\/.left, \/-(b))
  def toRight[B](b: =>B): B \/ A = cata(\/.right, -\/(b))
  def <\/[B](b: =>B): A \/ B = toLeft(b)
  def \/>[B](b: =>B): B \/ A = toRight(b)

  def orZero(implicit A: Monoid[A]): A = getOrElse(A.zero)
  def unary_~(implicit A: Monoid[A]): A = orZero

  def orEmpty[F[_]: Applicative: PlusEmpty]: F[A] =
    cata(Applicative[F].point(_), PlusEmpty[F].empty)
  ...
}
#+END_SRC

=.cata= is a terser alternative to =.map(f).getOrElse(b)= and has the
simpler form =|= if the map is =identity= (i.e. just =.getOrElse=).

=.toLeft= and =.toRight=, and their symbolic aliases, create a disjunction
(explained in the next section) by taking a fallback for the =Empty= case.

=.orZero= (having =~foo= syntax) takes a =Monoid= to define the
default value.

=.orEmpty= uses an =ApplicativePlus= to create a single element or
empty container, not forgetting that we already get support for stdlib
collections from the =Foldable= instance's =.to= method.

#+BEGIN_SRC scala
scala> ~1.just
res: Int = 1

scala> Maybe.empty[Int].orZero
res: Int = 0

scala> Maybe.empty[Int].orEmpty[IList]
res: IList[Int] = []

scala> 1.just.orEmpty[IList]
res: IList[Int] = [1]

scala> 1.just.to[List] // from Foldable
res: List[Int] = List(1)
#+END_SRC

#+BEGIN_ASIDE
Methods are defined in OOP style on =Maybe=, contrary to our Chapter 4
lesson to use an =object= or =implicit class=. This is a common theme
in scalaz and the reason is largely historical:

- text editors failed to find extension methods, but this now works
  seamlessly in IntelliJ, ENSIME and ScalaIDE.
- there are corner cases where the compiler would fail to infer the
  types and not be able to find the extension method.
- the stdlib defines some =implicit class= instances that add methods
  to all values, with conflicting method names. =+= is the most
  prominent example, turning everything into a concatenated =String=.

The same is true for functionality that is provided by typeclass
instances, such as these methods which are otherwise provided by
=Optional=

#+BEGIN_SRC scala
sealed abstract class Maybe[A] {
  def getOrElse(a: =>A): A = ...
  ...
}
#+END_SRC

However, recent versions of Scala have addressed many bugs and we are
now less likely to encounter problems.
#+END_ASIDE

**** Either

Scalaz's improvement over =scala.Either= is symbolic, but it is common
to speak about it as /either/ or =Disjunction=

#+BEGIN_SRC scala
sealed abstract class \/[+A, +B] { ... }
final case class -\/[+A](a: A) extends (A \/ Nothing)
final case class \/-[+B](b: B) extends (Nothing \/ B)

type Disjunction[+A, +B] = \/[A, B]
type DLeft[+A] = -\/[A]
type DRight[+B] = \/-[B]

object \/ {
  def left [A, B]: A => A \/ B = -\/(_)
  def right[A, B]: B => A \/ B = \/-(_)

  def fromEither[A, B](e: Either[A, B]): A \/ B = ...
  ...
}
#+END_SRC

with corresponding syntax

#+BEGIN_SRC scala
implicit class EitherOps[A](val self: A) {
  final def left [B]: (A \/ B) = -\/(self)
  final def right[B]: (B \/ A) = \/-(self)
}
#+END_SRC

allowing for easy construction of values. Note that the extension
method takes the type of the /other side/. So if we wish to create a
=String \/ Int= and we have an =Int=, we must pass =String= when
calling =.right=

#+BEGIN_SRC scala
scala> 1.right[String]
res: String \/ Int = \/-(1)

scala> "hello".left[Int]
res: String \/ Int = -\/(hello)
#+END_SRC

The symbolic nature of =\/= makes it read well in type signatures when
shown infix. Note that symbolic types in Scala associate from the left
and nested =\/= must have parentheses, e.g. =(A \/ (B \/ (C \/ D))=.

=\/= has right-biased (i.e. =flatMap= applies to =\/-=) typeclass
instances for:

- =Monad= / =MonadError=
- =Traverse= / =Bitraverse=
- =Plus=
- =Optional=
- =Cozip=

and depending on the contents

- =Equal= / =Order=
- =Semigroup= / =Monoid= / =Band=

In addition, there are custom methods

#+BEGIN_SRC scala
sealed abstract class \/[+A, +B] { self =>
  def fold[X](l: A => X, r: B => X): X = self match {
    case -\/(a) => l(a)
    case \/-(b) => r(b)
  }

  def swap: (B \/ A) = self match {
    case -\/(a) => \/-(a)
    case \/-(b) => -\/(b)
  }
  def unary_~ : (B \/ A) = swap

  def |[BB >: B](x: =>BB): BB = getOrElse(x) // Optional[_]
  def |||[C, BB >: B](x: =>C \/ BB): C \/ BB = orElse(x) // Optional[_]

  def +++[AA >: A: Semigroup, BB >: B: Semigroup](x: =>AA \/ BB): AA \/ BB = ...

  def toEither: Either[A, B] = ...

  final class SwitchingDisjunction[X](right: =>X) {
    def <<?:(left: =>X): X = ...
  }
  def :?>>[X](right: =>X) = new SwitchingDisjunction[X](right)
  ...
}
#+END_SRC

=.fold= is similar to =Maybe.cata= and requires that both the left and
right sides are mapped to the same type.

=.swap= (and the =~foo= syntax) swaps a left into a right and a right
into a left.

The =|= alias to =getOrElse= appears similarly to =Maybe=. We also get
=|||= as an alias to =orElse=.

=+++= is for combining disjunctions with lefts taking preference over
right:

- =right(v1) +++ right(v2)= gives =right(v1 |+| v2)=
- =right(v1) +++ left (v2)= gives =left (v2)=
- =left (v1) +++ right(v2)= gives =left (v1)=
- =left (v1) +++ left (v2)= gives =left (v1 |+| v2)=

=.toEither= is provided for backwards compatibility with the Scala
stdlib.

The combination of =:?>>= and =<<?:= allow for a convenient syntax to
ignore the contents of an =\/=, but pick a default based on its type

#+BEGIN_SRC scala
scala> 1 <<?: foo :?>> 2
res: Int = 2 // foo is a \/-

scala> 1 <<?: ~foo :?>> 2
res: Int = 1
#+END_SRC

Scalaz also comes with =Either3=, for storing one of three values

#+BEGIN_SRC scala
sealed abstract class Either3[+A, +B, +C]
final case class Left3[+A, +B, +C](a: A)   extends Either3[A, B, C]
final case class Middle3[+A, +B, +C](b: B) extends Either3[A, B, C]
final case class Right3[+A, +B, +C](c: C)  extends Either3[A, B, C]
#+END_SRC

However, it is common to use nested disjunctions =A \/ (B \/ C)=, making
=Either3= redundant.

**** Validation

At first sight, =Validation= (aliased with =\?/=, /happy Elvis/)
appears to be a clone of =Disjunction=:

#+BEGIN_SRC scala
sealed abstract class Validation[+E, +A] { ... }
final case class Success[A](a: A) extends Validation[Nothing, A]
final case class Failure[E](e: E) extends Validation[E, Nothing]

type ValidationNel[E, +X] = Validation[NonEmptyList[E], X]

object Validation {
  type \?/[+E, +A] = Validation[E, A]

  def success[E, A]: A => Validation[E, A] = Success(_)
  def failure[E, A]: E => Validation[E, A] = Failure(_)
  def failureNel[E, A](e: E): ValidationNel[E, A] = Failure(NonEmptyList(e))

  def lift[E, A](a: A)(f: A => Boolean, fail: E): Validation[E, A] = ...
  def liftNel[E, A](a: A)(f: A => Boolean, fail: E): ValidationNel[E, A] = ...
  def fromEither[E, A](e: Either[E, A]): Validation[E, A] = ...
  ...
}
#+END_SRC

With convenient syntax

#+BEGIN_SRC scala
implicit class ValidationOps[A](self: A) {
  def success[X]: Validation[X, A] = Validation.success[X, A](self)
  def successNel[X]: ValidationNel[X, A] = success
  def failure[X]: Validation[A, X] = Validation.failure[A, X](self)
  def failureNel[X]: ValidationNel[A, X] = Validation.failureNel[A, X](self)
}
#+END_SRC

However, the data structure itself is not the complete story.
=Validation= intentionally does not have an instance of any =Monad=,
restricting itself to success-biased versions of:

- =Applicative=
- =Traverse= / =Bitraverse=
- =Cozip=
- =Plus=
- =Optional=

and depending on the contents

- =Equal= / =Order=
- =Show=
- =Semigroup= / =Monoid=

The big advantage of restricting to =Applicative= is that =Validation=
is explicitly for situations where we wish to report all failures,
whereas =Disjunction= is used to stop at the first failure. To
accommodate failure accumulation, a popular form of =Validation= is
=ValidationNel=, having a =NonEmptyList[E]= in the failure position.

Consider performing input validation of data provided by a user using
=Disjunction= and =flatMap=:

#+BEGIN_SRC scala
scala> :paste
       final case class Credentials(user: Username, name: Fullname)
       final case class Username(value: String) extends AnyVal
       final case class Fullname(value: String) extends AnyVal

       def username(in: String): String \/ Username =
         if (in.isEmpty) "empty username".left
         else if (in.contains(" ")) "username contains spaces".left
         else Username(in).right

       def realname(in: String): String \/ Fullname =
         if (in.isEmpty) "empty real name".left
         else Fullname(in).right

scala> for {
         u <- username("sam halliday")
         r <- realname("")
       } yield Credentials(u, r)
res = -\/(username contains spaces)
#+END_SRC

If we use ~|@|~ syntax

#+BEGIN_SRC scala
scala> (username("sam halliday") |@| realname("")) (Credentials.apply)
res = -\/(username contains spaces)
#+END_SRC

we still get back the first failure. This is because =Disjunction= is
a =Monad=, its =.applyX= methods must be consistent with =.flatMap=
and not assume that any operations can be performed out of order.
Compare to:

#+BEGIN_SRC scala
scala> :paste
       def username(in: String): ValidationNel[String, Username] =
         if (in.isEmpty) "empty username".failureNel
         else if (in.contains(" ")) "username contains spaces".failureNel
         else Username(in).success

       def realname(in: String): ValidationNel[String, Fullname] =
         if (in.isEmpty) "empty real name".failureNel
         else Fullname(in).success

scala> (username("sam halliday") |@| realname("")) (Credentials.apply)
res = Failure(NonEmpty[username contains spaces,empty real name])
#+END_SRC

This time, we get back all the failures!

=Validation= has many of the same methods as =Disjunction=, such as
=.fold=, =.swap= and =+++=, plus some extra:

#+BEGIN_SRC scala
sealed abstract class Validation[+E, +A] {
  def append[F >: E: Semigroup, B >: A: Semigroup](x: F \?/ B]): F \?/ B = ...

  def disjunction: (E \/ A) = ...
  ...
}
#+END_SRC

=.append= (aliased by =+|+=) has the same type signature as =+++= but
prefers the =success= case

- =failure(v1) +|+ failure(v2)= gives =failure(v1 |+| v2)=
- =failure(v1) +|+ success(v2)= gives =success(v2)=
- =success(v1) +|+ failure(v2)= gives =success(v1)=
- =success(v1) +|+ success(v2)= gives =success(v1 |+| v2)=

#+BEGIN_ASIDE
=+|+= the surprised c3p0 operator.
#+END_ASIDE

=.disjunction= converts a =Validated[A, B]= into an =A \/ B=.
Disjunction has the mirror =.validation= and =.validationNel= to
convert into =Validation=, allowing for easy conversion between
sequential and parallel failure accumulation.

=\/= and =Validation= are the more performant FP equivalent of a checked
exception for input validation, avoiding both a stacktrace and requiring the
caller to deal with the failure resulting in more robust systems.

#+BEGIN_ASIDE
One of the slowest things on the JVM is to create an exception, due to the
resources required to construct the stacktrace. It is traditional to use
exceptions for input validation and parsing, which can be thousands of times
slower than the equivalent functions written with =\/= or =Validation=.

Some people claim that predictable exceptions for input validation are
referentially transparent because they will occur every time. However, the
stacktrace inside the exception depends on the call chain, giving a different
value depending on who calls it, thus breaking referential transparency.
Regardless, throwing an exception is not pure because it means the function is
not /Total/.
#+END_ASIDE

**** These

We encountered =These=, a data encoding of inclusive logical =OR=,
when we learnt about =Align=. Let's take a closer look:

#+BEGIN_SRC scala
sealed abstract class \&/[+A, +B] { ... }
object \&/ {
  type These[A, B] = A \&/ B

  final case class This[A](aa: A) extends (A \&/ Nothing)
  final case class That[B](bb: B) extends (Nothing \&/ B)
  final case class Both[A, B](aa: A, bb: B) extends (A \&/ B)

  def apply[A, B](a: A, b: B): These[A, B] = Both(a, b)
}
#+END_SRC

with convenient construction syntax

#+BEGIN_SRC scala
implicit class TheseOps[A](self: A) {
  final def wrapThis[B]: A \&/ B = \&/.This(self)
  final def `this`[B]: A \&/ B = wrapThis
  final def wrapThat[B]: B \&/ A = \&/.That(self)
  final def that[B]: B \&/ A = wrapThat
}
implicit class ThesePairOps[A, B](self: (A, B)) {
  final def both: A \&/ B = \&/.Both(self._1, self._2)
}
#+END_SRC

Annoyingly, =this= is a keyword in Scala and must be called with
back-ticks, or as =.wrapThis=.

=These= has typeclass instances for

- =Monad=
- =Bitraverse=
- =Traverse=
- =Cobind=

and depending on contents

- =Semigroup= / =Monoid= / =Band=
- =Equal= / =Order=
- =Show=

=These= (=\&/=) has many of the methods we have come to expect of
=Disjunction= (=\/=) and =Validation= (=\?/=)

#+BEGIN_SRC scala
sealed abstract class \&/[+A, +B] {
  def fold[X](s: A => X, t: B => X, q: (A, B) => X): X = ...
  def swap: (B \&/ A) = ...
  def unary_~ : (B \&/ A) = swap

  def append[X >: A: Semigroup, Y >: B: Semigroup](o: =>(X \&/ Y)): X \&/ Y = ...

  def &&&[X >: A: Semigroup, C](t: X \&/ C): X \&/ (B, C) = ...
  ...
}
#+END_SRC

=.append= has 9 possible arrangements and data is never thrown away
because cases of =This= and =That= can always be converted into a
=Both=.

=.flatMap= is right-biased (=Both= and =That=), taking a =Semigroup=
of the left content (=This=) to combine rather than break early. =&&&=
is a convenient way of binding over two of /these/, creating a tuple
on the right and dropping data if it is not present in each of
/these/.

Although it is tempting to use =\&/= in return types, overuse is an
anti-pattern. The main reason to use =\&/= is to combine or split
potentially infinite /streams/ of data in finite memory. Convenient
functions exist on the companion to deal with =EphemeralStream=
(aliased here to fit in a single line) or anything with a =MonadPlus=

#+BEGIN_SRC scala
type EStream[A] = EphemeralStream[A]

object \&/ {
  def concatThisStream[A, B](x: EStream[A \&/ B]): EStream[A] = ...
  def concatThis[F[_]: MonadPlus, A, B](x: F[A \&/ B]): F[A] = ...

  def concatThatStream[A, B](x: EStream[A \&/ B]): EStream[B] = ...
  def concatThat[F[_]: MonadPlus, A, B](x: F[A \&/ B]): F[B] = ...

  def unalignStream[A, B](x: EStream[A \&/ B]): (EStream[A], EStream[B]) = ...
  def unalign[F[_]: MonadPlus, A, B](x: F[A \&/ B]): (F[A], F[B]) = ...

  def merge[A: Semigroup](t: A \&/ A): A = ...
  ...
}
#+END_SRC

**** Higher Kinded Either

The =Coproduct= data type (not to be confused with the more general concept of a
/coproduct/ in an ADT, or =shapeless.Coproduct=) wraps =Disjunction= for type
constructors:

#+BEGIN_SRC scala
final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) { ... }
object Coproduct {
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] = Coproduct(-\/(x))
  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] = Coproduct(\/-(x))
  ...
}
#+END_SRC

Typeclass instances simply delegate to those of the =F[_]= and =G[_]=.

The most popular use case for =Coproduct= is when we want to create an anonymous
coproduct for a GADT.

# https://github.com/scala/scala/pull/5538

**** Not So Eager

Built-in Scala tuples, and basic data types like =Maybe= and
=Disjunction= are eagerly-evaluated value types.

For convenience, /by-name/ alternatives to =Name= are provided, having
the expected typeclass instances:

#+BEGIN_SRC scala
sealed abstract class LazyTuple2[A, B] {
  def _1: A
  def _2: B
}
...
sealed abstract class LazyTuple4[A, B, C, D] {
  def _1: A
  def _2: B
  def _3: C
  def _4: D
}

sealed abstract class LazyOption[+A] { ... }
private final case class LazySome[A](a: () => A) extends LazyOption[A]
private case object LazyNone extends LazyOption[Nothing]

sealed abstract class LazyEither[+A, +B] { ... }
private case class LazyLeft[A, B](a: () => A) extends LazyEither[A, B]
private case class LazyRight[A, B](b: () => B) extends LazyEither[A, B]
#+END_SRC

The astute reader will note that =Lazy*= is a misnomer, and these data
types should perhaps be: =ByNameTupleX=, =ByNameOption= and
=ByNameEither=.

**** Const

=Const=, for /constant/, is a wrapper for a value of type =A=, along with a
spare type parameter =B=.

#+BEGIN_SRC scala
final case class Const[A, B](getConst: A)
#+END_SRC

=Const= provides an instance of =Applicative[Const[A, ?]]= if there is a
=Monoid[A]= available:

#+BEGIN_SRC scala
implicit def applicative[A: Monoid]: Applicative[Const[A, ?]] =
  new Applicative[Const[A, ?]] {
    def point[B](b: =>B): Const[A, B] =
      Const(Monoid[A].zero)
    def ap[B, C](fa: =>Const[A, B])(fbc: =>Const[A, B => C]): Const[A, C] =
      Const(fbc.getConst |+| fa.getConst)
  }
#+END_SRC

The most important thing about this =Applicative= is that it ignores the =B=
parameters, continuing on without failing and only combining the constant values
that it encounters.

Going back to our example application =drone-dynamic-agents=, we should first
refactor our =logic.scala= file to use =Applicative= instead of =Monad=. We
wrote =logic.scala= before we learnt about =Applicative= and now we know better:

#+BEGIN_SRC scala
final class DynAgents[F[_]: Applicative](D: Drone[F], M: Machines[F]) {
  ...
  def act(world: WorldView): F[WorldView] = world match {
    case NeedsAgent(node) =>
      M.start(node) >| world.copy(pending = Map(node -> world.time))

    case Stale(nodes) =>
      nodes.traverse { node =>
        M.stop(node) >| node
      }.map { stopped =>
        val updates = stopped.strengthR(world.time).toList.toMap
        world.copy(pending = world.pending ++ updates)
      }

    case _ => world.pure[F]
  }
  ...
}
#+END_SRC

Since our business logic only requires an =Applicative=, we can write mock
implementations with ~F[a]~ as ~Const[String, a]~. In each case, we return the
name of the function that is called:

#+BEGIN_SRC scala
object ConstImpl {
  type F[a] = Const[String, a]

  private val D = new Drone[F] {
    def getBacklog: F[Int] = Const("backlog")
    def getAgents: F[Int]  = Const("agents")
  }

  private val M = new Machines[F] {
    def getAlive: F[Map[MachineNode, Instant]]   = Const("alive")
    def getManaged: F[NonEmptyList[MachineNode]] = Const("managed")
    def getTime: F[Instant]                      = Const("time")
    def start(node: MachineNode): F[Unit]        = Const("start")
    def stop(node: MachineNode): F[Unit]         = Const("stop")
  }

  val program = new DynAgents[F](D, M)
}
#+END_SRC

With this interpretation of our program, we can assert on the methods that are
called:

#+BEGIN_SRC scala
  it should "call the expected methods" in {
    import ConstImpl._

    val alive    = Map(node1 -> time1, node2 -> time1)
    val world    = WorldView(1, 1, managed, alive, Map.empty, time4)

    program.act(world).getConst shouldBe "stopstop"
  }
#+END_SRC

Alternatively, we could have counted total method calls by using =Const[Int, ?]=
or an =IMap[String, Int]=.

With this test, we've gone beyond traditional /Mock/ testing with a =Const= test
that asserts on /what is called/ without having to provide implementations. This
is useful if our specification demands that we make certain calls for certain
input, e.g. for accounting purposes. Furthermore, we've achieved this with
compiletime safety.

Let's take this line of thinking a little further and say we want to monitor (in
production) the nodes that we are stopping in =act=. We can create
implementations of =Drone= and =Machines= with =Const=, calling it from our
wrapped version of =act=

#+BEGIN_SRC scala
final class Monitored[U[_]: Functor](program: DynAgents[U]) {
  type F[a] = Const[Set[MachineNode], a]
  private val D = new Drone[F] {
    def getBacklog: F[Int] = Const(Set.empty)
    def getAgents: F[Int]  = Const(Set.empty)
  }
  private val M = new Machines[F] {
    def getAlive: F[Map[MachineNode, Instant]]   = Const(Set.empty)
    def getManaged: F[NonEmptyList[MachineNode]] = Const(Set.empty)
    def getTime: F[Instant]                      = Const(Set.empty)
    def start(node: MachineNode): F[Unit]        = Const(Set.empty)
    def stop(node: MachineNode): F[Unit]         = Const(Set(node))
  }
  val monitor = new DynAgents[F](D, M)

  def act(world: WorldView): U[(WorldView, Set[MachineNode])] = {
    val stopped = monitor.act(world).getConst
    program.act(world).strengthR(stopped)
  }
}
#+END_SRC

We can do this because =monitor= is /pure/ and running it produces no side
effects.

This runs the program with =ConstImpl=, extracting all the calls to
=Machines.stop=, then returning it alongside the =WorldView=. We can unit test
this:

#+BEGIN_SRC scala
  it should "monitor stopped nodes" in {
    val underlying = new Mutable(needsAgents).program

    val alive = Map(node1 -> time1, node2 -> time1)
    val world = WorldView(1, 1, managed, alive, Map.empty, time4)
    val expected = world.copy(pending = Map(node1 -> time4, node2 -> time4))

    val monitored = new Monitored(underlying)
    monitored.act(world) shouldBe (expected -> Set(node1, node2))
  }
#+END_SRC

We have used =Const= to do something that looks like /Aspect Oriented
Programming/, once popular in Java. We built on top of our business logic to
support a monitoring concern, without having to complicate the business logic.

It gets even better. We can run =ConstImpl= in production to gather what we want
to =stop=, and then provide an *optimised* implementation of =act= that can make
use of implementation-specific batched calls.

The silent hero of this story is =Applicative=. =Const= lets us show off what is
possible. If we need to change our program to require a =Monad=, we can no
longer use =Const= and must write full mocks to be able to assert on what is
called under certain inputs. The /Rule of Least Power/ demands that we use
=Applicative= instead of =Monad= wherever we can.

*** Collections

Unlike the stdlib Collections API, the scalaz approach describes collection
behaviours in the typeclass hierarchy, e.g. =Foldable=, =Traverse=, =Monoid=.
What remains to be studied are the implementations in terms of data structures,
which have different performance characteristics and niche methods.

Because all the collection data types provide more or less the same list of
typeclass instances, we shall avoid repeating the list, which is often some variation of:

- =Monoid=
- =Traverse= / =Foldable=
- =MonadPlus= / =IsEmpty=
- =Cobind= / =Comonad=
- =Zip= / =Unzip=
- =Align=
- =Equal= / =Order=
- =Show=

Data structures that are provably non-empty are able to provide

- =Traverse1= / =Foldable1=

and provide =Semigroup= instead of =Monoid=, =Plus= instead of =IsEmpty=.

**** Lists

We have used =IList[A]= and =NonEmptyList[A]= so many times by now that they
should be familiar. They codify a classic linked list data structure:

#+BEGIN_SRC scala
sealed abstract class IList[A] {
  def ::(a: A): IList[A] = ...
  def :::(as: IList[A]): IList[A] = ...
  def toList: List[A] = ...
  def toNel: Option[NonEmptyList[A]] = ...
  ...
}
final case class INil[A]() extends IList[A]
final case class ICons[A](head: A, tail: IList[A]) extends IList[A]

final case class NonEmptyList[A](head: A, tail: IList[A]) {
  def <::(b: A): NonEmptyList[A] = nel(b, head :: tail)
  def <:::(bs: IList[A]): NonEmptyList[A] = ...
  ...
}
#+END_SRC

#+BEGIN_ASIDE
The source code for scalaz 7.3 reveals that =INil= is implemented as

#+BEGIN_SRC scala
sealed abstract case class INil[A] private() extends IList[A]
object INil {
  private[this] val value: INil[Nothing] = new INil[Nothing]{}
  def apply[A](): IList[A] = value.asInstanceOf[IList[A]]
}
#+END_SRC

which exploits JVM implementation details to avoid an object allocation when
creating an =INil=.

This optimisation is manually applied to all zero-parameter classes. Indeed,
scalaz is full of many optimisations of this nature: debated and accepted only
when presented with evidence of a significant performance boost and no risk of a
semantic change.
#+END_ASIDE

The main advantage of =IList= over stdlib =List= is that there are no
unsafe methods, like =.head= which throws an exception on an empty
list.

In addition, =IList= is a *lot* simpler, having no hierarchy and a
much smaller bytecode footprint. Furthermore, the stdlib =List= has a
terrifying implementation that uses =var= to workaround performance
problems in the stdlib collection design:

#+BEGIN_SRC scala
package scala.collection.immutable

sealed abstract class List[+A]
  extends AbstractSeq[A]
  with LinearSeq[A]
  with GenericTraversableTemplate[A, List]
  with LinearSeqOptimized[A, List[A]] { ... }
case object Nil extends List[Nothing] { ... }
final case class ::[B](
  override val head: B,
  private[scala] var tl: List[B]
) extends List[B] { ... }
#+END_SRC

=List= creation requires careful, and slow, =Thread= synchronisation
to ensure safe publishing. =IList= requires no such hacks and can
therefore outperform =List=.

#+BEGIN_ASIDE
Isn't =NonEmptyList= just the same as =ICons=? Yes, at a data structure level.
But the difference is that =ICons= is part of the =IList= ADT whereas
=NonEmptyList= is outside it. Typeclass instances should always be provided at
the level of an ADT, not for each entry, to avoid complexity.
#+END_ASIDE

**** =EphemeralStream=

The stdlib =Stream= is a lazy version of =List=, but is riddled with
memory leaks and unsafe methods. =EphemeralStream= does not keep
references to computed values, helping to alleviate the memory
retention problem, and removing unsafe methods in the same spirit as
=IList=.

#+BEGIN_SRC scala
sealed abstract class EphemeralStream[A] {
  def headOption: Option[A]
  def tailOption: Option[EphemeralStream[A]]
  ...
}
// private implementations
object EphemeralStream extends EphemeralStreamInstances {
  type EStream[A] = EphemeralStream[A]

  def emptyEphemeralStream[A]: EStream[A] = ...
  def cons[A](a: =>A, as: =>EStream[A]): EStream[A] = ...
  def unfold[A, B](start: =>B)(f: B => Option[(A, B)]): EStream[A] = ...
  def iterate[A](start: A)(f: A => A): EStream[A] = ...

  implicit class ConsWrap[A](e: =>EStream[A]) {
    def ##::(h: A): EStream[A] = cons(h, e)
  }
  object ##:: {
    def unapply[A](xs: EStream[A]): Option[(A, EStream[A])] =
      if (xs.isEmpty) None
      else Some((xs.head(), xs.tail()))
  }
  ...
}
#+END_SRC

#+BEGIN_ASIDE
The use of the word /stream/ for a data structure of this nature comes down to
legacy. /Stream/ is now more commonly used to refer to the /Reactive Manifesto/
and its compatible frameworks such as Akka Streams and /Functional Streams for
Scala/ (fs2). We will tour fs2 / =scalaz-stream= in a later chapter.
#+END_ASIDE

=.cons=, =.unfold= and =.iterate= are mechanisms for creating streams, and the
convenient syntax =##::= puts a new element at the head of a by-name =EStream=
reference. =.unfold= is for creating a finite (but possibly infinite) stream by
repeatedly applying a function =f= to get the next value and input for the
following =f=. =.iterate= creates an infinite stream by repeating a function =f=
on the previous element.

=EStream= may appear in pattern matches with the symbol =##::=,
matching the syntax for =.cons=.

#+BEGIN_ASIDE
=##::= sort of looks like an Exogorth: a giant space worm that lives
on an asteroid.
#+END_ASIDE

Although =EStream= addresses the value memory retention problem, it is
still possible to suffer from /slow memory leaks/ if a live reference
points to the head of an infinite stream. Problems of this nature, as
well as the need to compose effectful streams, are why fs2 exists.

**** =CorecursiveList=

# https://github.com/scalaz/scalaz/pull/1193
# http://jyp.github.io/posts/controlled-fusion.html

/Corecursion/ is when we start from a base state and produce subsequent steps
deterministically, like the =EphemeralStream.unfold= method that we just
studied:

#+BEGIN_SRC scala
def unfold[A, B](b: =>B)(f: B => Option[(A, B)]): EStream[A] = ...
#+END_SRC

Contrast to /recursion/, which breaks data into a base state and then
terminates.

A =CorecursiveList= is a data encoding of =EphemeralStream.unfold=, offering an
alternative to =EStream= that may perform better in some circumstances:

#+BEGIN_SRC scala
sealed abstract class CorecursiveList[A] {
  type S
  def init: S
  def step: S => Maybe[(S, A)]
}

object CorecursiveList {
  private final case class CorecursiveListImpl[S0, A](
    init: S0,
    step: S0 => Maybe[(S0, A)]
  ) extends CorecursiveList[A] { type S = S0 }

  def apply[S, A](init: S)(step: S => Maybe[(S, A)]): CorecursiveList[A] =
    CorecursiveListImpl(init, step)

  ...
}
#+END_SRC

Corecursion is useful when implementing =Comonad.cojoin=, like our =Hood=
example. =CorecursiveList= is a good way to codify non-linear recurrence
equations like those used in biology population models, drone control systems,
macro economics, and investment banking models.

**** =ImmutableArray=

A simple wrapper around mutable stdlib =Array=, with primitive
specialisations:

#+BEGIN_SRC scala
sealed abstract class ImmutableArray[+A] {
  def ++[B >: A: ClassTag](o: ImmutableArray[B]): ImmutableArray[B]
  ...
}
object ImmutableArray {
  final class StringArray(s: String) extends ImmutableArray[Char] { ... }
  sealed class ImmutableArray1[+A](as: Array[A]) extends ImmutableArray[A] { ... }
  final class ofRef[A <: AnyRef](as: Array[A]) extends ImmutableArray1[A](as)
  ...
  final class ofLong(as: Array[Long]) extends ImmutableArray1[Long](as)

  def fromArray[A](x: Array[A]): ImmutableArray[A] = ...
  def fromString(str: String): ImmutableArray[Char] = ...
  ...
}
#+END_SRC

=Array= is unrivalled in terms of read performance and heap size.
However, there is zero structural sharing when creating new arrays,
therefore arrays are typically used only when their contents are not
expected to change, or as a way of safely wrapping raw data from a
legacy system.

**** =Dequeue=

A =Dequeue= (pronounced like a "deck" of cards) is a linked list that
allows items to be put onto or retrieved from the front (=cons=) or
the back (=snoc=) in constant time. Removing an element from either
end is constant time on average.

#+BEGIN_SRC scala
sealed abstract class Dequeue[A] {
  def frontMaybe: Maybe[A]
  def backMaybe: Maybe[A]

  def ++(o: Dequeue[A]): Dequeue[A] = ...
  def +:(a: A): Dequeue[A] = cons(a)
  def :+(a: A): Dequeue[A] = snoc(a)
  def cons(a: A): Dequeue[A] = ...
  def snoc(a: A): Dequeue[A] = ...
  def uncons: Maybe[(A, Dequeue[A])] = ...
  def unsnoc: Maybe[(A, Dequeue[A])] = ...
  ...
}
private final case class SingletonDequeue[A](single: A) extends Dequeue[A] { ... }
private final case class FullDequeue[A](
  front: NonEmptyList[A],
  fsize: Int,
  back: NonEmptyList[A],
  backSize: Int) extends Dequeue[A] { ... }
private final case object EmptyDequeue extends Dequeue[Nothing] { ... }

object Dequeue {
  def empty[A]: Dequeue[A] = EmptyDequeue()
  def apply[A](as: A*): Dequeue[A] = ...
  def fromFoldable[F[_]: Foldable, A](fa: F[A]): Dequeue[A] = ...
  ...
}
#+END_SRC

The way it works is that there are two lists, one for the front data
and another for the back. Consider an instance holding symbols =a0,
a1, a2, a3, a4, a5, a6=

#+BEGIN_SRC scala
FullDequeue(
  NonEmptyList('a0, IList('a1, 'a2, 'a3)), 4,
  NonEmptyList('a6, IList('a5, 'a4)), 3)
#+END_SRC

which can be visualised as

#+BEGIN_SRC dot :cmd dot :file images/dequeue.png :exports results
digraph G {
    graph [dpi=100];
    node [fontname=Hack];

    subgraph cluster_front {
        label = "front";
        subgraph cluster_front_tail {
            label = "tail        "
            style=filled;
            color=lightgrey;
            node [style=filled,color=white];
            a1;
            a1 -> a2 -> a3;
        }
        a0;
        a0 -> a1;
    }

    subgraph cluster_back {
        label = "back";
        subgraph cluster_back_tail {
            node [style=filled,fontcolor=white,color=lightgray];
            a5 -> a4
            label = "tail        ";
            color=lightgray;
        }
        a6 [style=filled,color=lightgray,fontcolor=white];
        a6 -> a5;
    }
}
#+END_SRC

#+CAPTION: 30
#+RESULTS:
[[file:images/dequeue.png]]

Note that the list holding the =back= is in reverse order.

Reading the =snoc= (final element) is a simple lookup into
=back.head=. Adding an element to the end of the =Dequeue= means
adding a new element to the head of the =back=, and recreating the
=FullDequeue= wrapper (which will increase =backSize= by one). Almost
all of the original structure is shared. Compare to adding a new
element to the end of an =IList=, which would involve recreating the
entire structure.

The =frontSize= and =backSize= are used to re-balance the =front= and
=back= so that they are always approximately the same size.
Re-balancing means that some operations can be slower than others
(e.g. when the entire structure must be rebuilt) but because it
happens only occasionally, we can take the average of the cost and say
that it is constant.

**** =DList=

# http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/

Linked lists have poor performance characteristics when large lists are appended
together. Consider the work that goes into evaluating the following:

#+BEGIN_SRC scala
((as ::: bs) ::: (cs ::: ds)) ::: (es ::: (fs ::: gs))
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/dlist-list-append.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    as;bs;cs;ds;es;fs;gs;
    c1 [label = ":::", ];
    c2 [label = ":::"];
    c3 [label = ":::"];
    c4 [label = ":::"];
    c5 [label = ":::"];
    c6 [label = ":::"];

    as -> c1 [penwidth=3];
    bs -> c1;

    cs -> c2 [penwidth=3];
    ds -> c2;

    c1 -> c3 [penwidth=3];
    c2 -> c3;

    es -> c4 [penwidth=3];

    fs -> c5 [penwidth=3];
    gs -> c5;
    c5 -> c4;

    c3 -> c6 [penwidth=3];
    c4 -> c6;
}
#+END_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/dlist-list-append.png]]

This creates six intermediate lists, traversing and rebuilding every list three
times (except for =gs= which is shared between all stages).

The =DList= (for /difference list/) is a more efficient solution for this
scenario. Instead of performing the calculations at each stage, it is
represented as a function ~IList[A] => IList[A]~

#+BEGIN_SRC scala
final case class DList[A](f: IList[A] => IList[A]) {
  def toIList: IList[A] = f(IList.empty)
  def ++(as: DList[A]): DList[A] = DList(xs => f(as.f(xs)))
  ...
}
object DList {
  def fromIList[A](as: IList[A]): DList[A] = DList(xs => as ::: xs)
}
#+END_SRC

#+BEGIN_ASIDE
This is a simplified implementation: it has a stack overflow bug that we will
fix in the chapter on Advanced Monads.
#+END_ASIDE

The equivalent calculation is (the symbols created via =DList.fromIList=)

#+BEGIN_SRC scala
(((a ++ b) ++ (c ++ d)) ++ (e ++ (f ++ g))).toIList
#+END_SRC

which breaks the work into /right-associative/ (i.e. fast) appends

#+BEGIN_SRC scala
(as ::: (bs ::: (cs ::: (ds ::: (es ::: (fs ::: gs))))))
#+END_SRC

utilising the fast constructor on =IList=.

As always, there is no free lunch. There is a memory allocation overhead that
can slow down code that naturally results in right-associative appends. The
largest speedup is when =IList= operations are /left-associative/, e.g.

#+BEGIN_SRC scala
((((((as ::: bs) ::: cs) ::: ds) ::: es) ::: fs) ::: gs)
#+END_SRC

Difference lists suffer from bad marketing. If they were called a
=ListBuilderFactory= they'd probably be in the standard library.

**** =ISet=

Tree structures are excellent for storing ordered data, with every /binary node/
holding elements that are /less than/ in one branch, and /greater than/ in the
other. However, naive implementations of a tree structure can become
/unbalanced/ depending on the insertion order. It is possible to maintain a
perfectly balanced tree, but it is incredibly inefficient as every insertion
effectively rebuilds the entire tree.

=ISet= is an implementation of a tree of /bounded balance/, meaning that it is
approximately balanced, using the =size= of each branch to balance a node.

#+BEGIN_SRC scala
sealed abstract class ISet[A] {
  val size: Int = this match {
    case Tip()        => 0
    case Bin(_, l, r) => 1 + l.size + r.size
  }
  ...
}
object ISet {
  private final case class Tip[A]() extends ISet[A]
  private final case class Bin[A](a: A, l: ISet[A], r: ISet[A]) extends ISet[A]

  def empty[A]: ISet[A] = Tip()
  def singleton[A](x: A): ISet[A] = Bin(x, Tip(), Tip())
  def fromFoldable[F[_]: Foldable, A: Order](xs: F[A]): ISet[A] =
    xs.foldLeft(empty[A])((a, b) => a insert b)
  ...
}
#+END_SRC

=ISet= requires =A= to have an =Order=. The =Order[A]= instance must remain the
same between calls or internal assumptions will be invalid, leading to data
corruption: i.e. we are assuming typeclass coherence such that =Order[A]= is
unique for any =A=.

The =ISet= ADT unfortunately permits invalid trees. We strive to write ADTs that
fully describe what is and isn't valid through type restrictions, but sometimes
there are situations where it can only be achieved by the inspired touch of an
immortal. Instead, =Tip= / =Bin= are =private=, to stop users from accidentally
constructing invalid trees. =.insert= is the only way to build an =ISet=,
therefore defining what constitutes a valid tree.

#+BEGIN_SRC scala
sealed abstract class ISet[A] {
  ...
  def contains(x: A)(implicit o: Order[A]): Boolean = ...
  def union(other: ISet[A])(implicit o: Order[A]): ISet[A] = ...
  def delete(x: A)(implicit o: Order[A]): ISet[A] = ...

  def insert(x: A)(implicit o: Order[A]): ISet[A] = this match {
    case Tip() => ISet.singleton(x)
    case self @ Bin(y, l, r) => o.order(x, y) match {
      case LT => balanceL(y, l.insert(x), r)
      case GT => balanceR(y, l, r.insert(x))
      case EQ => self
    }
  }
  ...
}
#+END_SRC

The internal methods =.balanceL= and =.balanceR= are mirrors of each other, so
we only study =.balanceL=, which is called when the value we are inserting is
/less than/ the current node. It is also called by the =.delete= method.

# https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers-0.5.10.2/src/Data-Set-Internal.html#Set

#+BEGIN_SRC scala
def balanceL[A](y: A, left: ISet[A], right: ISet[A]): ISet[A] = (left, right) match {
...
#+END_SRC

Balancing requires us to classify the scenarios that can occur. We will go
through each possible scenario, visualising the =(y, left, right)= on the left
side of the page, with the balanced structure on the right, also known as the
/rotated tree/.

- filled circles visualise a =Tip=
- three columns visualise the =left | value | right= fields of =Bin=
- diamonds visualise any =ISet=

The first scenario is the trivial case, which is when both the =left= and
=right= are =Tip=. In fact we will never encounter this scenario from =.insert=,
but we hit it in =.delete=

#+BEGIN_SRC scala
case (Tip(), Tip()) => singleton(y)
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-1.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=point,width=0.2];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> y | <right>"];
      left_ [shape=point,width=0.2];
      right_ [shape=point,width=0.2];
      left_ -> y_:left;
      right_ -> y_:right;
    }
}
#+END_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/balanceL-1.png]]

The second case is when =left= is a =Bin= containing only =Tip=, we don't need
to balance anything, we just create the obvious connection:

#+BEGIN_SRC scala
case (Bin(lx, Tip(), Tip()), Tip()) => Bin(y, left, Tip())
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-2.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=point,width=0.2];
      left_right [shape=point,width=0.2];
      left_left -> left:left;
      left_right -> left:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> y | <right>"];
      left_ [shape=record, label="<left> | <y> lx | <right>"];
      right_ [shape=point,width=0.2];
      left_ -> y_:left;
      right_ -> y_:right;

      left_left_ [shape=point,width=0.2];
      left_right_ [shape=point,width=0.2];
      left_left_ -> left_:left;
      left_right_ -> left_:right;

    }
}
#+END_SRC

#+CAPTION: 60
#+RESULTS:
[[file:images/balanceL-2.png]]

The third case is when it starts to get interesting: =left= is a =Bin=
containing a =Bin= in its =right=

#+BEGIN_SRC scala
case (Bin(lx, Tip(), Bin(lrx, _, _)), Tip()) =>
  Bin(lrx, singleton(lx), singleton(y))
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-3.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=point,width=0.2];
      left_right [shape=record, label="<left> | <y> lrx | <right>"];
      left_left -> left:left;
      left_right -> left:right;
      left_right_left [label="",shape=diamond];
      left_right_right [label="",shape=diamond];
      left_right_left -> left_right:left;
      left_right_right -> left_right:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];
    hack_3 [style=invis];
    hack_3 -> hack_2 [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> lrx | <right>"];
      left_ [shape=record, label="<left> | <y> lx | <right>"];
      right_ [shape=record, label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      left_left_ [shape=point,width=0.2];
      left_right_ [shape=point,width=0.2];
      left_left_ -> left_:left;
      left_right_ -> left_:right;

      right_left_ [shape=point,width=0.2];
      right_right_ [shape=point,width=0.2];
      right_left_ -> right_:left;
      right_right_ -> right_:right;

    }
}
#+END_SRC

#+CAPTION: 70
#+RESULTS:
[[file:images/balanceL-3.png]]

But what happened to the two diamonds sitting below =lrx=? Didn't we just lose
information? No, we didn't lose information, because we can reason (based on
size balancing) that they are always =Tip=! There is no rule in any of the
following scenarios (or in =.balanceR=) that can produce a tree of the shape
where the diamonds are =Bin=.

The fourth case is the opposite of the third case.

#+BEGIN_SRC scala
case (Bin(lx, ll, Tip()), Tip()) => Bin(lx, ll, singleton(y))
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-4.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [label="ll",shape=diamond];
      left_right [shape=point,width=0.2];
      left_left -> left:left;
      left_right -> left:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> lx | <right>"];
      left_ [label="ll",shape=diamond];
      right_ [shape=record, label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      right_left_ [shape=point,width=0.2];
      right_right_ [shape=point,width=0.2];
      right_left_ -> right_:left;
      right_right_ -> right_:right;

    }
}
#+END_SRC

#+CAPTION: 70
#+RESULTS:
[[file:images/balanceL-4.png]]

The fifth case is when we have full trees on both sides of the =left= and we
must use their relative sizes to decide on how to re-balance.

#+BEGIN_SRC scala
case (Bin(lx, ll, lr), Tip()) if (2*ll.size > lr.size) =>
  Bin(lx, ll, Bin(y, lr, Tip()))
case (Bin(lx, ll, Bin(lrx, lrl, lrr)), Tip()) =>
  Bin(lrx, Bin(lx, ll, lrl), Bin(y, lrr, Tip()))
#+END_SRC

For the first branch, ~2*ll.size > lr.size~

#+BEGIN_SRC dot :cmd dot :file images/balanceL-5a.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=diamond,label="ll",penwidth=3];
      left_right [shape=diamond, label="lr"];
      left_left -> left:left;
      left_right -> left:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];
    hack_3 [style=invis];
    hack_3 -> hack_2 [style=invis];

    subgraph case_ {
      y_ [shape=record,label="<left> | <y> lx | <right>"];
      left_ [shape=diamond,label="ll"];
      right_ [shape=record,label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      right_left_ [shape=diamond,label="lr"];
      right_right_ [shape=point,width=0.2];
      right_left_ -> right_:left;
      right_right_ -> right_:right;
    }
}
#+End_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/balanceL-5a.png]]

and for the second branch ~2*ll.size <= lr.size~

#+BEGIN_SRC dot :cmd dot :file images/balanceL-5b.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=point,width=0.2];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=diamond,label="ll"];
      left_right [shape=record, label="<left> | <y> lrx | <right>", penwidth=3];
      left_left -> left:left;
      left_right -> left:right;
      left_right_left [label="lrl",shape=diamond];
      left_right_right [label="lrr",shape=diamond];
      left_right_left -> left_right:left;
      left_right_right -> left_right:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];
    hack_3 [style=invis];
    hack_3 -> hack_2 [style=invis];

    subgraph case_ {
      y_ [shape=record,label="<left> | <y> lrx | <right>"];
      left_ [shape=record,label="<left> | <y> lx | <right>"];
      right_ [shape=record,label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      left_left_ [shape=diamond,label="ll"];
      left_right_ [shape=diamond,label="lrl"];
      left_left_ -> left_:left;
      left_right_ -> left_:right;

      right_left_ [shape=diamond,label="lrr"];
      right_right_ [shape=point,width=0.2];
      right_left_ -> right_:left;
      right_right_ -> right_:right;
    }
}
#+End_SRC

#+CAPTION: 75
#+RESULTS:
[[file:images/balanceL-5b.png]]

The sixth scenario introduces a tree on the =right=. When the =left= is empty we
create the obvious connection. This scenario never arises from =.insert= because
the =left= is always non-empty:

#+BEGIN_SRC scala
case (Tip(), r) => Bin(y, Tip(), r)
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-6.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=point,width=0.2];
      right [shape=diamond,label="r"];
      left -> y [style=invis];
      right -> y [style=invis];
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> y | <right>"];
      left_ [shape=point,width=0.2];
      right_ [shape=diamond,label="r"];
      left_ -> y_:left;
      right_ -> y_:right;
    }
}
#+END_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/balanceL-6.png]]

The final scenario is when we have non-empty trees on both sides. Unless the
=left= is three times or more the size of the =right=, we can do the simple
thing and create a new =Bin=

#+BEGIN_SRC scala
case _ if l.size <= 3 * r.size => Bin(y, l, r)
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-7a.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=diamond,label="l"];
      right [shape=diamond,label="r",penwidth=3];
      left -> y [style=invis];
      right -> y [style=invis];
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];

    subgraph case_ {
      y_ [shape=record, label="<left> | <y> y | <right>"];
      left_ [shape=diamond,label="l"];
      right_ [shape=diamond,label="r"];
      left_ -> y_:left;
      right_ -> y_:right;
    }
}
#+END_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/balanceL-7a.png]]

However, should the =left= be more than three times the size of the =right=, we
must balance based on the relative sizes of =ll= and =lr=, like in scenario
five.

#+BEGIN_SRC scala
case (Bin(lx, ll, lr), r) if (2*ll.size > lr.size) =>
  Bin(lx, ll, Bin(y, lr, r))
case (Bin(lx, ll, Bin(lrx, lrl, lrr)), r) =>
  Bin(lrx, Bin(lx, ll, lrl), Bin(y, lrr, r))
#+END_SRC

#+BEGIN_SRC dot :cmd dot :file images/balanceL-7b.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=diamond,label="r"];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=diamond,label="ll",penwidth=3];
      left_right [shape=diamond, label="lr"];
      left_left -> left:left;
      left_right -> left:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];
    hack_3 [style=invis];
    hack_3 -> hack_2 [style=invis];

    subgraph case_ {
      y_ [shape=record,label="<left> | <y> lx | <right>"];
      left_ [shape=diamond,label="ll"];
      right_ [shape=record,label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      right_left_ [shape=diamond,label="lr"];
      right_right_ [shape=diamond,label="r"];
      right_left_ -> right_:left;
      right_right_ -> right_:right;
    }
}
#+End_SRC

#+CAPTION: 60
#+RESULTS:
[[file:images/balanceL-7b.png]]

#+BEGIN_SRC dot :cmd dot :file images/balanceL-7c.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT,nodesep=1];
    node [fontname=Hack];
    compound=true;

    subgraph case {
      y [label="y",color=white];
      left [shape=record, label="<left> | <y> lx | <right>"];
      right [shape=diamond,label="r"];
      left -> y [style=invis];
      right -> y [style=invis];
      left_left [shape=diamond,label="ll"];
      left_right [shape=record, label="<left> | <y> lrx | <right>",penwidth=3];
      left_left -> left:left;
      left_right -> left:right;
      left_right_left [label="lrl",shape=diamond];
      left_right_right [label="lrr",shape=diamond];
      left_right_left -> left_right:left;
      left_right_right -> left_right:right;
    }

    goes_to [shape=rarrow,label="",color=lightgray];
    hack_2 [style=invis];
    hack_2 -> goes_to [style=invis];
    hack_3 [style=invis];
    hack_3 -> hack_2 [style=invis];

    subgraph case_ {
      y_ [shape=record,label="<left> | <y> lrx | <right>"];
      left_ [shape=record,label="<left> | <y> lx | <right>"];
      right_ [shape=record,label="<left> | <y> y | <right>"];
      left_ -> y_:left;
      right_ -> y_:right;

      left_left_ [shape=diamond,label="ll"];
      left_right_ [shape=diamond,label="lrl"];
      left_left_ -> left_:left;
      left_right_ -> left_:right;

      right_left_ [shape=diamond,label="lrr"];
      right_right_ [shape=diamond,label="r"];
      right_left_ -> right_:left;
      right_right_ -> right_:right;
    }
}
#+End_SRC

#+CAPTION: 75
#+RESULTS:
[[file:images/balanceL-7c.png]]

This concludes our study of the =.insert= method and how the =ISet= is
constructed. It should be of no surprise that =Foldable= is implemented in terms
of depth-first search along the =left= or =right=, as appropriate. Methods such
as =.minimum= and =.maximum= are optimal because the data structure already
encodes the ordering.

It is worth noting that some typeclass methods /cannot/ be implemented as
efficiently as we would like. Consider the signature of =Foldable.element=

#+BEGIN_SRC scala
@typeclass trait Foldable[F[_]] {
  ...
  def element[A: Equal](fa: F[A], a: A): Boolean
  ...
}
#+END_SRC

The obvious implementation for =.element= is to defer to (almost) binary-search
=ISet.contains=. However, it is not possible because =.element= provides =Equal=
whereas =.contains= requires =Order=.

# http://okmij.org/ftp/Haskell/types.html#restricted-datatypes
# https://github.com/scalaz/scalaz/pull/1576

=ISet= is unable to provide a =Functor= for the same reason. In practice this
turns out to be a sensible constraint: performing a =.map= would involve
rebuilding the entire structure. It is sensible to convert to some other
datatype, such as =IList=, perform the =.map=, and convert back. A consequence
is that it is not possible to have =Traverse[ISet]= or =Applicative[ISet]=.

**** =IMap=

#+BEGIN_SRC scala
sealed abstract class ==>>[A, B] {
  val size: Int = this match {
    case Tip()           => 0
    case Bin(_, _, l, r) => 1 + l.size + r.size
  }
}
object ==>> {
  type IMap[A, B] = A ==>> B

  private final case class Tip[A, B]() extends (A ==>> B)
  private final case class Bin[A, B](
    key: A,
    value: B,
    left: A ==>> B,
    right: A ==>> B
  ) extends ==>>[A, B]

  def apply[A: Order, B](x: (A, B)*): A ==>> B = ...

  def empty[A, B]: A ==>> B = Tip[A, B]()
  def singleton[A, B](k: A, x: B): A ==>> B = Bin(k, x, Tip(), Tip())
  def fromFoldable[F[_]: Foldable, A: Order, B](fa: F[(A, B)]): A ==>> B = ...
  ...
}
#+END_SRC

This is very familiar! Indeed, =IMap= (an alias to the lightspeed operator
~==>>~) is another size-balanced tree, but with an extra =value: B= field in
each binary branch, allowing it to store key/value pairs. Only the key type =A=
needs an =Order= and a suite of convenient methods are provided to allow easy
entry updating

#+BEGIN_SRC scala
sealed abstract class ==>>[A, B] {
  ...
  def adjust(k: A, f: B => B)(implicit o: Order[A]): A ==>> B = ...
  def adjustWithKey(k: A, f: (A, B) => B)(implicit o: Order[A]): A ==>> B = ...
  ...
}
#+END_SRC

**** =StrictTree= and =Tree=

Both =StrictTree= and =Tree= are implementations of a /Rose Tree/, a tree
structure with an unbounded number of branches in every node (unfortunately
built from standard library collections for legacy reasons):

#+BEGIN_SRC scala
case class StrictTree[A](
  rootLabel: A,
  subForest: Vector[StrictTree[A]]
)
#+END_SRC

=Tree= is a /by-need/ version of =StrictTree= with convenient constructors

#+BEGIN_SRC scala
class Tree[A](
  rootc: Need[A],
  forestc: Need[Stream[Tree[A]]]
) {
  def rootLabel = rootc.value
  def subForest = forestc.value
}
object Tree {
  object Node {
    def apply[A](root: =>A, forest: =>Stream[Tree[A]]): Tree[A] = ...
  }
  object Leaf {
    def apply[A](root: =>A): Tree[A] = ...
  }
}
#+END_SRC

The user of a Rose Tree is expected to manually balance it, which makes it
suitable for cases where it is useful to encode domain knowledge of a hierarchy
into the data structure. For example, in artificial intelligence, a Rose Tree
can be used in [[https://arxiv.org/abs/1203.3468][clustering algorithms]] to organise data into a hierarchy of
increasingly similar things. It is possible to represent XML documents with a
Rose Tree.

If you find yourself working with hierarchical data, consider using a Rose Tree
instead of rolling a custom data structure.

**** =FingerTree=

# http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
# https://github.com/scalaz/scalaz/issues/1609

Finger trees are generalised sequences with amortised constant cost lookup and
logarithmic concatenation. =A= is the type of data and it may help to ignore
=V=:

#+BEGIN_SRC scala
sealed abstract class FingerTree[V, A] {
  def +:(a: A): FingerTree[V, A] = ...
  def :+(a: =>A): FingerTree[V, A] = ...
  def <++>(right: =>FingerTree[V, A]): FingerTree[V, A] = ...
  ...
}
object FingerTree {
  private class Empty[V, A]() extends FingerTree[V, A]
  private class Single[V, A](v: V, a: =>A) extends FingerTree[V, A]
  private class Deep[V, A](
    v: V,
    left: Finger[V, A],
    spine: =>FingerTree[V, Node[V, A]],
    right: Finger[V, A]
  ) extends FingerTree[V, A]

  sealed abstract class Finger[V, A]
  final case class One[V, A](v: V, a1: A) extends Finger[V, A]
  final case class Two[V, A](v: V, a1: A, a2: A) extends Finger[V, A]
  final case class Three[V, A](v: V, a1: A, a2: A, a3: A) extends Finger[V, A]
  final case class Four[V, A](v: V, a1: A, a2: A, a3: A, a4: A) extends Finger[V, A]

  sealed abstract class Node[V, A]
  private class Node2[V, A](v: V, a1: =>A, a2: =>A) extends Node[V, A]
  private class Node3[V, A](v: V, a1: =>A, a2: =>A, a3: =>A) extends Node[V, A]
  ...
}
#+END_SRC

#+BEGIN_ASIDE
~<++>~ is the TIE Bomber. Admittedly, sending in the proton torpedoes is a bit
of an overreaction: it is the same thing as the regular =Monoid= TIE Fighter
=|+|=.
#+END_ASIDE

Visualising =FingerTree= as dots, =Finger= as boxes and =Node= as boxes within
boxes:

#+BEGIN_SRC dot :cmd dot :file images/fingertree.png :exports results
digraph G {
    graph [dpi=100, rankdir=BT];
    node [fontname=Hack];

    // Deep[V, A]
    deep1 [shape=circle,label="",style=filled,width=0.1,color=black];

    // Two[V, A]
    ab [shape=record, label="<a> a | <b> b"];
    ab -> deep1 [dir=none];

    // Node2[V, A]
    node1 [shape=record,label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>c</TD><TD>d</TD></TR>
</TABLE> |
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>e</TD></TR>
</TABLE>
>]

    // Deep[V, Node[A]]
    deep2 [shape=doublecircle,label="",style=filled,width=0.1,color=black];
    node1 -> deep2 [dir=none];

    deep3 [shape=doublecircle,label="",style=filled,width=0.1,color=black];
    deep3 -> deep2 -> deep1 [dir=none];

    single [shape=record,width=0.1,label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>f</TD></TR>
</TABLE>
>]
    single -> deep3 [dir=none];

    node2 [shape=record,label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>g</TD><TD>h</TD></TR>
</TABLE> |
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>i</TD><TD>j</TD></TR>
</TABLE>
>]

    node2 -> deep2 [dir=none];

    klm [shape=record, label="<k> k| <l> l | <m> m"];
    klm -> deep1 [dir=none];
}
#+End_SRC

#+CAPTION: 35
#+RESULTS:
[[file:images/fingertree.png]]

Adding elements to the front of a =FingerTree= with =+:= is efficient because
=Deep= simply adds the new element to its =left= finger. If the finger is a
=Four=, we rebuild the =spine= to take 3 of the elements as a =Node3=. Adding to
the end, =:+=, is the same but in reverse.

Appending =|+|= (also =<++>=) is more efficient than adding one element at a
time because the case of two =Deep= trees can retain the outer branches,
rebuilding the spine based on the 16 possible combinations of the two =Finger=
values in the middle.

In the above we skipped over =V=. Not shown in the ADT description is an
=implicit measurer: Reducer[A, V]= on every element of the ADT.

#+BEGIN_ASIDE
Storing typeclass instances on the ADT is considered bad style and also
increases the memory requirement by 64 bits for every entry. The implementation
of =FingerTree= is almost a decade old and is due a rewrite.
#+END_ASIDE

=Reducer= is an extension of =Monoid= that allows for single elements to be
added to an =M=

#+BEGIN_SRC scala
class Reducer[C, M: Monoid] {
  def unit(c: C): M

  def snoc(m: M, c: C): M = append(m, unit(c))
  def cons(c: C, m: M): M = append(unit(c), m)
}
#+END_SRC

For example, =Reducer[A, IList[A]]= can provide an efficient =.cons=

#+BEGIN_SRC scala
implicit def reducer[A]: Reducer[A, IList[A]] = new Reducer[A, IList[A]] {
  override def unit(a: A): IList[A] = IList.single(a)
  override def cons(a: A, as: IList[A]): IList[A] = a :: as
}
#+END_SRC

***** =IndSeq=

If we use =Int= as =V=, we can get an indexed sequence, where the measure is
/size/, allowing us to perform index-based lookup by comparing the desired index
with the size at each branch in the structure:

#+BEGIN_SRC scala
final class IndSeq[A](val self: FingerTree[Int, A])
object IndSeq {
  private implicit def sizer[A]: Reducer[A, Int] = _ => 1
  def apply[A](as: A*): IndSeq[A] = ...
}
#+END_SRC

Another use of =FingerTree= is as an ordered sequence, where the measure stores
the largest value contained by each branch:

***** =OrdSeq=

#+BEGIN_SRC scala
final class OrdSeq[A: Order](val self: FingerTree[LastOption[A], A]) {
  def partition(a: A): (OrdSeq[A], OrdSeq[A]) = ...
  def insert(a: A): OrdSeq[A] = ...
  def ++(xs: OrdSeq[A]): OrdSeq[A] = ...
}
object OrdSeq {
  private implicit def keyer[A]: Reducer[A, LastOption[A]] = a => Tag(Some(a))
  def apply[A: Order](as: A*): OrdSeq[A] = ...
}
#+END_SRC

=OrdSeq= has no typeclass instances so it is only useful for incrementally
building up an ordered sequence, with duplicates. We can access the underlying
=FingerTree= when needed.

***** =Cord=

The most common use of =FingerTree= is as an efficient intermediate holder for
=String= representations in =Show=. Building a single =String= can be thousands
of times faster than the default =case class= implementation of nested
=.toString=, which builds a =String= for every layer in the ADT.

#+BEGIN_SRC scala
final case class Cord(self: FingerTree[Int, String]) {
  override def toString: String = {
    val sb = new java.lang.StringBuilder(self.measure)
    self.foreach(sb.append) // locally scoped side effect
    sb.toString
  }
  ...
}
#+END_SRC

For example, the =Cord[String]= instance returns a =Three= with the string in
the middle and quotes on either side

#+BEGIN_SRC scala
implicit val show: Show[String] = s => Cord(FingerTree.Three("\"", s, "\""))
#+END_SRC

Therefore a =String= renders as it is written in source code

#+BEGIN_SRC scala
scala> val s = "foo"
       s.toString
res: String = foo

scala> s.show
res: Cord = "foo"
#+END_SRC

**** =Heap= Priority Queue

A /priority queue/ is a data structure that allows fast insertion of ordered
elements, allowing duplicates, with fast access to the /minimum/ value (highest
priority). The structure is not required to store the non-minimal elements in
order. A naive implementation of a priority queue could be

#+BEGIN_SRC scala
final case class Vip[A] private (val peek: Maybe[A], xs: IList[A]) {
  def push(a: A)(implicit O: Order[A]): Vip[A] = peek match {
    case Maybe.Just(min) if a < min => Vip(a.just, min :: xs)
    case _                          => Vip(peek, a :: xs)
  }

  def pop(implicit O: Order[A]): Maybe[(A, Vip[A])] = peek strengthR reorder
  private def reorder(implicit O: Order[A]): Vip[A] = xs.sorted match {
    case INil()           => Vip(Maybe.empty, IList.empty)
    case ICons(min, rest) => Vip(min.just, rest)
  }
}
object Vip {
  def fromList[A: Order](xs: IList[A]): Vip[A] = Vip(Maybe.empty, xs).reorder
}
#+END_SRC

This =push= is a very fast =O(1)=, but =reorder= (and therefore =pop=) relies on
=IList.sorted= costing =O(n log n)=.

# http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf

Scalaz encodes a priority queue, with a tree structure where every node has a
value less than its children, called a /Heap Priority Queue/. =Heap= has fast
push (=insert=), =union=, =size=, pop (=uncons=) and peek (=minimumO=)
operations:

#+BEGIN_SRC scala
sealed abstract class Heap[A] {
  def insert(a: A)(implicit O: Order[A]): Heap[A] = ...
  def +(a: A)(implicit O: Order[A]): Heap[A] = insert(a)

  def union(as: Heap[A])(implicit O: Order[A]): Heap[A] = ...

  def uncons(implicit O: Order[A]): Option[(A, Heap[A])] = minimumO strengthR deleteMin
  def minimumO: Option[A] = ...
  def deleteMin(implicit O: Order[A]): Heap[A] = ...

  ...
}
object Heap {
  def fromData[F[_]: Foldable, A: Order](as: F[A]): Heap[A] = ...

  private final case class Ranked[A](rank: Int, value: A)

  private final case class Empty[A]() extends Heap[A]
  private final case class NonEmpty[A](
    size: Int,
    tree: Tree[Ranked[A]]
  ) extends Heap[A]

  ...
}
#+END_SRC

#+BEGIN_ASIDE
=size= is memoized in the ADT to enable instant calculation of
=Foldable.length=, at a cost of 64 bits per entry. A variant of =Heap= could be
created with a smaller footprint, but slower =Foldable.length=.
#+END_ASIDE

=Heap= is implemented with a Rose =Tree= of =Ranked= values, where the =rank= is
the depth of a subtree, allowing us to depth-balance the tree. We manually
maintain the tree so the =minimum= value is at the top. An advantage of encoding
the minimum value in the data structure is that =minimumO= (also known as
/peek/) is a free lookup:

#+BEGIN_SRC scala
  def minimumO: Option[A] = this match {
    case Empty()                        => None
    case NonEmpty(_, Tree.Node(min, _)) => Some(min.value)
  }
#+END_SRC

When inserting a new entry, we compare to the current minimum and replace if the
new entry is lower:

#+BEGIN_SRC scala
  def insert(a: A)(implicit O: Order[A]): Heap[A] = this match {
    case Empty() =>
      NonEmpty(1, Tree.Leaf(Ranked(0, a)))
    case NonEmpty(size, tree @ Tree.Node(min, _)) if a <= min.value =>
      NonEmpty(size + 1, Tree.Node(Ranked(0, a), Stream(tree)))
  ...
#+END_SRC

Insertions of non-minimal values result in an /unordered/ structure in the
branches of the minimum. When we encounter two or more subtrees of equal rank,
we optimistically put the minimum to the front:

#+BEGIN_SRC scala
  ...
    case NonEmpty(size, Tree.Node(min,
           (t1 @ Tree.Node(Ranked(r1, x1), xs1)) #::
           (t2 @ Tree.Node(Ranked(r2, x2), xs2)) #:: ts)) if r1 == r2 =>
      lazy val t0 = Tree.Leaf(Ranked(0, a))
      val sub =
        if (x1 <= a && x1 <= x2)
          Tree.Node(Ranked(r1 + 1, x1), t0 #:: t2 #:: xs1)
        else if (x2 <= a && x2 <= x1)
          Tree.Node(Ranked(r2 + 1, x2), t0 #:: t1 #:: xs2)
        else
          Tree.Node(Ranked(r1 + 1, a), t1 #:: t2 #:: Stream())

      NonEmpty(size + 1, Tree.Node(Ranked(0, min.value), sub #:: ts))

    case NonEmpty(size,  Tree.Node(min, rest)) =>
      val t0 = Tree.Leaf(Ranked(0, a))
      NonEmpty(size + 1, Tree.Node(Ranked(0, min.value), t0 #:: rest))
  }
#+END_SRC

Avoiding a full ordering of the tree makes =insert= very fast, =O(1)=, such that
producers adding to the queue are not penalised. However, the consumer pays the
cost when calling =uncons=, with =deleteMin= costing =O(log n)= because it must
search for the minimum value, and remove it from the tree by rebuilding. That's
fast when compared to the naive implementation.

The =union= operation also delays ordering allowing it to be =O(1)=.

If the =Order[Foo]= does not correctly capture the priority we want for the
=Heap[Foo]=, we can use =Tag= and provide a custom =Order[Foo @@ Custom]= for a
=Heap[Foo @@ Custom]=.

**** =Diev= (Discrete Intervals)

# http://web.engr.oregonstate.edu/~erwig/papers/Diet_JFP98.pdf

We can efficiently encode the (unordered) integer values 6, 9, 2, 13, 8, 14, 10,
7, 5 as inclusive intervals =[2, 2], [5, 10], [13, 14]=. =Diev= is an efficient
encoding of /intervals/ for elements =A= that have an =Enum[A]=, getting more
efficient as the contents become denser.

#+BEGIN_SRC scala
sealed abstract class Diev[A] {
  def +(interval: (A, A)): Diev[A]
  def +(value: A): Diev[A]
  def ++(other: Diev[A]): Diev[A]

  def -(interval: (A, A)): Diev[A]
  def -(value: A): Diev[A]
  def --(other: Diev[A]): Diev[A]

  def intervals: Vector[(A, A)]
  def contains(value: A): Boolean
  def contains(interval: (A, A)): Boolean
  ...
}
object Diev {
  private final case class DieVector[A: Enum](
    intervals: Vector[(A, A)]
  ) extends Diev[A]

  def empty[A: Enum]: Diev[A] = ...
  def fromValuesSeq[A: Enum](values: Seq[A]): Diev[A] = ...
  def fromIntervalsSeq[A: Enum](intervals: Seq[(A, A)]): Diev[A] = ...
}
#+END_SRC

When updating the =Diev=, adjacent intervals are merged (and then ordered) such
that there is a unique representation for a given set of values.

#+BEGIN_SRC scala
scala> Diev.fromValuesSeq(List(6, 9, 2, 13, 8, 14, 10, 7, 5))
res: Diev[Int] = ((2,2)(5,10)(13,14))

scala> Diev.fromValuesSeq(List(6, 9, 2, 13, 8, 14, 10, 7, 5).reverse)
res: Diev[Int] = ((2,2)(5,10)(13,14))
#+END_SRC

A great usecase for =Diev= is for storing time periods. For example, in our
=TradeTemplate= from the previous chapter

#+BEGIN_SRC scala
final case class TradeTemplate(
  payments: List[java.time.LocalDate],
  ccy: Option[Currency],
  otc: Option[Boolean]
)
#+END_SRC

if we find that the =payments= are very dense, we may wish to swap to a =Diev=
representation for performance reasons, without any change in our business logic
because we used =Monoid=, not any =List= specific methods. We would, however,
have to provide an =Enum[LocalDate]=, which is an otherwise useful thing to
have.

**** =OneAnd=

Recall that =Foldable= is the scalaz equivalent of a collections API and
=Foldable1= is for non-empty collections. So far we have only seen
=NonEmptyList= to provide a =Foldable1=. The simple data structure =OneAnd=
wraps any other collection to turn it into a =Foldable1=:

#+BEGIN_SRC scala
final case class OneAnd[F[_], A](head: A, tail: F[A])
#+END_SRC

=NonEmptyList[A]= could be an alias to =OneAnd[IList, A]=. Similarly, we can
create non-empty =Stream=, =DList= and =Tree= structures. However it may break
ordering and uniqueness characteristics of the underlying structure: a
=OneAnd[ISet, A]= is not a non-empty =ISet=, it is an =ISet= with a guaranteed
first element that may also be in the =ISet=.

*** Summary

In this chapter we have skimmed over the data types that scalaz has to offer.

It is not necessary to remember everything in this chapter: think of each
section as having planted the kernel of an idea in your mind. If, in a few
months, you find yourself thinking "I remember reading about a data structure
that might be useful here" and you return to these pages, we have succeeded.

The world of functional data structures is an active area of research. Academic
publications appear regularly with new approaches to old problems. If you are
the kind of person who would like to contribute back to scalaz, finding a
functional data structure to implement would be greatly appreciated.

* WIP                                                                 :final:
  :PROPERTIES:
  :EXPORT_FILE_NAME: wip.md
  :END:

** Advanced Monads

You have to know things like Advanced Monads in order to be an advanced
functional programmer. However, we are developers yearning for a simple life,
and our idea of "advanced" is modest. To put it into context:
=scala.concurrent.Future= is more complicated and nuanced than any =Monad= in
this chapter.

In this chapter we will study some of the most important implementations of
=Monad= and explain why =Future= needlessly complicates an application: we will
offer simpler and faster alternatives.

*** Always in motion is the =Future=

# https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/
# https://alexn.org/blog/2017/01/30/asynchronous-programming-scala.html#h3

# believe it or not, Viktor Klang thinks a lot of this complexity is a good
# thing? :-/ http://viktorklang.com/blog/Futures-in-Scala-protips-2.html

The biggest problem with =Future= is that it eagerly schedules work during
construction. As we discovered in the introduction, =Future= conflates the
definition of a program with /interpreting/ it (i.e. running it).

=Future= is also bad from a performance perspective: every time =.flatMap= is
called, a closure is submitted to an =Executor=, resulting in unnecessary thread
scheduling and context switching. It is not unusual to see 50% of our CPU power
dealing with thread scheduling, instead of doing the work. So much so that
parallelising work with =Future= can often make it /slower/.

Combined, eager evaluation and executor submission means that it is impossible
to know when a job started, when it finished, or the sub-tasks that were spawned
to calculate the final result. It should not surprise us that performance
monitoring "solutions" are a solid earner for the modern day snake oil merchant.

Furthermore, =Future.flatMap= requires an =ExecutionContext= to be in implicit
scope: users are forced to think about business logic and execution semantics at
the same time.

#+BEGIN_ASIDE
If =Future= was a Star Wars character, it would be Anakin Skywalker: the fallen
chosen one, rushing in and breaking things without thinking.
#+END_ASIDE

# General Grievous, with four arms flairing around everywhere. An army with no
# loyalty, no spirit.

*** Effects and Side Effects

If we can't call side-effecting methods in our business logic, or in =Future=
(or =Id=, or =Either=, or =Const=, etc), *when can* we write them? The answer
is: in a =Monad= that delays execution until it is interpreted at the
application's entrypoint. We can now refer to I/O and mutation as an /effect/ on
the world, captured by the type system, as opposed to having a hidden
/side-effect/.

The simplest implementation of such a =Monad= is =IO=, formalising the version
we wrote in the introduction:

# inspiration...
# https://gist.github.com/jdegoes/97459c0045f373f4eaf126998d8f65dc#io

#+BEGIN_SRC scala
final class IO[A](val interpret: () => A)
object IO {
  def apply[A](a: =>A): IO[A] = new IO(() => a)

  implicit val monad: Monad[IO] = new Monad[IO] {
    def point[A](a: =>A): IO[A] = IO(a)
    def bind[A, B](fa: IO[A])(f: A => IO[B]): IO[B] = f(fa.interpret())
  }
}
#+END_SRC

The =.interpret= method is only called once, in the entrypoint of an
application:

#+BEGIN_SRC scala
  def main(args: Array[String]): Unit = program.interpret()
#+END_SRC

However, there are two big problems with this simple =IO=:

1. it can stack overflow
2. it doesn't support parallel computations

Both of these problems will be overcome in this chapter. However, no matter how
complicated the internal implementation of a =Monad=, the principles described
here remain true: we're modularising the definition of a program and its
execution, such that we can capture effects in type signatures, allowing us to
reason about them, and reuse more code.

#+BEGIN_ASIDE
The scala compiler will happily allow us to call side-effecting methods from
unsafe code blocks. The [[https://scalacenter.github.io/scalafix/][scalafix]] linting tool can ban side-effecting methods at
compiletime, unless called from inside a deferred =Monad= like =IO=.
#+END_ASIDE

*** Stack Safety

On the JVM, every method call adds an entry to the call stack of the =Thread=,
like adding to the front of a =List=. When the method completes, the method at
the =head= is thrown away. The maximum length of the call stack is determined by
the =-Xss= flag when starting up =java=. Tail recursive methods are detected by
the scala compiler and do not add an entry. If we hit the limit, by calling too
many chained methods, we get a =StackOverflowError=.

Unfortunately, every nested call to our =IO='s =.flatMap= adds another method
call to the stack. The easiest way to see this is to repeat an action forever,
and see if it survives for longer than a few seconds. We can use =.forever=,
from =Apply= (a parent of =Monad=):

#+BEGIN_SRC scala
scala> val hello = IO { println("hello") }
scala> Apply[IO].forever(hello).interpret()

hello
hello
hello
...
hello
java.lang.StackOverflowError
    at java.io.FileOutputStream.write(FileOutputStream.java:326)
    at ...
    at monadio.IO$$anon$1.$anonfun$bind$1(monadio.scala:18)
    at monadio.IO$$anon$1.$anonfun$bind$1(monadio.scala:18)
    at ...
#+END_SRC

Scalaz has a typeclass that =Monad= instances can implement if they are stack
safe: =BindRec= requires a constant stack space for recursive =bind=:

#+BEGIN_SRC scala
@typeclass trait BindRec[F[_]] extends Bind[F] {
  def tailrecM[A, B](f: A => F[A \/ B])(a: A): F[B]

  override def forever[A, B](fa: F[A]): F[B] = ...
}
#+END_SRC

We don't need =BindRec= for all programs, but it is essential for a general
purpose =Monad= implementation.

The way to achieve stack safety is to convert method calls into references to an
ADT, the =Free= monad:

#+BEGIN_SRC scala
sealed abstract class Free[S[_], A]
object Free {
  private final case class Return[S[_], A](a: A)     extends Free[S, A]
  private final case class Suspend[S[_], A](a: S[A]) extends Free[S, A]
  private final case class Gosub[S[_], A0, B](
    a: Free[S, A0],
    f: A0 => Free[S, B]
  ) extends Free[S, B] { type A = A0 }
  ...
}
#+END_SRC

#+BEGIN_ASIDE
=SUSPEND=, =RETURN= and =GOSUB= are a tip of the hat to the =BASIC= commands of
the same name: pausing, completing, and continuing a subroutine, respectively.
#+END_ASIDE

The =Free= monad is named because it can be /generated for free/ for any =S[_]=.
For example, we could set =S= to be the =Drone= or =Machines= algebras from
Chapter 3 and generate a data structure representation of our program. We'll
return to why this is useful at the end of this chapter.

**** =Trampoline=

=Free= is more general than we need for now. Setting the algebra =S[_]= to ~()
=> ?~, a deferred calculation or /thunk/, we get =Trampoline= and can implement
a stack safe =Monad=

#+BEGIN_SRC scala
object Free {
  type Trampoline[A] = Free[() => ?, A]
  implicit val trampoline: Monad[Trampoline] with BindRec[Trampoline] =
    new Monad[Trampoline] with BindRec[Trampoline] {
      def point[A](a: =>A): Trampoline[A] = Return(a)
      def bind[A, B](fa: Trampoline[A])(f: A => Trampoline[B]): Trampoline[B] =
        Gosub(fa, f)

      def tailrecM[A, B](f: A => Trampoline[A \/ B])(a: A): Trampoline[B] =
        bind(f(a)) {
          case -\/(a) => tailrecM(f)(a)
          case \/-(b) => point(b)
        }
    }
  ...
}
#+END_SRC

The =Free= ADT is a natural data type representation of the =Monad= interface:

1. =Return= represents =.point=
2. =Gosub= represents =.bind= / =.flatMap=

When an ADT mirrors the arguments of related functions, it is called a /Church
encoding/, or /Continuation Passing Style/.

The =BindRec= implementation, =.tailrecM=, runs =.bind= until we get a =B=.
Although this is not technically a =@tailrec= implementation, it uses constant
stack space because each call returns a heap object, with delayed recursion.

#+BEGIN_ASIDE
Called =Trampoline= because every time we =.bind= on the stack, we /bounce/ back
to the heap.

The only Star Wars reference involving bouncing is Yoda's duel with Dooku. We
shall not speak of this again.
#+END_ASIDE

Convenient functions are provided to create a =Trampoline= eagerly (=.done=) or
by-name (=.delay=). We can also create a =Trampoline= from a by-name
=Trampoline= (=.suspend=):

#+BEGIN_SRC scala
object Trampoline {
  def done[A](a: A): Trampoline[A]                  = Return(a)
  def delay[A](a: =>A): Trampoline[A]               = suspend(done(a))
  def suspend[A](a: =>Trampoline[A]): Trampoline[A] = unit >> a

  private val unit: Trampoline[Unit] = Suspend(() => done(()))
}
#+END_SRC

When we see =Trampoline[A]= in a codebase we can always mentally substitute it
with =A=, because it is simply adding stack safety to the pure computation. We
get the =A= by interpreting =Free=, provided by the =.run= method:

#+BEGIN_SRC scala
sealed abstract class Free[S[_], A] {
  def run(implicit ev: Free[S, A] =:= Trampoline[A]): A = ev(this).go(_())

  def go(f: S[Free[S, A]] => Free[S, A])(implicit S: Functor[S]): A = {
    @tailrec def go2(t: Free[S, A]): A = t.resume match {
      case -\/(s) => go2(f(s))
      case \/-(r) => r
    }
    go2(this)
  }

  @tailrec def resume(implicit S: Functor[S]): (S[Free[S, A]] \/ A) = this match {
    case Return(a) => \/-(a)
    case Suspend(t) => -\/(t.map(Return(_)))
    case Gosub(Return(a), f) => f(a).resume
    case Gosub(Suspend(t), f) => -\/(t.map(f))
    case Gosub(Gosub(a, g), f) => a >>= (z => g(z) >>= f).resume
  }
  ...
}
#+END_SRC

Take a moment to read through the implementation of =resume= to understand how
this evaluates a single layer of the =Free=, and that =go= is running it to
completion. The case that is most likely to cause confusion is when we have
nested =Gosub=: apply the inner function =g= then pass it to the outer one =f=,
it is just function composition.

**** Example: Stack Safe =DList=

In the previous chapter we described the data type =DList= as

#+BEGIN_SRC scala
final case class DList[A](f: IList[A] => IList[A]) {
  def toIList: IList[A] = f(IList.empty)
  def ++(as: DList[A]): DList[A] = DList(xs => f(as.f(xs)))
  ...
}
#+END_SRC

However, the actual implementation looks more like:

#+BEGIN_SRC scala
final case class DList[A](f: IList[A] => Trampoline[IList[A]]) {
  def toIList: IList[A] = f(IList.empty).run
  def ++(as: =>DList[A]): DList[A] = DList(xs => suspend(as.f(xs) >>= f))
  ...
}
#+END_SRC

Instead of applying nested calls to =f= we use a suspended =Trampoline=. We
interpret the trampoline with =.run= only when needed, e.g. in =toIList=. The
changes are minimal, but we now have a stack safe =DList= that can rearrange the
concatenation of a large number lists without blowing the stack!

**** Stack Safe =IO=

Similarly, our =IO= can be made stack safe thanks to =Trampoline=:

#+BEGIN_SRC scala
final class IO[A](val tramp: Trampoline[A]) {
  def unsafePerformIO(): A = tramp.run
}
object IO {
  def apply[A](a: =>A): IO[A] = new IO(Trampoline.delay(a))

  implicit val Monad: Monad[IO] with BindRec[IO] =
    new Monad[IO] with BindRec[IO] {
      def point[A](a: =>A): IO[A] = IO(a)
      def bind[A, B](fa: IO[A])(f: A => IO[B]): IO[B] =
        new IO(fa.tramp >>= (a => f(a).tramp))
      def tailrecM[A, B](f: A => IO[A \/ B])(a: A): IO[B] = ...
    }
}
#+END_SRC

#+BEGIN_ASIDE
We heard you like =Monad=, so we made you a =Monad= out of a =Monad=, so you can
monadically bind when you are monadically binding.
#+END_ASIDE

The interpreter, =.unsafePerformIO()=, has an intentionally scary name to
discourage using it except in the entrypoint of the application.

This time, we don't get a stack overflow error:

#+BEGIN_SRC scala
scala> val hello = IO { println("hello") }
scala> Apply[IO].forever(hello).unsafePerformIO()

hello
hello
hello
...
hello
#+END_SRC

Using a =Trampoline= typically introduces a performance regression vs a regular
reference. It is =Free= in the sense of /freely generated/, not /free as in
beer/.

#+BEGIN_ASIDE
Always benchmark instead of accepting sweeping statements about performance: it
may well be the case that the garbage collector performs better for your
application when using =Free= because of the reduced size of retained objects in
the stack.
#+END_ASIDE

*** Monad Transformer Library

Monad transformers are data structures that wrap an underlying value and provide
a monadic /effect/.

For example, in Chapter 2 we used =OptionT= to let us use =F[Option[A]]= in a
=for= comprehension as if it was just a =F[A]=. This gave our program the effect
of an /optional/ value. Alternatively, we can get the effect of optionality if
we have a =MonadPlus=.

This subset of data types and extensions to =Monad= are often referred to as the
/Monad Transformer Library/ (MTL), summarised below. In this section, we will
explain each of the transformers, why they are useful, and how they work.

| Effect               | Underlying                  | Transformer | Typeclass     |
|----------------------+-----------------------------+-------------+---------------|
| optionality          | ~F[Maybe[A]]~               | ~MaybeT~    | ~MonadPlus~   |
| errors               | ~F[E \/ A]~                 | ~EitherT~   | ~MonadError~  |
| a runtime value      | ~A => F[B]~                 | ~ReaderT~   | ~MonadReader~ |
| journal / multitask  | ~F[(W, A)]~                 | ~WriterT~   | ~MonadTell~   |
| evolving state       | ~S => F[(S, A)]~            | ~StateT~    | ~MonadState~  |
| keep calm & carry on | ~F[E \&/ A]~                | ~TheseT~    |               |
| control flow         | ~(A => F[B]) => F[B]~       | ~ContT~     |               |

# https://www.slideshare.net/sukanthajra/classy-monad-transformers-stop-effing-around
# https://www.youtube.com/watch?v=QtZJATIPB0k
# https://gist.github.com/jdegoes/97459c0045f373f4eaf126998d8f65dc#common-transformers

**** =MonadTrans=

Each transformer has the general shape =T[F[_], A]=, providing at least an
instance of =Monad= and =Hoist= (and therefore =MonadTrans=):

#+BEGIN_SRC scala
@typeclass trait MonadTrans[T[_[_], _]] {
  def liftM[F[_]: Monad, A](a: F[A]): T[F, A]
}

@typeclass trait Hoist[F[_[_], _]] extends MonadTrans[F] {
  def hoist[M[_]: Monad, N[_]](f: M ~> N): F[M, ?] ~> F[N, ?]
}
#+END_SRC

#+BEGIN_ASIDE
=T[_[_], _]= is another example of a higher kinded type. It says that =T= takes
two type parameters: the first also takes a type parameter, written =_[_]=, and
the second does not take any type parameters, written =_=.
#+END_ASIDE

=.liftM= lets us create a monad transformer if we have an =F[A]=. For example,
we can create an =OptionT[IO, String]= by calling =.liftM[OptionT]= on an
=IO[String]=.

=.hoist= is the same idea, but for natural transformations.

Generally, there are three ways to create a monad transformer:

- from the underlying, using the transformer's constructor
- from a single value =A=, using =.pure= from the =Monad= syntax
- from an =F[A]=, using =.liftM= from the =MonadTrans= syntax

Due to the way that type inference works in Scala, this often means that a
complex type parameter must be explicitly written. As a workaround, transformers
provide convenient constructors on their companion that are easier to use.

**** =MaybeT=

=OptionT=, =MaybeT= and =LazyOptionT= have similar implementations, providing
optionality through =Option=, =Maybe= and =LazyOption=, respectively. We will
focus on =MaybeT= to avoid repetition.

#+BEGIN_SRC scala
final case class MaybeT[F[_], A](run: F[Maybe[A]])
object MaybeT {
  def just[F[_]: Applicative, A](v: =>A): MaybeT[F, A] =
    MaybeT(Maybe.just(v).pure[F])
  def empty[F[_]: Applicative, A]: MaybeT[F, A] =
    MaybeT(Maybe.empty.pure[F])
  ...
}
#+END_SRC

providing a =MonadPlus=

#+BEGIN_SRC scala
implicit def monad[F[_]: Monad] = new MonadPlus[MaybeT[F, ?]] {
  def point[A](a: =>A): MaybeT[F, A] = MaybeT.just(a)
  def bind[A, B](fa: MaybeT[F, A])(f: A => MaybeT[F, B]): MaybeT[F, B] =
    MaybeT(fa.run >>= (_.cata(f(_).run, Maybe.empty.pure[F])))

  def empty[A]: MaybeT[F, A] = MaybeT.empty

  def plus[A](a: MaybeT[F, A], b: =>MaybeT[F, A]): MaybeT[F, A] = ...
}
#+END_SRC

This monad looks fiddly, but it is just delegating everything to the =Monad[F]=
and then re-wrapping with a =MaybeT=. It is plumbing.

With this monad we can write logic that handles optionality in the =F[_]=
context, rather than carrying around =Option= or =Maybe=.

For example, say we are interfacing with a social media website to count the
number of stars a user has, and we start with a =String= that may or may not
correspond to a user. We have this algebra:

#+BEGIN_SRC scala
trait Twitter[F[_]] {
  def getUser(name: String): F[Maybe[User]]
  def getStars(user: User): F[Int]
}
def T[F[_]](implicit t: Twitter[F]): Twitter[F] = t
#+END_SRC

We need to call =getUser= followed by =getStars=. If we use =Monad= as our
context, our function is difficult because we have to handle the =Empty= case:

#+BEGIN_SRC scala
  def stars[F[_]: Monad: Twitter](name: String): F[Maybe[Int]] = for {
    maybeUser  <- T.getUser(name)
    maybeStars <- maybeUser.traverse(T.getStars)
  } yield maybeStars
#+END_SRC

However, if we have a =MonadPlus= as our context, we can suck =Maybe= into the
=F[_]= with =.orEmpty=, and forget about it:

#+BEGIN_SRC scala
  def stars[F[_]: MonadPlus: Twitter](name: String): F[Int] = for {
    user  <- T.getUser(name) >>= (_.orEmpty[F])
    stars <- T.getStars(user)
  } yield stars
#+END_SRC

However adding a =MonadPlus= requirement can cause problems downstream if the
context does not have one. The solution is to either change the context of the
program to =MaybeT[F, ?]= (lifting the =Monad[F]= into a =MonadPlus=), or to
explicitly use =MaybeT= in the return type, at the cost of slightly more code:

#+BEGIN_SRC scala
  def stars[F[_]: Monad: Twitter](name: String): MaybeT[F, Int] = for {
    user  <- MaybeT(T.getUser(name))
    stars <- T.getStars(user).liftM[MaybeT]
  } yield stars
#+END_SRC

The decision to require a more powerful =Monad= vs returning a transformer is
something that each team can decide for themselves based on the interpreters
that they plan on using for their program.

**** =EitherT=

An optional value is a special case of a value that may be an error, but we
don't know anything about the error. =EitherT= (and the lazy variant
=LazyEitherT=) allows us to use any type we want as the error value, providing
contextual information about what went wrong.

Where =\/= and =Validation= is the FP equivalent of a checked exception,
=EitherT= makes it convenient to both create and ignore errors until something
can be done about it.

=EitherT= is a wrapper around an =F[A \/ B]=

#+BEGIN_SRC scala
final case class EitherT[F[_], A, B](run: F[A \/ B])
object EitherT {
  def either[F[_]: Applicative, A, B](d: A \/ B): EitherT[F, A, B] = ...
  def leftT[F[_]: Functor, A, B](fa: F[A]): EitherT[F, A, B] = ...
  def rightT[F[_]: Functor, A, B](fb: F[B]): EitherT[F, A, B] = ...
  def pureLeft[F[_]: Applicative, A, B](a: A): EitherT[F, A, B] = ...
  def pure[F[_]: Applicative, A, B](b: B): EitherT[F, A, B] = ...
  ...
}
#+END_SRC

The =Monad= is a =MonadError=

#+BEGIN_SRC scala
@typeclass trait MonadError[F[_], E] extends Monad[F] {
  def raiseError[A](e: E): F[A]
  def handleError[A](fa: F[A])(f: E => F[A]): F[A]

  def emap[A, B](fa: F[A])(f: A => S \/ B): F[B] =
    bind(fa)(a => f(a).fold(raiseError(_), pure(_)))
}
#+END_SRC

=.raiseError= and =.handleError= are self-descriptive: the equivalent of =throw=
and =catch= an exception, respectively.

=.emap=, /either/ map, is for functions that could fail and is very useful for
writing decoders in terms of existing ones, much as we used =.contramap= to
define new encoders in terms of existing ones. For example, say we have an XML
decoder like

#+BEGIN_SRC scala
@typeclass trait XDecoder[A] {
  def fromXml(x: Xml): String \/ A
}
object XDecoder {
  implicit val monad: MonadError[String \/ ?, String] = ...
  implicit val string: XDecoder[String] = ...
}
#+END_SRC

we can define a decoder for =Char= in terms of a =String= decoder

#+BEGIN_SRC scala
implicit val char: XDecoder[Char] = XDecoder[String].emap { s =>
  if (s.length == 1) s(0).right
  else s"not a char: $s".left
}
#+END_SRC

The =MonadError= for =EitherT= is:

#+BEGIN_SRC scala
implicit def monad[F[_]: Monad, E] = new MonadError[EitherT[F, E, ?], E] {
  def monad[F[_]: Monad, E] = new MonadError[EitherT[F, E, ?], E] {
  def bind[A, B](fa: EitherT[F, E, A])
                (f: A => EitherT[F, E, B]): EitherT[F, E, B] =
    EitherT(fa.run >>= (_.fold(_.left[B].pure[F], b => f(b).run)))
  def point[A](a: =>A): EitherT[F, E, A] = EitherT.pure(a)

  def raiseError[A](e: E): EitherT[F, E, A] = EitherT.pureLeft(e)
  def handleError[A](fa: EitherT[F, E, A])
                    (f: E => EitherT[F, E, A]): EitherT[F, E, A] =
    EitherT(fa.run >>= {
      case -\/(e) => f(e).run
      case right => right.pure[F]
    })
}
#+END_SRC

It should be of no surprise that we can rewrite the =MonadPlus= example with
=MonadError=, inserting informative error messages:

#+BEGIN_SRC scala
  def stars[F[_]: Twitter](name: String)
                          (implicit F: MonadError[F, String]): F[Int] = for {
    user  <- T.getUser(name) >>= (_.orError(s"user '$name' not found")(F))
    stars <- T.getStars(user)
  } yield stars
#+END_SRC

where =.orError= is a convenience method on =Maybe=

#+BEGIN_SRC scala
sealed abstract class Maybe[A] {
  ...
  def orError[F[_], E](e: E)(implicit F: MonadError[F, E]): F[A] =
    cata(F.point(_), F.raiseError(e))
}
#+END_SRC

#+BEGIN_ASIDE
It is common to use =implicit= parameter blocks instead of context bounds when
the signature of the typeclass has more than one parameter.

It is also common practice to name the implicit parameter after the primary
type, in this case =F=.
#+END_ASIDE

The version using =EitherT= directly looks like

#+BEGIN_SRC scala
  def stars[F[_]: Monad: Twitter](name: String): EitherT[F, String, Int] = for {
    user <- EitherT(T.getUser(name).map(_ \/> s"user '$name' not found"))
    stars <- EitherT.rightT(T.getStars(user))
  } yield stars
#+END_SRC

The simplest instance of =MonadError= is for =\/=, perfect for testing business
logic that requires a =MonadError=. For example,

#+BEGIN_SRC scala
  final class MockTwitter extends Twitter[String \/ ?] {
    def getUser(name: String): String \/ Maybe[User] =
      if (name.contains(" ")) Maybe.empty.right
      else if (name === "wobble") "connection error".left
      else User(name).just.right

    def getStars(user: User): String \/ Int =
      if (user.name.startsWith("w")) 10.right
      else "stars have been replaced by hearts".left
  }
#+END_SRC

Our unit tests for =.stars= might cover these cases:

#+BEGIN_SRC scala
scala> stars("wibble")
\/-(10)

scala> stars("wobble")
-\/(connection error)

scala> stars("i'm a fish")
-\/(user 'i'm a fish' not found)

scala> stars("fommil")
-\/(stars have been replaced by hearts)
#+END_SRC

As we've now seen several times, we can focus on testing the pure business logic
without distraction.

***** Choosing an error type

The community is undecided on the best strategy for the error type =E= in
=MonadError=.

One school of thought says that we should pick something general, like a
=String=. The other school says that an application should have an ADT of
errors, allowing different errors to be reported or handled differently. An
unprincipled gang prefers using =Throwable= for maximum JVM compatibility.

There are two problems with an ADT of errors on the application level:

- it is very awkward to create a new error. One file becomes a monolithic
  repository of errors, aggregating the ADTs of individual subsystems.
- no matter how granular the errors are, the resolution is often the same: log
  it and try it again, or give up. We don't need an ADT for this.

An error ADT is of value if every entry allows a different kind of recovery to
be performed.

A compromise between an error ADT and a =String= is an intermediary format. JSON
is a good choice as it can be understood by most logging and monitoring
frameworks.

A problem with not having a stacktrace is that it can be hard to localise which
piece of code was the source of an error. With [[https://github.com/lihaoyi/sourcecode/][=sourcecode= by Li Haoyi]], we can
include contextual information as metadata in our errors:

#+BEGIN_SRC scala
  final case class Meta(fqn: String, file: String, line: Int)
  object Meta {
    implicit def gen(implicit fqn: sourcecode.FullName,
                              file: sourcecode.File,
                              line: sourcecode.Line): Meta =
      new Meta(fqn.value, file.value, line.value)
  }

  final case class Err(msg: String)(implicit val meta: Meta)
#+END_SRC

Although =Err= is referentially transparent, the implicit construction of a
=Meta= does *not* appear to be referentially transparent from a natural reading:
two calls to =Meta.gen= (invoked implicitly when creating an =Err=) will produce
different values because the location in the source code impacts the returned
value:

#+BEGIN_SRC scala
scala> println(Err("hello world").meta)
Meta(com.acme,<console>,10)

scala> println(Err("hello world").meta)
Meta(com.acme,<console>,11)
#+END_SRC

To understand this, we have to appreciate that =sourcecode.*= methods are macros
that are generating source code for us. If we were to write the above explicitly
it is clear what is happening:

#+BEGIN_SRC scala
scala> println(Err("hello world")(Meta("com.acme", "<console>", 10)).meta)
Meta(com.acme,<console>,10)

scala> println(Err("hello world")(Meta("com.acme", "<console>", 11)).meta)
Meta(com.acme,<console>,11)
#+END_SRC

Yes, we've made a deal with the macro devil, but we could also write the =Meta=
manually and have it go out of date quicker than our documentation.

***** =IO= and =Throwable=

=IO= does not have a =MonadError= but instead implements something similar to
=throw=, =catch= and =finally= for =Throwable= errors:

#+BEGIN_SRC scala
final class IO[A](val tramp: Trampoline[A]) {
  ...
  // catch
  def except(f: Throwable => IO[A]): IO[A] = ...
  // finally
  def ensuring[B](f: IO[B]): IO[A] = ...
  def onException[B](f: IO[B]): IO[A] = ...
}
object IO {
  // throw
  def throwIO[A](e: Throwable): IO[A] = IO(throw e)
  ...
}
#+END_SRC

It is good to avoid using keywords where possible, as it means we have to
remember less caveats of the language. If we need to interact with a legacy API
with a *predictable* exception, like a string parser, we can use =Maybe.attempt=
or =\/.attempt= and convert the non referentially transparent =Throwable= into a
descriptive =String=.

**** =ReaderT=

The reader monad wraps ~A => F[B]~ allowing a program ~F[B]~ to depend on a
runtime value ~A~. For those familiar with dependency injection, the reader
monad is the FP equivalent of Spring or Guice's ~@Inject~, without the XML and
reflection.

=ReaderT= is just an alias to another more generally useful data type named
after the mathematician /Heinrich Kleisli/.

#+BEGIN_SRC scala
type ReaderT[F[_], A, B] = Kleisli[F, A, B]

final case class Kleisli[F[_], A, B](run: A => F[B]) {
  def dimap[C, D](f: C => A, g: B => D)(implicit F: Functor[F]): Kleisli[F, C, D] =
    Kleisli(c => run(f(c)).map(g))

  def >=>[C](k: Kleisli[F, B, C])(implicit F: Bind[F]): Kleisli[F, A, C] = ...
  def >==>[C](k: B => F[C])(implicit F: Bind[F]): Kleisli[F, A, C] = this >=> Kleisli(k)
  ...
}
object Kleisli {
  implicit def kleisliFn[F[_], A, B](k: Kleisli[F, A, B]): A => F[B] = k.run
  ...
}
#+END_SRC

#+BEGIN_ASIDE
Some people call ~>=>~ the /fish operator/. There's always a bigger fish, hence
~>==>~. They are also called /Kleisli arrows/.
#+END_ASIDE

An =implicit= conversion on the companion allows us to use a =Kleisli= in place
of a function, so we can provide it as the parameter to a monad's =.bind=, or
~>>=~.

The most common use for =ReaderT= is to provide environment information to a
program. In =drone-dynamic-agents= we need access to the user's Oauth 2.0
Refresh Token to be able to contact Google. The obvious thing is to load the
=RefreshTokens= from disk on startup, and make every method take an =implicit
tokens: RefreshToken=. In fact, this is such a common requirement that Martin
Odersky has proposed [[https://www.scala-lang.org/blog/2016/12/07/implicit-function-types.html][implicit functions]].

A better solution is for our program to have an algebra that provides the
configuration when needed, e.g.

#+BEGIN_SRC scala
trait ConfigReader[F[_]] {
  def token: F[RefreshToken]
}
#+END_SRC

We have reinvented =MonadReader=, the typeclass associated to =ReaderT=, where
=.ask= is the same as our =.token=, and =S= is =RefreshToken=:

#+BEGIN_SRC scala
@typeclass trait MonadReader[F[_], S] extends Monad[F] {
  def ask: F[S]

  def local[A](f: S => S)(fa: F[A]): F[A]
}
#+END_SRC

with the implementation

#+BEGIN_SRC scala
implicit def monad[F[_]: Monad, R] = new MonadReader[Kleisli[F, R, ?], R] {
  def point[A](a: =>A): Kleisli[F, R, A] = Kleisli(_ => F.point(a))
  def bind[A, B](fa: Kleisli[F, R, A])(f: A => Kleisli[F, R, B]) =
    Kleisli(a => Monad[F].bind(fa.run(a))(f))

  def ask: Kleisli[F, R, R] = Kleisli(_.pure[F])
  def local[A](f: R => R)(fa: Kleisli[F, R, A]): Kleisli[F, R, A] =
    Kleisli(f andThen fa.run)
}
#+END_SRC

A law of =MonadReader= is that the =S= cannot change between invocations, i.e.
~ask >> ask === ask~. For our usecase, this is to say that the configuration is
read once. If we decide later that we want to reload configuration every time we
need it, e.g. allowing us to change the token without restarting the
application, we can reintroduce =ConfigReader= which has no such law.

In our OAuth 2.0 implementation we could first move the =Monad= evidence onto the
methods:

#+BEGIN_SRC scala
  def bearer(refresh: RefreshToken)(implicit F: Monad[F]): F[BearerToken] =
    for { ...
#+END_SRC

and then refactor the =refresh= parameter to be part of the =Monad=

#+BEGIN_SRC scala
  def bearer(implicit F: MonadReader[F, RefreshToken]): F[BearerToken] =
    for {
      refresh <- F.ask
#+END_SRC

Fundamentally, any parameter can be moved into the =MonadReader=. This is of
most value to your immediate caller when they simply want to thread through this
information from above. With =ReaderT=, we can reserve =implicit= parameter
blocks entirely for the use of typeclasses, reducing the mental burden of using
Scala.

The other method in =MonadReader= is =.local=

#+BEGIN_SRC scala
  def local[A](f: S => S)(fa: F[A]): F[A]
#+END_SRC

We can change =S= and run a program =fa= within that local context, returning to
the original =S=. A use case for =.local= is to generate a "stack trace" that
makes sense to our domain. giving us nested logging! Leaning on the =Meta= data
structure from the previous section, we define a function to checkpoint:

#+BEGIN_SRC scala
def traced[A](fa: F[A])(implicit F: MonadReader[F, IList[Meta]]): F[A] =
  F.local(Meta.gen :: _)(fa)
#+END_SRC

and we can use it to wrap functions that operate in this context.

#+BEGIN_SRC scala
def foo: F[Foo] = traced(getBar) >>= barToFoo
#+END_SRC

automatically passing through anything that is not explicitly traced. A compiler
plugin or macro could do the opposite, opting everything in by default.

If we access =.ask= we can see the breadcrumb trail of exactly how we were
called, without the distraction of bytecode implementation details. A
referentially transparent stacktrace!

A defensive programmer may wish to truncate the =IList[Meta]= at a certain
length to avoid the equivalent of a stack overflow. Indeed, a more appropriate
data structure is =Dequeue=.

=.local= can also be used to keep track of contextual information that is
directly relevant to the task at hand, like the number of spaces that must
indent a line when pretty printing a human readable file format, bumping it by
two spaces when we enter a nested structure.

#+BEGIN_ASIDE
Not four spaces. Not eight spaces. Not a TAB.

Two spaces. Exactly two spaces. This is a magic number we can hardcode, because
every other number is *wrong*.
#+END_ASIDE

Finally, if we cannot request a =MonadReader= because our application does not
provide one, we can always return a =ReaderT=

#+BEGIN_SRC scala
  def bearer(implicit F: Monad[F]): ReaderT[F, RefreshToken, BearerToken] =
    ReaderT( token => for {
    ...
#+END_SRC

If a caller receives a =ReaderT=, and they have the =token= parameter to hand,
they can call =access.run(token)= and get back an =F[BearerToken]=.

Admittedly, since we don't have many callers, we should just revert to a regular
function parameter. =MonadReader= is of most use when:

1. we may wish to refactor the code later to reload config
2. the value is not needed by intermediate callers
3. or, we want to locally scope some variable

In a nutshell, dotty can keep its implicit functions... we already have
=ReaderT= and =MonadReader=.

One last example. Monad transformers typically provide specialised =Monad=
instances if their underlying type has one. So, for example, =ReaderT= has a
=MonadError=, =MonadPlus=, etc if the underlying has one. Decoder typeclasses
tend to have a signature that looks like ~A => F[B]~, recall

#+BEGIN_SRC scala
@typeclass trait XDecoder[A] {
  def fromXml(x: Xml): String \/ A
}
#+END_SRC

which has a single method of signature ~XNode => String \/ A~, isomorphic to
=ReaderT[String \/ ?, Xml, A]=. We can formalise this relationship with an
=Isomorphism=. It's easier to read by introducing type aliases

#+BEGIN_SRC scala
type Out[a] = String \/ a
type RT[a] = ReaderT[Out, Xml, a]
val isoReaderT: XDecoder <~> RT =
  new IsoFunctorTemplate[XDecoder, RT] {
    def from[A](fa: RT[A]): XDecoder[A] = fa.run(_)
    def to[A](fa: XDecoder[A]): RT[A] = ReaderT[Out, Xml, A](fa.fromXml)
  }
#+END_SRC

Now our =XDecoder= has access to all the typeclasses that =ReaderT= has. The
typeclass we need is =MonadError[Decoder, String]=

#+BEGIN_SRC scala
implicit val monad: MonadError[XDecoder, String] = MonadError.fromIso(isoReaderT)
#+END_SRC

which we know to be useful for defining new decoders in terms of existing ones.

**** =WriterT=

The opposite to reading is writing. The =WriterT= monad transformer is typically
for writing to a journal.

#+BEGIN_SRC scala
final case class WriterT[F[_], W, A](run: F[(W, A)])
object WriterT {
  def put[F[_]: Functor, W, A](value: F[A])(w: W): WriterT[F, W, A] = ...
  def putWith[F[_]: Functor, W, A](value: F[A])(w: A => W): WriterT[F, W, A] = ...
  ...
}
#+END_SRC

The wrapped type is =F[(W, A)]= with the journal accumulated in =W=.

There is not just one associated monad, but two! =MonadTell= and =MonadListen=

#+BEGIN_SRC scala
@typeclass trait MonadTell[F[_], W] extends Monad[F] {
  def writer[A](w: W, v: A): F[A]
  def tell(w: W): F[Unit] = ...

  def :++>[A](fa: F[A])(w: =>W): F[A] = ...
  def :++>>[A](fa: F[A])(f: A => W): F[A] = ...
}

@typeclass trait MonadListen[F[_], W] extends MonadTell[F, W] {
  def listen[A](fa: F[A]): F[(A, W)]

  def written[A](fa: F[A]): F[W] = ...
}
#+END_SRC

=MonadTell= is for writing to the journal and =MonadListen= is to recover it.
The =WriterT= implementation is

#+BEGIN_SRC scala
implicit def monad[F[_]: Monad, W: Monoid] = new MonadListen[WriterT[F, W, ?], W] {
  def point[A](a: =>A) = WriterT((Monoid[W].zero, a).point)
  def bind[A, B](fa: WriterT[F, W, A])(f: A => WriterT[F, W, B]) = WriterT(
    fa.run >>= { case (wa, a) => f(a).run.map { case (wb, b) => (wa |+| wb, b) } })

  def writer[A](w: W, v: A) = WriterT((w -> v).point)
  def listen[A](fa: WriterT[F, W, A]) = WriterT(
    fa.run.map { case (w, a) => (w, (a, w)) })
}
#+END_SRC

The most obvious example is to use =MonadTell= for logging, or audit reporting.
Reusing =Meta= from our error reporting we could imagine creating a log
structure like

#+BEGIN_SRC scala
sealed trait Log
final case class Debug(msg: String)(implicit m: Meta)   extends Log
final case class Info(msg: String)(implicit m: Meta)    extends Log
final case class Warning(msg: String)(implicit m: Meta) extends Log
#+END_SRC

and use =Dequeue[Log]= as our journal type. We could change our OAuth2
=authenticate= method to

#+BEGIN_SRC scala
def debug(msg: String)(implicit m: Meta): Dequeue[Log] = Dequeue(Debug(msg))

def authenticate: F[CodeToken] =
  for {
    callback <- user.start :++> debug("started the webserver")
    params   = AuthRequest(callback, config.scope, config.clientId)
    url      = config.auth.withQuery(params.toUrlQuery)
    _        <- user.open(url) :++> debug(s"user visiting $url")
    code     <- user.stop :++> debug("stopped the webserver")
  } yield code
#+END_SRC

We could even combine this with the =ReaderT= traces and get structured logs.

The caller can recover the logs with =.written= and do something with them.

However, there is a strong argument that logging deserves its own algebra. The
log level is often needed at the point of creation for performance reasons and
writing out the logs is typically managed at the application level rather than
something each component needs to be concerned about.

The =W= in =WriterT= has a =Monoid=, allowing us to journal any kind of
/monoidic/ calculation as a secondary value along with our primary program. For
example, counting the number of times we do something, building up an
explanation of a calculation, or building up a =TradeTemplate= for a new trade
while we price it.

A popular specialisation of =WriterT= is when the monad is =Id=, meaning the
underlying =run= value is just a simple tuple =(W, A)=.

#+BEGIN_SRC scala
type Writer[W, A] = WriterT[Id, W, A]
object WriterT {
  def writer[W, A](v: (W, A)): Writer[W, A] = WriterT[Id, W, A](v)
  def tell[W](w: W): Writer[W, Unit] = WriterT((w, ()))
  ...
}
final implicit class WriterOps[A](self: A) {
  def set[W](w: W): Writer[W, A] = WriterT(w -> self)
  def tell: Writer[A, Unit] = WriterT.tell(self)
}
#+END_SRC

which allows us to let any value carry around a secondary monoidal calculation,
without needing a context =F[_]=.

In a nutshell, =WriterT= / =MonadTell= is how to multi-task in FP.

**** =StateT=

=StateT= lets us =.put=, =.get= and =.modify= a value that is handled by the
monadic context. It is the FP replacement of =var=.

If we were to write an impure method that has access to some mutable state, held
in a =var=, it might have the signature ~() => F[A]~ and return a different
value on every call, breaking referential transparency. With pure FP the
function takes the state as input and returns the updated state as output, which
is why the underlying type of =StateT= is ~S => F[(S, A)]~.

The associated monad is =MonadState=

#+BEGIN_SRC scala
@typeclass trait MonadState[F[_], S] extends Monad[F] {
  def put(s: S): F[Unit]
  def get: F[S]

  def modify(f: S => S): F[Unit] = get >>= (s => put(f(s)))
  ...
}
#+END_SRC

#+BEGIN_ASIDE
=S= must be an immutable type: =.modify= is not an escape hatch to update a
mutable data structure. Mutability is impure and is only allowed within an =IO=
block.
#+END_ASIDE

=StateT= is implemented slightly differently than the monad transformers we have
studied so far. Instead of being a =case class= it is an ADT with two members:

#+BEGIN_SRC scala
sealed abstract class StateT[F[_], S, A]
object StateT {
  def apply[F[_], S, A](f: S => F[(S, A)]): StateT[F, S, A] = Point(f)

  private final case class Point[F[_], S, A](
    run: S => F[(S, A)]
  ) extends StateT[F, S, A]
  private final case class FlatMap[F[_], S, A, B](
    a: StateT[F, S, A],
    f: (S, A) => StateT[F, S, B]
  ) extends StateT[F, S, B]
  ...
}
#+END_SRC

which are a specialised form of =Trampoline=, giving us stack safety when we
want to recover the underlying data structure, =.run=:

#+BEGIN_SRC scala
sealed abstract class StateT[F[_], S, A] {
  def run(initial: S)(implicit F: Monad[F]): F[(S, A)] = this match {
    case Point(f) => f(initial)
    case FlatMap(Point(f), g) =>
      f(initial) >>= { case (s, x) => g(s, x).run(s) }
    case FlatMap(FlatMap(f, g), h) =>
      FlatMap(f, (s, x) => FlatMap(g(s, x), h)).run(initial)
  }
  ...
}
#+END_SRC

=StateT= can straightforwardly implement =MonadState= with its ADT:

#+BEGIN_SRC scala
implicit def monad[F[_]: Applicative, S] = new MonadState[StateT[F, S, ?], S] {
  def point[A](a: =>A) = Point(s => (s, a).point[F])
  def bind[A, B](fa: StateT[F, S, A])(f: A => StateT[F, S, B]) =
    FlatMap(fa, (_, a: A) => f(a))

  def get       = Point(s => (s, s).point[F])
  def put(s: S) = Point(_ => (s, ()).point[F])
}
#+END_SRC

With =.pure= mirrored on the companion as =.stateT=:

#+BEGIN_SRC scala
object StateT {
  def stateT[F[_]: Applicative, S, A](a: A): StateT[F, S, A] = ...
  ...
}
#+END_SRC

and =MonadTrans.liftM= providing the ~F[A] => StateT[F, S, A]~ constructor as
usual.

A common variant of =StateT= is when ~F = Id~, giving the underlying type
signature ~S => (S, A)~. Scalaz provides a type alias and convenience functions
for interacting with the =State= monad transformer directly, and mirroring
=MonadState=:

#+BEGIN_SRC scala
type State[a] = StateT[Id, a]
object State {
  def apply[S, A](f: S => (S, A)): State[S, A] = StateT[Id, S, A](f)
  def state[S, A](a: A): State[S, A] = State((_, a))

  def get[S]: State[S, S] = State(s => (s, s))
  def put[S](s: S): State[S, Unit] = State(_ => (s, ()))
  def modify[S](f: S => S): State[S, Unit] = ...
  ...
}
#+END_SRC

For an example we can return to the business logic tests of
=drone-dynamic-agents=. Recall from Chapter 3 that we created =Mutable= as test
interpreters for our application and we stored the number of =started= and
=stoped= nodes in =var=.

#+BEGIN_SRC scala
class Mutable(state: WorldView) {
  var started, stopped: Int = 0

  implicit val drone: Drone[Id] = new Drone[Id] { ... }
  implicit val machines: Machines[Id] = new Machines[Id] { ... }
  val program = new DynAgents[Id]
}
#+END_SRC

We now know that we can write a much better test simulator with =State=. We'll
take the opportunity to upgrade the accuracy of the simulation at the same time.
Recall that a core domain object is our application's view of the world:

#+BEGIN_SRC scala
final case class WorldView(
  backlog: Int,
  agents: Int,
  managed: NonEmptyList[MachineNode],
  alive: Map[MachineNode, Instant],
  pending: Map[MachineNode, Instant],
  time: Instant
)
#+END_SRC

Since we're writing a simulation of the world for our tests, we can create a
data type that captures the ground truth of everything

#+BEGIN_SRC scala
final case class World(
  backlog: Int,
  agents: Int,
  managed: NonEmptyList[MachineNode],
  alive: Map[MachineNode, Instant],
  started: Set[MachineNode],
  stopped: Set[MachineNode],
  time: Instant
)
#+END_SRC

#+BEGIN_ASIDE
We have not yet rewritten the application to fully make use scalaz data types
and typeclasses, and we are still relying on stdlib collections. There is no
urgency to update as this is straightforward and these types can be used in a
pure FP manner.
#+END_ASIDE

The key difference being that the =started= and =stopped= nodes can be separated
out. Our interpreter can be implemented in terms of =State[World, a]= and we can
write our tests to assert on what both the =World= and =WorldView= looks like
after the business logic has run.

The interpreters, which are mocking out contacting external Drone and Google
services, may be implemented like this:

#+BEGIN_SRC scala
import State.{ get, modify }
object StateImpl {
  type F[a] = State[World, a]

  private val D = new Drone[F] {
    def getBacklog: F[Int] = get.map(_.backlog)
    def getAgents: F[Int]  = get.map(_.agents)
  }

  private val M = new Machines[F] {
    def getAlive: F[Map[MachineNode, Instant]]   = get.map(_.alive)
    def getManaged: F[NonEmptyList[MachineNode]] = get.map(_.managed)
    def getTime: F[Instant]                      = get.map(_.time)

    def start(node: MachineNode): F[Unit] =
      modify(w => w.copy(started = w.started + node))
    def stop(node: MachineNode): F[Unit] =
      modify(w => w.copy(stopped = w.stopped + node))
  }

  val program = new DynAgents[F](D, M)
}
#+END_SRC

and we can rewrite our tests to follow a convention where:

- =world1= is the state of the world before running the program
- =view1= is the application's belief about the world
- =world2= is the state of the world after running the program
- =view2= is the application's belief after running the program

For example,

#+BEGIN_SRC scala
  it should "request agents when needed" in {
    val world1          = World(5, 0, managed, Map(), Set(), Set(), time1)
    val view1           = WorldView(5, 0, managed, Map(), Map(), time1)

    val (world2, view2) = StateImpl.program.act(view1).run(world1)

    view2.shouldBe(view1.copy(pending = Map(node1 -> time1)))
    world2.stopped.shouldBe(world1.stopped)
    world2.started.shouldBe(Set(node1))
  }
#+END_SRC

We would be forgiven for looking back to our business logic loop

#+BEGIN_SRC python
state = initial()
while True:
  state = update(state)
  state = act(state)
#+END_SRC

and use =StateT= to manage the =state=. However, our =DynAgents= business logic
requires only =Applicative= and we would be violating the /Rule of Least Power/
to require the more powerful =MonadState=. It is therefore entirely reasonable
to handle the state manually by passing it in to =update= and =act=.

**** =IndexedStateT=

The code that we have studied thus far is not how scalaz implements =StateT=.
Instead, a type alias points to =IndexedStateT=

#+BEGIN_SRC scala
type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]
#+END_SRC

The implementation of =IndexedStateT= is much as we have studied, with an extra
type parameter allowing the input state =S1= and output state =S2= to differ:

#+BEGIN_SRC scala
sealed abstract class IndexedStateT[F[_], -S1, S2, A] {
  def run(initial: S1)(implicit F: Bind[F]): F[(S2, A)] = ...
  ...
}
object IndexedStateT {
  def apply[F[_], S1, S2, A](
    f: S1 => F[(S2, A)]
  ): IndexedStateT[F, S1, S2, A] = Wrap(f)

  private final case class Wrap[F[_], S1, S2, A](
    run: S1 => F[(S2, A)]
  ) extends IndexedStateT[F, S1, S2, A]
  private final case class FlatMap[F[_], S1, S2, S3, A, B](
    a: IndexedStateT[F, S1, S2, A],
    f: (S2, A) => IndexedStateT[F, S2, S3, B]
  ) extends IndexedStateT[F, S1, S3, B]
  ...
}
#+END_SRC

=IndexedStateT= does not have a =MonadState= when =S1 != S2=, although it has a
=Monad=.

The following example is adapted from [[https://www.youtube.com/watch?v=JPVagd9W4Lo][Index your State]] by Vincent Marquez.
Consider the scenario where we must design an algebraic interface to access a
=key: Int= to =value: String= lookup. This may have a networked implementation
and the order of calls is essential. Our first attempt at the API may look
something like:

#+BEGIN_SRC scala
  trait Cache[F[_]] {
    def read(k: Int): F[Maybe[String]]

    def lock: F[Unit]
    def update(k: Int, v: String): F[Unit]
    def commit: F[Unit]
  }
#+END_SRC

with runtime errors if =.update= or =.commit= is called without a =.lock=. A
more complex design may involve multiple traits and a custom DSL that nobody
remembers how to use.

Instead, we can use =IndexedStateT= to require that the caller is in the correct
state. First we define our possible states as an ADT

#+BEGIN_SRC scala
  sealed abstract class Status
  final case class Ready()                          extends Status
  final case class Locked(on: ISet[Int])            extends Status
  final case class Updated(values: Int ==>> String) extends Status
#+END_SRC

and then revisit our algebra

#+BEGIN_SRC scala
trait Cache[M[_]] {
  type F[in, out, a] = IndexedStateT[M, in, out, a]

  def read(k: Int): F[Ready, Ready, Maybe[String]]
  def readLocked(k: Int): F[Locked, Locked, Maybe[String]]
  def readUncommitted(k: Int): F[Updated, Updated, Maybe[String]]

  def lock: F[Ready, Locked, Unit]
  def update(k: Int, v: String): F[Locked, Updated, Unit]
  def commit: F[Updated, Ready, Unit]
}
#+END_SRC

which will give a compiletime error if we try to =.update= without a =.lock=

#+BEGIN_SRC scala
    for {
      a1 <- C.read(13)
      _  <- C.update(13, "wibble")
      _  <- C.commit
    } yield a1

[error]  found   : IndexedStateT[M,Locked,Ready,Maybe[String]]
[error]  required: IndexedStateT[M,Ready,?,?]
[error]       _  <- C.update(13, "wibble")
[error]          ^
#+END_SRC

but allowing us to construct functions that can be composed by explicitly
including their state:

#+BEGIN_SRC scala
  def wibbleise[M[_]: Monad](C: Cache[M]): F[Ready, Ready, String] =
    for {
      _  <- C.lock
      a1 <- C.readLocked(13)
      a2 = a1.cata(_ + "'", "wibble")
      _  <- C.update(13, a2)
      _  <- C.commit
    } yield a2
#+END_SRC

#+BEGIN_ASIDE
We introduced code duplication in our API when we defined multiple =.read=
operations

#+BEGIN_SRC scala
  def read(k: Int): F[Ready, Ready, Maybe[String]]
  def readLocked(k: Int): F[Locked, Locked, Maybe[String]]
  def readUncommitted(k: Int): F[Updated, Updated, Maybe[String]]
#+END_SRC

Instead of

#+BEGIN_SRC scala
  def read[S <: Status](k: Int): F[S, S, Maybe[String]]
#+END_SRC

The reason we didn't do this is, /because subtyping/. This (broken) code would
compile with the inferred type signature =F[Nothing, Ready, Maybe[String]]=

#+BEGIN_SRC scala
    for {
      a1 <- C.read(13)
      _  <- C.update(13, "wibble")
      _  <- C.commit
    } yield a1
#+END_SRC

Scala has a =Nothing= type which is the subtype of all other types. Thankfully,
this code can not make it to runtime, as it would be impossible to call it, but
it is a bad API since users need to remember to add type ascriptions.

Another approach would be to stop the compiler from inferring =Nothing=. Scalaz
provides implicit evidence to assert that a type is not inferred as =Nothing=
and we can use it instead:

#+BEGIN_SRC scala
def read[S <: Status](k: Int)(implicit NN: NotNothing[S]): F[S, S, Maybe[String]]
#+END_SRC

# automated rewrite proposed in https://github.com/scalacenter/scalafix/issues/668

The choice of which of the three alternative APIs to prefer is left to the
personal taste of the API designer.
#+END_ASIDE

**** =IndexedReaderWriterStateT=

Those wanting to have a combination of ~ReaderT~, ~WriterT~ and ~IndexedStateT~
will not be disappointed. The transformer =IndexedReaderWriterStateT= wraps ~(R,
S1) => F[(W, A, S2)]~ with ~R~ having =Reader= semantics, ~W~ for monoidic
writes, and the ~S~ parameters for indexed state updates.

#+BEGIN_SRC scala
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {
  def run(r: R, s: S1)(implicit F: Monad[F]): F[(W, A, S2)] = ...
  ...
}
object IndexedReaderWriterStateT {
  def apply[F[_], R, W, S1, S2, A](f: (R, S1) => F[(W, A, S2)]) = ...
}

type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]
object ReaderWriterStateT {
  def apply[F[_], R, W, S, A](f: (R, S) => F[(W, A, S)]) = ...
}
#+END_SRC

Abbreviations are provided because otherwise, let's be honest, these types are
so long they look like they are part of a J2EE API:

#+BEGIN_SRC scala
type IRWST[F[_], -R, W, -S1, S2, A] = IndexedReaderWriterStateT[F, R, W, S1, S2, A]
val IRWST = IndexedReaderWriterStateT
type RWST[F[_], -R, W, S, A] = ReaderWriterStateT[F, R, W, S, A]
val RWST = ReaderWriterStateT
#+END_SRC

=IRWST= is a more efficient implementation than a manually created transformer
/stack/ of =ReaderT[WriterT[IndexedStateT[F, ...], ...], ...]=.

**** =TheseT=

=TheseT= allows errors to either abort the calculation or to be accumulated if
there is some partial success. Hence /keep calm and carry on/.

The underlying data type is =F[A \&/ B]= with =A= being the error type,
requiring a =Semigroup= to enable the accumulation of errors.

# https://hackage.haskell.org/package/these-0.7.4/docs/Control-Monad-Chronicle.html#t:ChronicleT

#+BEGIN_SRC scala
final case class TheseT[F[_], A, B](run: F[A \&/ B])
object TheseT {
  def `this`[F[_]: Functor, A, B](a: F[A]): TheseT[F, A, B] = ...
  def that[F[_]: Functor, A, B](b: F[B]): TheseT[F, A, B] = ...
  def both[F[_]: Functor, A, B](ab: F[(A, B)]): TheseT[F, A, B] = ...

  implicit def monad[F[_]: Monad, A: Semigroup] = new Monad[TheseT[F, A, ?]] {
    def bind[B, C](fa: TheseT[F, A, B])(f: B => TheseT[F, A, C]) =
      TheseT(fa.run >>= {
        case This(a) => a.wrapThis[C].point[F]
        case That(b) => f(b).run
        case Both(a, b) =>
          f(b).run.map {
            case This(a_)     => (a |+| a_).wrapThis[C]
            case That(c_)     => Both(a, c_)
            case Both(a_, c_) => Both(a |+| a_, c_)
          }
      })

    def point[B](b: =>B) = TheseT(b.wrapThat.point[F])
  }
}
#+END_SRC

There is no special monad associated with =TheseT=, it is just a regular
=Monad=. If we wish to abort a calculation we can return a =This= value, but we
accumulate errors when we return a =Both= which also contains a successful part
of the calculation.

=TheseT= can also be thought of from a different angle: =A= does not need to be
an /error/. Similarly to =WriterT=, the =A= may be a secondary calculation that
we are computing along with the primary calculation =B=. =TheseT= allows early
exit when something special about =A= demands it, like when Charlie Bucket found
the last golden ticket (=A=) he threw away his chocolate bar (=B=).

**** =ContT=

/Continuation Passing Style/ (CPS) is a style of programming where functions
never return, instead /continuing/ to the next computation. CPS is popular in
Javascript and Lisp as they allow non-blocking I/O via callbacks when data is
available. A direct translation of the pattern into impure Scala looks like

#+BEGIN_SRC scala
def foo[I, A](input: I)(next: A => Unit): Unit = next(doSomeStuff(input))
#+END_SRC

We can make this pure by introducing an =F[_]= context

#+BEGIN_SRC scala
def foo[F[_], I, A](input: I)(next: A => F[Unit]): F[Unit]
#+END_SRC

and refactor to return a function for the provided input

#+BEGIN_SRC scala
def foo[F[_], I, A](input: I): (A => F[Unit]) => F[Unit]
#+END_SRC

=ContT= is just a container for this signature, with a =Monad= instance

#+BEGIN_SRC scala
final case class ContT[F[_], B, A](_run: (A => F[B]) => F[B]) {
  def run(f: A => F[B]): F[B] = _run(f)
}
object IndexedContT {
  implicit def monad[F[_], B] = new Monad[ContT[F, B, ?]] {
    def point[A](a: =>A) = ContT(_(a))
    def bind[A, C](fa: ContT[F, B, A])(f: A => ContT[F, B, C]) =
      ContT(c_fb => fa.run(a => f(a).run(c_fb)))
  }
}
#+END_SRC

and convenient syntax to create a =ContT= from a monadic value:

#+BEGIN_SRC scala
implicit class ContTOps[F[_]: Monad, A](self: F[A]) {
  def cps[B]: ContT[F, B, A] = ContT(a_fb => self >>= a_fb)
}
#+END_SRC

However, the simple callback use of continuations brings nothing to pure
functional programming because we already know how to sequence non-blocking,
potentially distributed, computations: that's what =Monad= is for and we can do
this with =.bind= or a =Kleisli= arrow. To see why continuations are useful we
need to consider a more complex example under a rigid design constraint.

***** Control Flow

Say we have modularised our application into components that can perform I/O,
with each component owned by a different development team:

#+BEGIN_SRC scala
  final case class A0()
  final case class A1()
  final case class A2()
  final case class A3()
  final case class A4()

  def bar0(a4: A4): IO[A0] = ...
  def bar2(a1: A1): IO[A2] = ...
  def bar3(a2: A2): IO[A3] = ...
  def bar4(a3: A3): IO[A4] = ...
#+END_SRC

Our goal is to produce an =A0= given an =A1=. Whereas Javascript and Lisp would
reach for continuations to solve this problem (because the I/O could block) we
can just chain the functions

#+BEGIN_SRC scala
  def simple(a: A1): IO[A0] = bar2(a) >>= bar3 >>= bar4 >>= bar0
#+END_SRC

We can lift =.simple= into its continuation form by using the convenient =.cps=
syntax and a little bit of extra boilerplate for each step:

#+BEGIN_SRC scala
  def foo1(a: A1): ContT[IO, A0, A2] = bar2(a).cps
  def foo2(a: A2): ContT[IO, A0, A3] = bar3(a).cps
  def foo3(a: A3): ContT[IO, A0, A4] = bar4(a).cps

  def flow(a: A1): IO[A0]  = (foo1(a) >>= foo2 >>= foo3).run(bar0)
#+END_SRC

So what does this buy us? Firstly, it's worth noting that the control flow of
this application is left to right

#+BEGIN_SRC dot :cmd dot :file images/contt-simple.png :exports results
digraph G {
    graph [dpi=100,rankdir=LR];
    node [fontname=Hack];
    edge [fontname=Hack];
    fontname=Hack;
    compound=true;

    start [shape=point,width=0.1]
    end [shape=point,width=0.1]

    subgraph cluster_foo1 {
      label="foo1";
      bar2 [shape=rectangle];
    }
    subgraph cluster_foo2 {
      label="foo2";
      bar3 [shape=rectangle];
    }
    subgraph cluster_foo3 {
      label="foo3";
      bar4 [shape=rectangle];
    }
    bar0 [shape=rectangle];

    start -> bar2 [label="a1"]
    bar2 -> bar3 [label="a2"];
    bar3 -> bar4 [label="a3"];
    bar4 -> bar0 [label="a4"];
    bar0 -> end [label="a0"];
}
#+End_SRC

#+CAPTION: 60
#+RESULTS:
[[file:images/contt-simple.png]]

What if we are the authors of =foo2= and we want to post-process the =a0= that
we receive from the right (downstream), i.e. we want to split our =foo2= into
=foo2a= and =foo2b=

#+BEGIN_SRC dot :cmd dot :file images/contt-process1.png :exports results
digraph G {
    graph [dpi=100,rankdir=LR];
    node [fontname=Hack];
    edge [fontname=Hack];
    fontname=Hack;
    compound=true;

    start [shape=point,width=0.1]
    end [shape=point,width=0.1]

    subgraph cluster_foo1 {
      label="foo1";
      bar2 [shape=rectangle];
    }
    subgraph cluster_foo2a {
      label="foo2a";
      bar3 [shape=rectangle];
    }
    subgraph cluster_foo3 {
      label="foo3";
      bar4 [shape=rectangle];
    }
    subgraph cluster_foo2b {
      label="foo2b";
      process [shape=rectangle];
    }
    bar0 [shape=rectangle];

    start -> bar2 [label="a1"]
    bar2 -> bar3 [label="a2"];
    bar3 -> bar4 [label="a3"];
    bar4 -> bar0 [label="a4"];
    bar0 -> process [label="a0"];
    process -> end [label="a0"];
}
#+End_SRC

#+CAPTION: 75
#+RESULTS:
[[file:images/contt-process1.png]]

Let's *add the constraint that we cannot change the definition of =flow= or
=bar0=*, perhaps it is not our code and is defined by the framework we are
using.

It is not possible to process the output of =a0= by modifying any of the
remaining =barX= methods. However, with =ContT= we can modify =foo2= to process
the result of the =next= continuation:

#+BEGIN_SRC dot :cmd dot :file images/contt-process2.png :exports results
digraph G {
    graph [dpi=100,rankdir=LR];
    node [fontname=Hack];
    edge [fontname=Hack];
    fontname=Hack;
    #compound=true;
    #overlap = false;

    start [shape=point,width=0.1]

    subgraph cluster_foo1 {
      label="foo1";
      bar2 [shape=rectangle];
    }
    subgraph cluster_foo2 {
      label="foo2";
      bar3 [shape=rectangle];
      process [shape=rectangle];
    }
    subgraph cluster_foo3 {
      label="foo3";
      bar4 [shape=rectangle];
    }

    bar0 [shape=rectangle];
    end [shape=point,width=0.1];

    start -> bar2 [label="a1"]
    bar2 -> bar3 [label="a2"];
    bar3:e -> bar4:w [label="a3"];
    bar4:s -> bar0:s [label="a4"];
    bar0 -> process [label="a0"];

    process:e -> end:w [label="a0"];

    # pushes end one out to the right
    hidden1 [style=invis];
    hidden1 -> end [style=invis];
}
#+End_SRC

#+CAPTION: 45
#+RESULTS:
[[file:images/contt-process2.png]]

Which can be defined with

#+BEGIN_SRC scala
  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =>
    for {
      a3  <- bar3(a)
      a0  <- next(a3)
    } yield process(a0)
  }
#+END_SRC

We are not limited to =.map= over the return value, we can =.bind= into another
control flow turning the linear flow into a graph!

#+BEGIN_SRC dot :cmd dot :file images/contt-elsewhere.png :exports results
digraph G {
    graph [dpi=100,rankdir=LR];
    node [fontname=Hack];
    edge [fontname=Hack];
    fontname=Hack;
    #compound=true;
    #overlap = false;

    start [shape=point,width=0.1]

    subgraph cluster_foo1 {
      label="foo1";
      bar2 [shape=rectangle];
    }
    subgraph cluster_foo2 {
      label="foo2";
      bar3 [shape=rectangle];
      check [shape=rectangle];
      # cheating by hiding another bar0 to keep it tidy
    }
    subgraph cluster_foo3 {
      label="foo3";
      bar4 [shape=rectangle];
    }
    subgraph cluster_elsewhere {
      label="elsewhere";
      elsewhere [label="???",shape=rectangle];
    }

    bar0 [label="bar0",shape=rectangle];
    end [shape=point,width=0.1];

    start -> bar2 [label="a1"];
    bar2 -> bar3 [label="a2"];
    bar3 -> bar4 [label="a3"];
    bar4 -> bar0 [label="a4"];

    # don't show the label, it's noisy
    bar0 -> check; #[label="a0"];
    check -> end [label="a0"];
    check -> elsewhere;
    elsewhere -> end [label="a0"];

    # pushes end one out to the right
    bar2 -> bar0 [style=invis];
#    hidden1 [style=invis];
#    hidden1 -> end [style=invis];
#    hidden1 -> hidden2 [style=invis];
#    hidden2 [style=invis];
#    hidden2 -> bar0 [style=invis];
}
#+End_SRC

#+CAPTION: 50
#+RESULTS:
[[file:images/contt-elsewhere.png]]

#+BEGIN_SRC scala
  def elsewhere: ContT[IO, A0, A4] = ???
  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =>
    for {
      a3  <- bar3(a)
      a0  <- next(a3)
      a0_ <- if (check(a0)) a0.pure[IO]
             else elsewhere.run(bar0)
    } yield a0_
  }
#+END_SRC

Or we can stay within the original flow and retry everything downstream

#+BEGIN_SRC dot :cmd dot :file images/contt-retry.png :exports results
digraph G {
    graph [dpi=100,rankdir=LR];
    node [fontname=Hack];
    edge [fontname=Hack];
    fontname=Hack;
    #compound=true;
    #overlap = false;

    start [shape=point,width=0.1]

    subgraph cluster_foo1 {
      label="foo1";
      bar2 [shape=rectangle];
    }
    subgraph cluster_foo2 {
      label="foo2";
      bar3 [shape=rectangle];
      check [shape=rectangle];
      # cheating by hiding another bar0 to keep it tidy
    }
    subgraph cluster_foo3 {
      label="foo3";
      bar4 [shape=rectangle];
    }

    bar0 [label="bar0",shape=rectangle];
    end [shape=point,width=0.1];

    start -> bar2 [label="a1"];
    bar2 -> bar3 [label="a2"];
    bar3 -> bar4 [label="a3"];
    bar4 -> bar0 [label="a4"];

    bar0 -> check; #[label="a0"];
    check -> end [label="a0"];
    check -> bar4 [label="a3"];

    # pushes end one out to the right
    bar2 -> bar0 [style=invis];
}
#+End_SRC

#+CAPTION: 45
#+RESULTS:
[[file:images/contt-retry.png]]

#+BEGIN_SRC scala
  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =>
    for {
      a3  <- bar3(a)
      a0  <- next(a3)
      a0_ <- if (check(a0)) a0.pure[IO]
             else next(a3)
    } yield a0_
  }
#+END_SRC

This is just one retry, not an infinite loop. For example, we might want
downstream to reconfirm a potentially dangerous action.

Finally, we can perform actions that are specific to the context of the =ContT=,
in this case =IO= which lets us do error handling and resource cleanup:

#+BEGIN_SRC scala
  def foo2(a: A2): ContT[IO, A0, A3] = bar3(a).ensuring(cleanup).cps
#+END_SRC

***** When to Order Spaghetti

It is not an accident that these diagrams look like spaghetti, that's just what
happens when we start messing with control flow. All the mechanisms we've
discussed in this section are simple to implement directly if we can edit the
definition of =flow=, therefore we do not typically need to use =ContT=.

However, if we are designing a framework, we should consider exposing the plugin
system as =ContT= callbacks to allow our users more power over their control
flow. Sometimes the customer just really wants the spaghetti.

For example, if the Scala compiler was written using CPS, it would allow for a
principled approach to communication between compiler phases. A compiler plugin
would be able to perform some action based on the inferred type of an
expression, computed at a later stage in the compile. Similarly, continuations
would be a good API for an extensible build tool or text editor.

# https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf

A caveat with =ContT= is that it is not stack safe, so cannot be used for
programs that run forever.

***** Great, kid. Don't get =ContT=.

A more complex variant of ~ContT~ called ~IndexedContT~ wraps ~(A => F[B]) =>
F[C]~. The new type parameter ~C~ allows the return type of the entire
computation to be different to the return type between each component. But if
~B~ is not equal to ~C~ then there is no ~Monad~.

Not missing an opportunity to generalise as much as possible, =IndexedContT= is
actually implemented in terms of an even more general structure (note the extra
=s= before the =T=)

#+BEGIN_SRC scala
final case class IndexedContsT[W[_], F[_], C, B, A](_run: W[A => F[B]] => F[C])

type IndexedContT[f[_], c, b, a] = IndexedContsT[Id, f, c, b, a]
type ContT[f[_], b, a]           = IndexedContsT[Id, f, b, b, a]
type ContsT[w[_], f[_], b, a]    = IndexedContsT[w, f, b, b, a]
type Cont[b, a]                  = IndexedContsT[Id, Id, b, b, a]
#+END_SRC

where =W[_]= has a =Comonad=, and =ContT= is actually implemented as a type
alias. Companion objects exist for these type aliases with convenient
constructors.

Admittedly, five type parameters is perhaps a generalisation too far. But then
again, over-generalisation is consistent with the sensibilities of
continuations.

# https://github.com/scalaz/scalaz/issues/1737
# http://www.haskellforall.com/2012/12/the-continuation-monad.html

**** Transformer Stacks and Ambiguous Implicits

This concludes our tour of the monad transformers in scalaz.

When multiple transformers are combined, we call this a /transformer stack/ and
although it is verbose, it is possible to read off the features by reading the
transformers. For example if we construct an =F[_]= context which is a set of
composed transformers, such as

#+BEGIN_SRC scala
type Ctx[A] = StateT[EitherT[IO, E, ?], S, A]
#+END_SRC

we know that we are adding error handling with error type =E= (there is a
=MonadError[Ctx, E]=) and we are managing state =A= (there is a =MonadState[Ctx,
S]=).

But there are unfortunately practical drawbacks to using monad transformers and
their companion =Monad= typeclasses:

1. Multiple implicit =Monad= parameters mean that the compiler cannot find the
   correct syntax to use for the context.

2. Monads do not compose in the general case, which means that the order of
   nesting of the transformers is important.

3. All the interpreters must be lifted into the common context. For example, we
   might have an implementation of some algebra that uses for =IO= and now we
   need to wrap it with =StateT= and =EitherT= even though they are unused
   inside the interpreter.

4. There is a performance cost associated to each layer. And some monad
   transformers are worse than others. =StateT= is particularly bad but even
   =EitherT= can cause memory allocation problems for high throughput
   applications.

Let's talk about workarounds.

***** No Syntax

Let's say we have an algebra

#+BEGIN_SRC scala
trait Lookup[F[_]] {
  def look: F[Int]
}
#+END_SRC

and some data types

#+BEGIN_SRC scala
final case class Problem(bad: Int)
final case class Table(last: Int)
#+END_SRC

that we want to use in our business logic

#+BEGIN_SRC scala
  def foo[F[_]](L: Lookup[F])(
    implicit
      E: MonadError[F, Problem],
      S: MonadState[F, Table]
  ): F[Int] = for {
    old <- S.get
    i   <- L.look
    _   <- if (i === old.last) E.raiseError(Problem(i))
           else ().pure[F]
  } yield i
#+END_SRC

The first problem we encounter is that this fails to compile

#+BEGIN_SRC
[error] value flatMap is not a member of type parameter F[Table]
[error]     old <- S.get
[error]              ^
#+END_SRC

There are some tactical solutions to this problem. The most obvious is to make
all the parameters explicit

#+BEGIN_SRC scala
  def foo1[F[_]: Monad](
    L: Lookup[F],
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = ...
#+END_SRC

and require only =Monad= to be passed implicitly via context bounds. However,
this means that we must manually wire up the =MonadError= and =MonadState= when
calling =foo1= and when calling out to another method that requires an
=implicit=.

A second solution is to leave the parameters =implicit= and use name shadowing
to make all but one of the parameters explicit. This allows upstream to use
implicit resolution when calling us but we still need to pass parameters
explicitly if we call out.

#+BEGIN_SRC scala
  @inline final def shadow[A, B, C](a: A, b: B)(f: (A, B) => C): C = f(a, b)

  def foo2a[F[_]: Monad](L: Lookup[F])(
    implicit
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = shadow(E, S) { (E, S) => ...
#+END_SRC

or we could shadow just one =Monad=, leaving the other one to provide our syntax
and to be available for when we call out to other methods

#+BEGIN_SRC scala
  @inline final def shadow[A, B](a: A)(f: A => B): B = f(a)
  ...

  def foo2b[F[_]](L: Lookup[F])(
    implicit
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = shadow(E) { E => ...
#+END_SRC

A third option, with a higher up-front cost, is to create a custom =Monad=
typeclass that holds =implicit= references to the two =Monad= classes that we
care about

#+BEGIN_SRC scala
trait MonadErrorState[F[_], E, S] {
  implicit def E: MonadError[F, E]
  implicit def S: MonadState[F, S]
}
#+END_SRC

and a derivation of the typeclass given a =MonadError= and =MonadState=

#+BEGIN_SRC scala
object MonadErrorState {
  implicit def create[F[_], E, S](
    implicit
      E0: MonadError[F, E],
      S0: MonadState[F, S]
  ) = new MonadErrorState[F, E, S] {
    def E: MonadError[F, E] = E0
    def S: MonadState[F, S] = S0
  }
}
#+END_SRC

Now if we want access to =S= or =E= we get them via =F.S= or =F.E=

#+BEGIN_SRC scala
  def foo3a[F[_]: Monad](L: Lookup[F])(
    implicit F: MonadErrorState[F, Problem, Table]
  ): F[Int] =
    for {
      old <- F.S.get
      i   <- L.look
      _ <- if (i === old.last) F.E.raiseError(Problem(i))
      else ().pure[F]
    } yield i
#+END_SRC

Like the second solution, we can choose one of the =Monad= instances to be
=implicit= within the block, achieved by importing it

#+BEGIN_SRC scala
  def foo3b[F[_]](L: Lookup[F])(
    implicit F: MonadErrorState[F, Problem, Table]
  ): F[Int] = {
    import F.E
    ...
  }
#+END_SRC

***** Composing Transformers

An =EitherT[StateT[...], ...]= has a =MonadError= but does not have a
=MonadState=, whereas =StateT[EitherT[...], ...]= can provide both.

The workaround is to study the implicit derivations on the companion of the
transformers and to make sure that the outer most transformer provides
everything we need.

A rule of thumb is that more complex transformers go on the outside, with this
chapter presenting transformers in increasing order of complex.

***** Lifting Interpreters

Continuing the same example, let's say our =Lookup= algebra has an =IO=
interpreter

#+BEGIN_SRC scala
object LookupRandom extends Lookup[IO] {
  def look: IO[Int] = IO { util.Random.nextInt }
}
#+END_SRC

but we want our context to be

#+BEGIN_SRC scala
type Ctx[A] = StateT[EitherT[IO, Problem, ?], Table, A]
#+END_SRC

to give us a =MonadError= and a =MonadState=. This means we need to wrap
=LookupRandom= to operate over =Ctx=.

#+BEGIN_ASIDE
The odds of getting the types correct on the first attempt are approximately
3,720 to one.
#+END_ASIDE

Firstly, we want to make use of the =.liftM= syntax on =Monad=, which uses
=MonadTrans= to lift from our starting =F[A]= into =G[F, A]=

#+BEGIN_SRC scala
final class MonadOps[F[_]: Monad, A](fa: F[A]) {
  def liftM[G[_[_], _]: MonadTrans]: G[F, A] = ...
  ...
}
#+END_SRC

It is important to realise that the type parameters to =.liftM= have two type
holes, one of shape =_[_]= and another of shape =_=. If we create type aliases
of this shape

#+BEGIN_SRC scala
  type Ctx0[F[_], A] = StateT[EitherT[F, Problem, ?], Table, A]
  type Ctx1[F[_], A] = EitherT[F, Problem, A]
  type Ctx2[F[_], A] = StateT[F, Table, A]
#+END_SRC

We can abstract over =MonadTrans= to lift a =Lookup[F]= to any =Lookup[G[F, ?]]=
where =G= is a Monad Transformer:

#+BEGIN_SRC scala
  def liftM[F[_]: Monad, G[_[_], _]: MonadTrans](f: Lookup[F]) =
    new Lookup[G[F, ?]] {
      def look: G[F, Int] = f.look.liftM[G]
    }
#+END_SRC

Allowing us to wrap once for =EitherT=, and then again for =StateT=

#+BEGIN_SRC scala
  val wrap1 = Lookup.liftM[IO, Ctx1](LookupRandom)
  val wrap2: Lookup[Ctx] = Lookup.liftM[EitherT[IO, Problem, ?], Ctx2](wrap1)
#+END_SRC

Another way to achieve this, in a single step, is to use =MonadIO= which enables
lifting an =IO= into a transformer stack:

#+BEGIN_SRC scala
@typeclass trait MonadIO[F[_]] extends Monad[F] {
  def liftIO[A](ioa: IO[A]): F[A]
}
#+END_SRC

with =MonadIO= instances for all the common combinations of transformers.

The boilerplate overhead to lift an =IO= interpreter to anything with a
=MonadIO= instance is therefore two lines of code (for the interpreter
definition), plus one line per element of the algebra, and a final line to call
it:

#+BEGIN_SRC scala
  def liftIO[F[_]: MonadIO](io: Lookup[IO]) = new Lookup[F] {
    def look: F[Int] = io.look.liftIO[F]
  }

  val L: Lookup[Ctx] = Lookup.liftIO(LookupRandom)
#+END_SRC

#+BEGIN_ASIDE
A compiler plugin that automatically produces the =.liftM= and =.liftIO= would
be a great contribution to the ecosystem! A work in progress can be seen at
https://gitlab.com/fommil/scalaz-free and welcomes contributors.
#+END_ASIDE

# https://github.com/kailuowang/mainecoon is almost what we need, but not quite

# From Fabio
# https://hackage.haskell.org/package/layers-0.1/docs/Documentation-Layers-Overview.html

***** Performance

The biggest problem with Monad Transformers is their performance overhead.
=EitherT= has a reasonably low overhead, with every =.flatMap= call generating a
handful of objects, but this can impact high throughput applications where every
object allocation matters. Other transformers, such as =StateT=, effectively add
a trampoline, and =ContT= keeps the entire call-chain retained in memory.

#+BEGIN_ASIDE
Your application might not care about allocations if it is bounded by network or
I/O. Always measure.
#+END_ASIDE

If performance becomes a problem, the solution is to not use Monad Transformers.
At least not the transformer data structures. A big advantage of the =Monad=
typeclasses, like =MonadState= is that we can create an optimised =F[_]= for our
application that provides the typeclasses naturally. We will learn how to create
an optimal =F[_]= over the next two chapters, when we deep dive into two
structures which we have already seen: =Free= and =IO=.

*** A Free Lunch

# You are free to use any methods necessary, but I want them alive.
# Jabba! This is your last chance. Free us or die.
# But these are my friends. Threepio, tell them they must be set free.

Our industry craves safe high-level languages, trading developer efficiency and
reliability for reduced runtime performance.

The Just In Time (JIT) compiler on the JVM performs so well that simple
functions can have comparable performance to their C or C++ equivalents,
ignoring the cost of garbage collection. However, the JIT only performs /low
level optimisations/: branch prediction, inlining methods, unrolling loops, and
so on.

The JIT does not perform optimisations of our business logic, for example
batching network calls or parallelising independent tasks. The developer is
responsible for writing the business logic and optimisations at the same time,
reducing readability and making it harder to maintain. It would be good if
optimisation was a tangential concern.

If instead, we have a data structure that describes our business logic in terms
of high level concepts, not machine instructions, we can perform /high level
optimisation/. Data structures of this nature are typically called /Free/
structures and can be generated for free for the members of the algebraic
interfaces of our program. For example, a /Free Applicative/ can be generated
that allows us to batch or de-duplicate expensive network I/O.

In this section we will learn how to create free structures, and how they can be
used.

**** =Free= (=Monad=)

Fundamentally, a monad describes a sequential program where every step depends
on the previous one. We are therefore limited to modifications that only know
about things that we've already run and the next thing we are going to run.

#+BEGIN_ASIDE
It was trendy, circa 2015, to write FP programs in terms of =Free= so this is as
much an exercise in how to understand =Free= code as it is to be able to write
or use it.

There is a lot of boilerplate to create a free structure. We shall use this
study of =Free= to learn how to generate the boilerplate, which we will reuse
for the other free structures.
#+END_ASIDE

As a refresher, =Free= is the data structure representation of a =Monad= and is
defined by three members

#+BEGIN_SRC scala
sealed abstract class Free[S[_], A] {
  def mapSuspension[T[_]](f: S ~> T): Free[T, A] = ...
  def foldMap[M[_]: Monad](f: S ~> M): M[A] = ...
  ...
}
object Free {
  implicit def monad[S[_], A]: Monad[Free[S, A]] = ...

  private final case class Suspend[S[_], A](a: S[A]) extends Free[S, A]
  private final case class Return[S[_], A](a: A)     extends Free[S, A]
  private final case class Gosub[S[_], A0, B](
    a: Free[S, A0],
    f: A0 => Free[S, B]
  ) extends Free[S, B] { type A = A0 }

  def liftF[S[_], A](value: S[A]): Free[S, A] = Suspend(value)
  ...
}
#+END_SRC

- =Suspend= represents a program that has not yet been interpreted
- =Return= is =.pure=
- =Gosub= is =.bind=

A =Free[S, A]= can be /freely generated/ for any algebra =S=. To make this
explicit, consider our application's =Machines= algebra

#+BEGIN_SRC scala
trait Machines[F[_]] {
  def getTime: F[Instant]
  def getManaged: F[NonEmptyList[MachineNode]]
  def getAlive: F[Map[MachineNode, Instant]]
  def start(node: MachineNode): F[Unit]
  def stop(node: MachineNode): F[Unit]
}
#+END_SRC

We define a freely generated =Free= for =Machines= by creating a GADT with a
data type for each element of the algebra. Each data type has the same input
parameters as its corresponding element, is parameterised over the return type,
and has the same name:

#+BEGIN_SRC scala
object Machines {
  sealed abstract class Ast[A]
  final case class GetTime()                extends Ast[Instant]
  final case class GetManaged()             extends Ast[NonEmptyList[MachineNode]]
  final case class GetAlive()               extends Ast[Map[MachineNode, Instant]]
  final case class Start(node: MachineNode) extends Ast[Unit]
  final case class Stop(node: MachineNode)  extends Ast[Unit]
  ...
#+END_SRC

The GADT defines an Abstract Syntax Tree (AST) because each member is
representing a computation in a program.

#+BEGIN_WARNING
The freely generated =Free= for =Machines= is =Free[Machines.Ast, ?]=, i.e. for
the AST, not =Free[Machines, ?]=. It is easy to make a mistake, since the latter
will compile, but is meaningless.
#+END_WARNING

We then define =.liftF=, an implementation of =Machines=, with =Free[Ast, ?]= as
the context. Every method simply delegates to =Free.liftT= to create a =Suspend=

#+BEGIN_SRC scala
  ...
  def liftF = new Machines[Free[Ast, ?]] {
    def getTime = Free.liftF(GetTime())
    def getManaged = Free.liftF(GetManaged())
    def getAlive = Free.liftF(GetAlive())
    def start(node: MachineNode) = Free.liftF(Start(node))
    def stop(node: MachineNode) = Free.liftF(Stop(node))
  }
}
#+END_SRC

When we construct our program, parameterised over a =Free=, we run it by
providing an /interpreter/ (a natural transformation =Ast ~> M=) to the
=.foldMap= method. For example, if we could provide an interpreter that maps to
=IO= we can construct an =IO[Unit]= program via the free AST

#+BEGIN_SRC scala
def program[F[_]: Monad](M: Machines[F]): F[Unit] = ...

val interpreter: Machines.Ast ~> IO = ...

val app: IO[Unit] = program[Free[Machines.Ast, ?]](Machines.liftF)
                      .foldMap(interpreter)
#+END_SRC

For completeness, an interpreter that delegates to a direct implementation is
easy to write. This might be useful if the rest of the application is using
=Free= as the context and we already have an =IO= implementation that we want to
use:

#+BEGIN_SRC scala
  def interpreter[F[_]](f: Machines[F]): Ast ~> F = λ[Ast ~> F] {
    case GetTime()    => f.getTime
    case GetManaged() => f.getManaged
    case GetAlive()   => f.getAlive
    case Start(node)  => f.start(node)
    case Stop(node)   => f.stop(node)
  }
#+END_SRC

But our business logic needs more than just =Machines=, we also need access to
the =Drone= algebra, recall defined as

#+BEGIN_SRC scala
trait Drone[F[_]] {
  def getBacklog: F[Int]
  def getAgents: F[Int]
}
object Drone {
  sealed abstract class Ast[A]
  ...
  def liftF = ...
  def interpreter = ...
}
#+END_SRC

What we want is for our AST to be a combination of the =Machines= and =Drone=
ASTs. We studied =Coproduct= in Chapter 6, a higher kinded disjunction:

#+BEGIN_SRC scala
final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A])
#+END_SRC

Now we can use the context =Free[Coproduct[Machines.Ast, Drone.Ast, ?], ?]=.

We could manually create the coproduct but we would be swimming in boilerplate,
and we'd have to do it all again if we wanted to add a third algebra.

The =scalaz.Inject= typeclass helps:

#+BEGIN_SRC scala
type :<:[F[_], G[_]] = Inject[F, G]
sealed abstract class Inject[F[_], G[_]] {
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}
object Inject {
  implicit def left[F[_], G[_]]: F :<: Coproduct[F, G, ?]] = ...
  ...
}
#+END_SRC

The =implicit= derivations generate =Inject= instances when we need them,
letting us rewrite our =liftF= to work for any combination of ASTs:

#+BEGIN_SRC scala
  def liftF[F[_]](implicit I: Ast :<: F) = new Machines[Free[F, ?]] {
    def getTime                  = Free.liftF(I.inj(GetTime()))
    def getManaged               = Free.liftF(I.inj(GetManaged()))
    def getAlive                 = Free.liftF(I.inj(GetAlive()))
    def start(node: MachineNode) = Free.liftF(I.inj(Start(node)))
    def stop(node: MachineNode)  = Free.liftF(I.inj(Stop(node)))
  }
#+END_SRC

It is nice that =F :<: G= reads as if our =Ast= is a member of the complete =F=
instruction set: this syntax is intentional.

#+BEGIN_ASIDE
A compiler plugin that automatically produces the =scalaz.Free= boilerplate
would be a great contribution to the ecosystem! Not only is it painful to write
the boilerplate, but there is the potential for a typo to ruin our day: if two
members of the algebra have the same type signature, we might not notice.
#+END_ASIDE

Putting it all together, lets say we have a program that we wrote abstracting over =Monad=

#+BEGIN_SRC scala
def program[F[_]: Monad](M: Machines[F], D: Drone[F]): F[Unit] = ...
#+END_SRC

and we have some existing implementations of =Machines= and =Drone=, we can
create interpreters from them:

#+BEGIN_SRC scala
val MachinesIO: Machines[IO] = ...
val DroneIO: Drone[IO]       = ...

val M: Machines.Ast ~> IO = Machines.interpreter(MachinesIO)
val D: Drone.Ast ~> IO    = Drone.interpreter(DroneIO)
#+END_SRC

and combine them into the larger instruction set using a convenience method from
the =NaturalTransformation= companion

#+BEGIN_SRC scala
object NaturalTransformation {
  def or[F[_], G[_], H[_]](fg: F ~> G, hg: H ~> G): Coproduct[F, H, ?] ~> G = ...
  ...
}

type Ast[a] = Coproduct[Machines.Ast, Drone.Ast, a]

val interpreter: Ast ~> IO = NaturalTransformation.or(M, D)
#+END_SRC

Then use it to produce an =IO=

#+BEGIN_SRC scala
val app: IO[Unit] = program[Free[Ast, ?]](Machines.liftF, Drone.liftF)
                      .foldMap(interpreter)
#+END_SRC

# https://github.com/scalaz/scalaz/pull/1753

But we've gone in circles! We could have used =IO= as the context for our
program in the first place and avoided =Free=. So why did we put ourselves
through all this pain? Let's see some reasons why =Free= might be useful.

***** Testing: Mocks and Stubs

It might sound hypocritical to propose that =Free= can be used to reduce
boilerplate, given how much code we have written. However, there is a tipping
point where the =Ast= pays for itself when we have many tests that require stub
implementations.

If the =.Ast= and =.liftF= is defined for an algebra, we can create /partial
interpreters/

#+BEGIN_SRC scala
    val M: Machines.Ast ~> Id = stub[Map[MachineNode, Instant]] {
      case Machines.GetAlive() => Map.empty
    }
    val D: Drone.Ast ~> Id = stub[Int] {
      case Drone.GetBacklog() => 1
    }
#+END_SRC

which can be used to test our =program=

#+BEGIN_SRC scala
    program[Free[Ast, ?]](Machines.liftF, Drone.liftF)
      .foldMap(or(M, D))
      .shouldBe(1)
#+END_SRC

By using partial functions, and not total functions, we are exposing ourselves
to runtime errors. Many teams are happy to accept this risk in their unit tests
since the test would fail if there is a programmer error.

Arguably we could also achieve the same thing with implementations of our
algebras that implement every method with =???=, overriding what we need on a
case by case basis.

#+BEGIN_ASIDE
The library [[https://github.com/djspiewak/smock][smock]] is more powerful, but for the purposes of this short example
we can define =stub= ourselves using a type inference trick that can be found
all over the scalaz source code. The reason for =Stub= being a separate class is
so that we only need to provide the =A= type parameter, with =F= and =G=
inferred from the left hand side of the expression:

#+BEGIN_SRC scala
object Mocker {
  final class Stub[A] {
    def apply[F[_], G[_]](pf: PartialFunction[F[A], G[A]]): F ~> G = new (F ~> G) {
      def apply[α](fa: F[α]) = pf.asInstanceOf[PartialFunction[F[α], G[α]]](fa)
    }
  }
  def stub[A]: Stub[A] = new Stub[A]
}
#+END_SRC
#+END_ASIDE

***** Monitoring

It is typical for server applications to be monitored by runtime agents that
manipulate bytecode to insert profilers and extract various kinds of usage or
performance information.

If our application's context is =Free=, we do not need to resort to bytecode
manipulation, we can instead implement a side-effecting monitor as an
interpreter that we have complete control over.

#+BEGIN_ASIDE
Runtime introspection is one of the few cases that can justify use of a
side-effect. If the monitoring is not visible to the program itself, referential
transparency will still hold. This is also the argument used by teams that use
side-effecting debug logging, and our argument for allowing mutation in the
implementation of =Memo=.
#+END_ASIDE

For example, consider using this =Ast ~> Ast= "agent"

#+BEGIN_SRC scala
    val Monitor = λ[Demo.Ast ~> Demo.Ast](
      _.run match {
        case \/-(m @ Drone.GetBacklog()) =>
          JmxAbstractFactoryBeanSingletonProviderUtilImpl.count("backlog")
          Coproduct.rightc(m)
        case other =>
          Coproduct(other)
      }
    )
#+END_SRC

which records method invocations: we would use a vendor-specific routine in real
code. We could also watch for specific messages of interest and log them as a
debugging aid.

We can attach =Monitor= to our production =Free= application with

#+BEGIN_SRC scala
.mapSuspension(Monitor).foldMap(interpreter)
#+END_SRC

or combine the natural transformations and run with a single

#+BEGIN_SRC scala
.foldMap(Monitor.andThen(interpreter))
#+END_SRC

***** Monkey Patching: Part 1

As engineers, we know that our business users often ask for bizarre workarounds
to be added to the core logic of the application. We might want to codify such
corner cases as /exceptions to the rule/ and handle them tangentially to our
core logic.

For example, suppose we get a memo from accounting telling us

#+BEGIN_QUOTE
/URGENT: Bob is using node =#c0ffee= to run the year end. DO NOT STOP THIS
MACHINE!1!/
#+END_QUOTE

There is no possibility to discuss why Bob shouldn't be using our machines for
his super-important accounts, so we have to hack our business logic and put out
a release to production as soon as possible.

Our monkey patch can map into a =Free= structure, allowing us to return a
pre-canned result (=Free.pure=) instead of scheduling the instruction. We
special case the instruction in a custom natural transformation with its return
value:

#+BEGIN_SRC scala
    val monkey = λ[Machines.Ast ~> Free[Machines.Ast, ?]] {
      case Machines.Stop(MachineNode("#c0ffee")) => Free.pure(())
      case other                                 => Free.liftF(other)
    }
#+END_SRC

eyeball that it works, push it to prod, and set an alarm for next week to remind
us to remove it, and revoke Bob's access to our servers.

Our unit test could use =State= as the target context, so we can keep track of
all the nodes we stopped:

#+BEGIN_SRC scala
    type S = Set[MachineNode]
    val M: Machines.Ast ~> State[S, ?] = Mocker.stub[Unit] {
      case Machines.Stop(node) => State.modify[S](_ + node)
    }

    Machines
      .liftF[Machines.Ast]
      .stop(MachineNode("#c0ffee"))
      .foldMap(monkey)
      .foldMap(M)
      .exec(Set.empty)
      .shouldBe(Set.empty)
#+END_SRC

along with a test that "normal" nodes are not affected.

An advantage of using =Free= to avoid stopping the =#c0ffee= nodes is that we
can be sure to catch all the usages instead of having to go through the business
logic and look for all usages of =.stop=. If our application context is just an
=IO= we could, of course, implement this logic in the =Machines[IO]=
implementation but an advantage of using =Free= is that we don't need to touch
the existing code and can instead isolate and test this (temporary) behaviour,
without being tied to the =IO= implementations.

***** Monkey Patching: Part 2

Infrastructure sends a memo:

#+BEGIN_QUOTE
/To meet the CEO's vision for this quarter, we are on a cost rationalisation and
reorientation initiative./

/Therefore, we paid Google a million dollars to develop a Batch API so we can
start nodes more cost effectively./

/PS: Your bonus depends on using the new API./
#+END_QUOTE

When we monkey patch, we are not limited to the original instruction set: we can
introduce new ASTs. Rather than change our core business logic, we might decide
to /translate/ existing instructions into an extended set, introducing =Batch=:

#+BEGIN_SRC scala
trait Batch[F[_]] {
  def start(nodes: NonEmptyList[MachineNode]): F[Unit]
}
object Batch {
  sealed abstract class Ast[A]
  ...
  def liftF = ...
}
#+END_SRC

Let's first set up a test for a simple program by defining the AST and target
type:

#+BEGIN_SRC scala
    type Orig[a] = Coproduct[Machines.Ast, Drone.Ast, a]
    type T[a]    = State[S, a]
#+END_SRC

We track the started nodes in a data container so we can assert on them later

#+BEGIN_SRC scala
    final case class S(
      singles: IList[MachineNode],
      batches: IList[NonEmptyList[MachineNode]]
    ) {
      def addSingle(node: MachineNode) = S(node :: singles, batches)
      def addBatch(nodes: NonEmptyList[MachineNode]) = S(singles, nodes :: batches)
    }
#+END_SRC

and introduce some stub implementations

#+BEGIN_SRC scala
    val M: Machines.Ast ~> T = Mocker.stub[Unit] {
      case Machines.Start(node) => State.modify[S](_.addSingle(node))
    }
    val D: Drone.Ast ~> T = Mocker.stub[Int] {
      case Drone.GetBacklog() => 2.pure[T]
    }
#+END_SRC

We can expect that the following simple program will behave as expected and call
=Machines.Start= twice:

#+BEGIN_SRC scala
    def program[F[_]: Monad](M: Machines[F], D: Drone[F]): F[Unit] =
      for {
        todo <- D.getBacklog
        _    <- (1 |-> todo).traverse(id => M.start(MachineNode(id.shows)))
      } yield ()

    program(Machines.liftF[Orig], Drone.liftF[Orig])
      .foldMap(or(M, D))
      .run(S(IList.empty, IList.empty))
      ._1
      .shouldBe(S(IList(MachineNode("2"), MachineNode("1")), IList.empty))
#+END_SRC

But we don't want to use =Machines.Start=, we need =Batch.Start= to get
our bonus. Expand the AST to keep track of the =Waiting= nodes that we are
delaying, and add the =Batch= instructions:

#+BEGIN_SRC scala
    type Waiting      = IList[MachineNode]
    type Extension[a] = Coproduct[Batch.Ast, Orig, a]
    type Patched[a]   = StateT[Free[Extension, ?], Waiting, a]
#+END_SRC

along with a stub for the =Batch= algebra

#+BEGIN_SRC scala
    val B: Batch.Ast ~> T = Mocker.stub[Unit] {
      case Batch.Start(nodes) => State.modify[S](_.addBatch(nodes))
    }
#+END_SRC

#+BEGIN_ASIDE
This example is advanced. It is possible to read the remainder of the book
without understanding how this example works: you may safely skim the rest of
this section if your brain hurts.
#+END_ASIDE

We can convert from the =Orig= AST into =Patched= by providing a natural
transformation that batches node starts:

#+BEGIN_SRC scala
    def monkey(max: Int) = new (Orig ~> Patched) {
      def apply[α](fa: Orig[α]): Patched[α] = fa.run match {
        case -\/(Machines.Start(node)) =>
          StateT { waiting =>
            if (waiting.length >= max) {
              val start = Batch.Start(NonEmptyList.nel(node, waiting))
              Free
                .liftF[Extension, Unit](leftc(start))
                .strengthL(IList.empty)
            } else
              Free
                .pure[Extension, Unit](())
                .strengthL(node :: waiting)
          }

        case _ =>
          Free
            .liftF[Extension, α](rightc(fa))
            .liftM[StateT[?[_], Waiting, ?]]
      }
    }
#+END_SRC

#+BEGIN_ASIDE
The Scala compiler struggles a bit to infer all the types in this code, so we
provide a lot of type annotations to help it along.
#+END_ASIDE

We're using =.strengthL= to set the value of the =Waiting= state, with =.pure=
again letting us avoid sending an instruction in this code branch.

We =.foldMap= *twice* because of the state, and combine the stubs again with
=.or=:

#+BEGIN_SRC scala
    program(Machines.liftF[Orig], Drone.liftF[Orig])
      .foldMap(monkey(1))
      .run(IList.empty) // starting Waiting list
      .foldMap(or(B, or(M, D)))
#+END_SRC

Then we run the program and assert: that there are no nodes in the =Waiting=
list, no node has been launched using the old API, and all nodes have been
launched in one call to the batch API.

#+BEGIN_SRC scala
      .run(S(IList.empty, IList.empty))
      .shouldBe(
        (
          S(
            IList.empty, // no singles
            IList(NonEmptyList(MachineNode("2"), MachineNode("1"))) // bonus time!
          ),
          (
            IList.empty, // no Waiting
            () // the program output
          )
        )
      )
#+END_SRC

Congratulations, we've saved the company $50 every month, and it only cost a
million dollars. But that was some other team's budget, so it is OK.

We could have done the same monkey patch by hard coding the batching logic into
our algebra implementations. In the defence of =Free=, we have decoupled the
patch from the implementation, which means we can test it more thoroughly.

#+BEGIN_WARNING
With great power comes great responsibility: we are transforming the meaning of
the program, almost certainly with unintended consequences.

Consider an algebra for writing debug messages to the network: we trade a
network performance gain for the risk of dropping some messages. However if we
are relying on the Monad laws in our business logic, and we mess with that, we
may as well be flipping bits in RAM.
#+END_WARNING

# http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html
# http://frees.io/docs/core/algebras/
# https://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html
# http://perevillega.com/understanding-free-monads
# https://www.chrisstucchio.com/blog/2015/free_monads_in_scalaz.html
# https://underscore.io/blog/posts/2017/03/29/free-inject.html

**** =FreeAp= (=Applicative=)

Despite this chapter being called *Advanced Monads*, the takeaway is: /don't use
monads unless you really *really* have to/. In this section, we will see why
=FreeAp= (free applicative) is preferable to =Free= monads.

=FreeAp= is defined as the data structure representation of the =ap= and =pure=
methods from the =Applicative= typeclass:

# https://www.youtube.com/watch?v=A-lmrvsUi2Y

#+BEGIN_SRC scala
sealed abstract class FreeAp[S[_], A] {
  def hoist[G[_]](f: S ~> G): FreeAp[G,A] = ...
  def foldMap[G[_]: Applicative](f: S ~> G): G[A] = ...
  def monadic: Free[S, A] = ...
  def analyze[M:Monoid](f: F ~> λ[α => M]): M = ...
  ...
}
object FreeAp {
  implicit def applicative[S[_], A]: Applicative[FreeAp[S, A]] = ...

  private final case class Pure[S[_], A](a: A) extends FreeAp[S, A]
  private final case class Ap[S[_], A, B](
    value: () => S[B],
    function: () => FreeAp[S, B => A]
  ) extends FreeAp[S, A]

  def pure[S[_], A](a: A): FreeAp[S, A] = Pure(a)
  def lift[S[_], A](x: => S[A]): FreeAp[S, A] = ...
  ...
}
#+END_SRC

The methods =.hoist= and =.foldMap= are like their =Free= analogues
=.mapSuspension= and =.foldMap=.

As a convenience, we can generate a =Free[S, A]= from our =FreeAp[S, A]= with
=.monadic=. This is especially useful to optimise smaller =Applicative=
subsystems yet use them as part of a larger =Free= program.

Like =Free=, we must create a =FreeAp= for our ASTs, more boilerplate...

#+BEGIN_SRC scala
  def liftA[F[_]](implicit I: Ast :<: F) = new Machines[FreeAp[F, ?]] {
    def getTime = FreeAp.lift(I.inj(GetTime()))
    ...
  }
#+END_SRC

***** Batching Network Calls

We opened this chapter with grand claims about performance. Time to deliver.

[[https://gist.github.com/hellerbarde/2843375#file-latency_humanized-markdown][Philip Stark]]'s Humanised version of [[http://norvig.com/21-days.html#answers][Peter Norvig's Latency Numbers]] serve as
motivation for why we should focus on reducing network calls to optimise an
application:

| Computer                          | Human Timescale | Human Analogy                  |
|-----------------------------------+-----------------+--------------------------------|
| L1 cache reference                | 0.5 secs        | One heart beat                 |
| Branch mispredict                 | 5 secs          | Yawn                           |
| L2 cache reference                | 7 secs          | Long yawn                      |
| Mutex lock/unlock                 | 25 secs         | Making a cup of tea            |
| Main memory reference             | 100 secs        | Brushing your teeth            |
| Compress 1K bytes with Zippy      | 50 min          | Scala compiler CI pipeline     |
| Send 2K bytes over 1Gbps network  | 5.5 hr          | Train London to Edinburgh      |
| SSD random read                   | 1.7 days        | Weekend                        |
| Read 1MB sequentially from memory | 2.9 days        | Long weekend                   |
| Round trip within same datacenter | 5.8 days        | Long US Vacation               |
| Read 1MB sequentially from SSD    | 11.6 days       | Short EU Holiday               |
| Disk seek                         | 16.5 weeks      | Term of university             |
| Read 1MB sequentially from disk   | 7.8 months      | Fully paid maternity in Norway |
| Send packet CA->Netherlands->CA   | 4.8 years       | Government's term              |

Although =Free= and =FreeAp= incur a memory allocation overhead, the equivalent
of 100 seconds in the humanised chart, every time we can turn two sequential
network calls into one batch call, we save nearly 5 years.

When we are in a =Applicative= context, we can safely optimise our application
without breaking any of the expectations of the original program, and without
cluttering the business logic.

Luckily, our main business logic only requires an =Applicative=, recall

#+BEGIN_SRC scala
final class DynAgents[F[_]: Applicative](D: Drone[F], M: Machines[F]) {
  def act(world: WorldView): F[WorldView] = ...
  ...
}
#+END_SRC

To begin, we create the =lift= boilerplate for the =Batch= algebra

#+BEGIN_SRC scala
trait Batch[F[_]] {
  def start(nodes: NonEmptyList[MachineNode]): F[Unit]
}
object Batch {
  sealed abstract class Ast[A]
  final case class Start(nodes: NonEmptyList[MachineNode]) extends Ast[Unit]

  def liftA[F[_]](implicit I: Ast :<: F) = new Batch[FreeAp[F, ?]] {
    def start(nodes: NonEmptyList[MachineNode]) = FreeAp.lift(I.inj(Start(nodes)))
  }
}
#+END_SRC

and then we'll create an instance of =DynAgents= with =FreeAp= as the context

#+BEGIN_SRC scala
  type Orig[a] = Coproduct[Machines.Ast, Drone.Ast, a]

  val world: WorldView = ...
  val program = new DynAgents(Drone.liftA[Orig], Machines.liftA[Orig])
  val freeap  = program.act(world)
#+END_SRC

In Chapter 6, we studied the =Const= data type, which allows us to analyse a
program. It should not be surprising that =FreeAp.analyze= is implemented in
terms of =Const=:

#+BEGIN_SRC scala
sealed abstract class FreeAp[S[_], A] {
  ...
  def analyze[M: Monoid](f: S ~> λ[α => M]): M =
    foldMap(λ[S ~> Const[M, ?]](x => Const(f(x)))).getConst
}
#+END_SRC

We provide a natural transformation to record all node starts and =.analyze= our
program to get all the nodes that need to be started:

#+BEGIN_SRC scala
    val gather = λ[Orig ~> λ[α => IList[MachineNode]]] {
      case Coproduct(-\/(Machines.Start(node))) => IList.single(node)
      case _                                    => IList.empty
    }
    val gathered: IList[MachineNode] = freeap.analyze(gather)
#+END_SRC

The next step is to extend the instruction set from =Orig= to =Extended=, which
includes the =Batch.Ast= and write a =FreeAp= program that starts all our
=gathered= nodes in a single network call

#+BEGIN_SRC scala
    type Extended[a] = Coproduct[Batch.Ast, Orig, a]
    def batch(nodes: IList[MachineNode]): FreeAp[Extended, Unit] =
      nodes.toNel match {
        case None        => FreeAp.pure(())
        case Some(nodes) => FreeAp.lift(Coproduct.leftc(Batch.Start(nodes)))
      }
#+END_SRC

We also need to remove all the calls to =Machines.Start=, which we can do with a natural transformation

#+BEGIN_SRC scala
    val nostart = λ[Orig ~> FreeAp[Extended, ?]] {
      case Coproduct(-\/(Machines.Start(_))) => FreeAp.pure(())
      case other                             => FreeAp.lift(Coproduct.rightc(other))
    }
#+END_SRC

Now we have two programs, and need to combine them. Recall the =*>= syntax for =Functor=

#+BEGIN_SRC scala
    val patched = batch(gathered) *> freeap.foldMap(nostart)
#+END_SRC

Putting it all together under a single method:

#+BEGIN_SRC scala
    def optimise[A](orig: FreeAp[Orig, A]): FreeAp[Extended, A] =
      (batch(orig.analyze(gather)) *> orig.foldMap(nostart))
#+END_SRC

That's it! We =.optimise= every time we call =act= in our main loop, which is
just a matter of plumbing.

**** =Coyoneda= (=Functor=)

Named after mathematician Nobuo Yoneda, we can freely generate a =Functor= data
structure for any algebra =S[_]=

#+BEGIN_SRC scala
sealed abstract class Coyoneda[S[_], A] {
  def run(implicit S: Functor[S]): S[A] = ...
  def trans[G[_]](f: F ~> G): Coyoneda[G, A] = ...
  ...
}
object Coyoneda {
  implicit def functor[S[_], A]: Functor[Coyoneda[S, A]] = ...

  private final case class Map[F[_], A, B](fa: F[A], f: A => B) extends Coyoneda[F, A]
  def apply[S[_], A, B](sa: S[A])(f: A => B) = Map[S, A, B](sa, f)
  def lift[S[_], A](sa: S[A]) = Map[S, A, A](sa, identity)
  ...
}
#+END_SRC

and there is also a contravariant version

#+BEGIN_SRC scala
sealed abstract class ContravariantCoyoneda[S[_], A] {
  def run(implicit S: Contravariant[S]): S[A] = ...
  def trans[G[_]](f: F ~> G): ContravariantCoyoneda[G, A] = ...
  ...
}
object ContravariantCoyoneda {
  implicit def contravariant[S[_], A]: Contravariant[ContravariantCoyoneda[S, A]] = ...

  private final case class Contramap[F[_], A, B](fa: F[A], f: B => A)
    extends ContravariantCoyoneda[F, A]
  def apply[S[_], A, B](sa: S[A])(f: B => A) = Contramap[S, A, B](sa, f)
  def lift[S[_], A](sa: S[A]) = Contramap[S, A, A](sa, identity)
  ...
}
#+END_SRC

#+BEGIN_ASIDE
The colloquial for =Coyoneda= is /coyo/ and =ContravariantCoyoneda= is /cocoyo/.
Just some Free Fun.
#+END_ASIDE

The API is somewhat simpler than =Free= and =FreeAp=, allowing a natural
transformation with =.trans= and a =.run= (taking an actual =Functor= or
=Contravariant=, respectively) to escape the free structure.

Coyo and cocoyo can be a useful utility if we want to =.map= or =.contramap=
over a type, and we know that we can convert into a data type that has a Functor
but we don't want to commit to the final data structure too early. For example,
we create a =Coyoneda[ISet, ?]= (recall =ISet= does not have a =Functor=) to use
methods that require a =Functor=, then convert into =IList= later on.

If we want to optimise a program with coyo or cocoyo we have to provide the
expected boilerplate for each algebra:

#+BEGIN_SRC scala
  def liftCoyo[F[_]](implicit I: Ast :<: F) = new Machines[Coyoneda[F, ?]] {
    def getTime = Coyoneda.lift(I.inj(GetTime()))
    ...
  }
  def liftCocoyo[F[_]](implicit I: Ast :<: F) = new Machines[ContravariantCoyoneda[F, ?]] {
    def getTime = ContravariantCoyoneda.lift(I.inj(GetTime()))
    ...
  }
#+END_SRC

An optimisation we get by using =Coyoneda= is /map fusion/ (and /contramap
fusion/), which allows us to rewrite

#+BEGIN_SRC scala
xs.map(a).map(b).map(c)
#+END_SRC

into

#+BEGIN_SRC scala
xs.map(x => c(b(a(x))))
#+END_SRC

avoiding intermediate representations. For example, if =xs= is a =List= of a
thousand elements, we save two thousand object allocations because we only map
over the data structure once.

However it is arguably a lot easier to just make this kind of change in the
original function by hand, or to wait for the [[https://github.com/oleg-py/better-monadic-for/issues/6][=better-monadic-for=]] project to
automatically perform these optimisations across our codebase.

# https://www.youtube.com/watch?v=H28QqxO7Ihc
# https://www.youtube.com/watch?v=A-lmrvsUi2Y

# - Programs that change values
# - Programs that build data
# - Programs that build programs

**** Extensible Effects

Programs are just data: free structures help to make this explicit and give us
the ability to rearrange and optimise that data.

=Free= is more special than it appears: it can sequence arbitrary algebras and
typeclasses.

For example, a free structure for =MonadState= is available. The =Ast= and
=.liftF= are more complicated than usual because we have to account for the =S=
type parameter on =MonadState=, and the inheritance from =Monad=:

#+BEGIN_SRC scala
object MonadState {
  sealed abstract class Ast[S, A]
  final case class Get[S]()     extends Ast[S, S]
  final case class Put[S](s: S) extends Ast[S, Unit]

  def liftF[F[_], S](implicit I: Ast[S, ?] :<: F) =
    new MonadState[Free[F, ?], S] with BindRec[Free[F, ?]] {
      def get       = Free.liftF(I.inj(Get[S]()))
      def put(s: S) = Free.liftF(I.inj(Put[S](s)))

      val delegate         = Free.freeMonad[F]
      def point[A](a: =>A) = delegate.point(a)
      ...
    }
  ...
}
#+END_SRC

This gives us the opportunity to use optimised interpreters. For example, we
could store the =S= in an atomic field instead of building up a nested =StateT=
trampoline.

We can create an =Ast= and =.liftF= for almost any algebra or typeclass! The
only restriction is that the =F[_]= does not appear as a parameter to any of the
instructions, i.e. it must be possible for the algebra to have an instance of
=Functor=. This unfortunately rules out =MonadError= and =Monoid=.

#+BEGIN_ASIDE
The reason why free encodings do not work for all algebras and typeclasses is
quite subtle.

Consider what happens if we create an Ast for =MonadError=, with =F[_]= in
contravariant position, i.e. as a parameter.

#+BEGIN_SRC scala
object MonadError {
  sealed abstract class Ast[F[_], E, A]
  final case class RaiseError[E, A](e: E) extends Ast[E, A]
  final case class HandleError[F[_], E, A](fa: F[A], f: E => F[A]) extends Ast[E, A]

  def liftF[F[_], E](implicit I: Ast[F, E, ?] :<: F): MonadError[F, E] = ...
  ...
}
#+END_SRC

When we come to interpret a program that uses =MonadError.Ast= we must construct
the coproduct of instructions. Let's say we extend a =Drone= program:

#+BEGIN_SRC scala
type Ast[a] = Coproduct[MonadError.Ast[Ast, String, ?], Drone.Ast, a]
#+END_SRC

This fails to compile because =Ast= refers to itself!

Algebras that are not entirely made of covariant functor signatures, i.e. =F[_]=
in return position, are impossible to interpret because the resulting type of
the program is self-referential. Indeed the name /algebra/ that we have been
using has its roots in [[https://en.wikipedia.org/wiki/F-algebra][F-Algebras]], where the F is for Functor.

/Thanks to Edmund Noble for initiating this discussion./

# https://github.com/scalaz/scalaz/pull/1888
#+END_ASIDE

As the AST of a free program grows, performance degrades because the interpreter
must match over instruction sets with an =O(n)= cost. An alternative to
=scalaz.Coproduct= is [[https://github.com/frees-io/iota][iotaz]]'s encoding, which uses an optimised data structure
to perform =O(1)= dynamic dispatch (using integers that are assigned to each
coproduct at compiletime).

For historical reasons a free AST for an algebra or typeclass is called /Initial
Encoding/, and a direct implementation (e.g. with =IO=) is called /Finally
Tagless/. Although we have explored interesting ideas with =Free=, it is
generally accepted that finally tagless is superior. But to use finally tagless
style, we need a high performance effect type that provides all the monad
typeclasses we've covered in this chapter. We also still need to be able to run
our =Applicative= code in parallel. This is exactly what we will cover next.

# http://okmij.org/ftp/Haskell/extensible/more.pdf
# http://okmij.org/ftp/Computation/free-monad.html
# http://atnos-org.github.io/eff/

# http://degoes.net/articles/effects-without-transformers
# and John's winter retreat talk...

*** =Parallel=

There are two effectful operations that we almost always want to run in
parallel:

1. =.map= over a collection of effects, returning a single effect. This is
   achieved by =.traverse=, which delegates to the effect's =.apply2=.
2. running a fixed number of effects with the /scream operator/ =|@|=, and
   combining their output, again delegating to =.apply2=.

However, in practice, neither of these operations execute in parallel by
default. The reason is that if our =F[_]= is implemented by a =Monad=, then the
derived combinator laws for =.apply2= must be satisfied, which say

#+BEGIN_SRC scala
@typeclass trait Bind[F[_]] extends Apply[F] {
  ...
  override def apply2[A, B, C](fa: => F[A], fb: => F[B])(f: (A, B) => C): F[C] =
    bind(fa)(a => map(fb)(b => f(a, b)))
  ...
}
#+END_SRC

In other words, *=Monad= is explicitly forbidden from running effects in
parallel.*

However, if we have an =F[_]= that is *not* monadic, then it may implement
=.apply2= in parallel. We can use the =@@= (tag) mechanism to create an instance
of =Applicative= for =F[_] @@ Parallel=, which is conveniently assigned to the
type alias =Applicative.Par=

#+BEGIN_SRC scala
object Applicative {
  type Par[F[_]] = Applicative[λ[α => F[α] @@ Tags.Parallel]]
  ...
}
#+END_SRC

Monadic programs can then request an implicit =Par= in addition to their =Monad=

#+BEGIN_SRC scala
def foo[F[_]: Monad: Applicative.Par]: F[Unit] = ...
#+END_SRC

Scalaz's =Traverse= syntax supports parallelism:

#+BEGIN_SRC scala
implicit class TraverseSyntax[F[_], A](self: F[A]) {
  ...
  def parTraverse[G[_], B](f: A => G[B])(
    implicit F: Traverse[F], G: Applicative.Par[G]
  ): G[F[B]] = Tag.unwrap(F.traverse(self)(a => Tag(f(a))))
}
#+END_SRC

If the implicit =Applicative.Par[IO]= is in scope, we can choose between
sequential and parallel traversal:

#+BEGIN_SRC scala
  val input: IList[String] = ...
  def network(in: String): IO[Int] = ...

  input.traverse(network): IO[IList[Int]] // one at a time
  input.parTraverse(network): IO[IList[Int]] // all in parallel
#+END_SRC

Similarly, we can call =.parApply= or =.parTupled= after using scream operators

#+BEGIN_SRC scala
  val fa: IO[String] = ...
  val fb: IO[String] = ...
  val fc: IO[String] = ...

  (fa |@| fb).parTupled: IO[(String, String)]

  (fa |@| fb |@| fc).parApply { case (a, b, c) => a + b + c }: IO[String]
#+END_SRC

It is worth nothing that when we have =Applicative= programs, such as

#+BEGIN_SRC scala
def foo[F[_]: Applicative]: F[Unit] = ...
#+END_SRC

we can use =F[A] @@ Parallel= as our program's context and get parallelism as
the default on =.traverse= and =|@|=. Converting between the raw and =@@
Parallel= versions of =F[_]= must be handled manually in the glue code, which
can be painful. Therefore it is often easier to simply request both forms of
=Applicative=

#+BEGIN_SRC scala
def foo[F[_]: Applicative: Applicative.Par]: F[Unit] = ...
#+END_SRC

**** Breaking the Law

We can take a more daring approach to parallelism: opt-out of the law that
=.apply2= must be sequential for =Monad=. This is highly controversial, but
works well for the majority of real world applications. we must first audit our
codebase (including third party dependencies) to ensure that nothing is making
use of the =.apply2= implied law.

We wrap =IO=

#+BEGIN_SRC scala
final class MyIO[A](val io: IO[A]) extends AnyVal
#+END_SRC

and provide our own implementation of =Monad= which runs =.apply2= in parallel
by delegating to a =@@ Parallel= instance

#+BEGIN_SRC scala
object MyIO {
  implicit val monad: Monad[MyIO] = new Monad[MyIO] {
    override def apply2[A, B, C](fa: MyIO[A], fb: MyIO[B])(f: (A, B) => C): MyIO[C] =
      Applicative[IO.Par].apply2(fa.io, fb.io)(f)
    ...
  }
}
#+END_SRC

We can now use =MyIO= as our application's context instead of =IO=, and *get
parallelism by default*.

#+BEGIN_ASIDE
Wrapping an existing type and providing custom typeclass instances is known as
/newtyping/.

=@@= and newtyping are complementary: =@@= allows us to request specific
typeclass variants on our domain model, whereas newtyping allow us to define the
instances on the implementation. Same thing, different insertion points.

The =@newtype= macro [[https://github.com/estatico/scala-newtype][by Cary Robbins]] has an optimised runtime representation
(more efficient than =extends AnyVal=), that makes it easy to delegate
typeclasses that we do not wish to customise. For example, we can customise
=Monad= but delegate the =Plus=:

#+BEGIN_SRC scala
@newtype class MyIO[A](io: IO[A])
object MyIO {
  implicit val monad: Monad[MyIO] = ...
  implicit val plus: Plus[MyIO] = derived
}
#+END_SRC
#+END_ASIDE

For completeness: a naive and inefficient implementation of =Applicative.Par=
for our toy =IO= could use =Future=:

#+BEGIN_SRC scala
object IO {
  ...
  type Par[a] = IO[a] @@ Parallel
  implicit val ParApplicative = new Applicative[Par] {
    override def apply2[A, B, C](fa: =>Par[A], fb: =>Par[B])(f: (A, B) => C): Par[C] =
      Tag(
        IO {
          val forked = Future { Tag.unwrap(fa).interpret() }
          val b      = Tag.unwrap(fb).interpret()
          val a      = Await.result(forked, Duration.Inf)
          f(a, b)
        }
      )
}
#+END_SRC

and due to [[https://github.com/scala/bug/issues/10954][a bug in the scala compiler]] that treats all =@@= instances as
orphans, we must explicitly import the implicit:

#+BEGIN_SRC scala
import IO.ParApplicative
#+END_SRC

In the final section of this chapter we will see how scalaz's =IO= is actually
implemented.

*** =IO=

Scalaz's =IO= is the fastest asynchronous programming construct in the Scala
ecosystem: up to 50 times faster than =Future= and 20% faster than Monix.

=IO= is a free data structure specialised for use as a general effect monad.

#+BEGIN_SRC scala
sealed abstract class IO[E, A] { ... }
object IO {
  final class FlatMap         ... extends IO[E, A]
  final class Point           ... extends IO[E, A]
  final class Strict          ... extends IO[E, A]
  final class SyncEffect      ... extends IO[E, A]
  final class Fail            ... extends IO[E, A]
  final class AsyncEffect     ... extends IO[E, A]
  final class AsyncIOEffect   ... extends IO[E, A]
  final class Attempt         ... extends IO[E2, E1 \/ A]
  final class Fork            ... extends IO[E2, Fiber[E1, A]]
  final class Race            ... extends IO[E, A]
  final class Suspend         ... extends IO[E, A]
  final class Bracket         ... extends IO[E, B]
  final class Uninterruptible ... extends IO[E, A]
  final class Sleep           ... extends IO[E, Unit]
  final class Supervise       ... extends IO[E, A]
  final class Terminate       ... extends IO[E, A]
  final class Supervisor      ... extends IO[E, Throwable => IO[Void, Unit]]
  final class Run             ... extends IO[E2, ExitResult[E1, A]]
  ...
}
#+END_SRC

=IO= has *two* type parameters: it has a =Bifunctor= allowing the error type to
be an application specific ADT. But because we are on the JVM, and must interact
with legacy libraries, a convenient type alias is provided that uses exceptions
for the error type:

#+BEGIN_SRC scala
  type Task[A] = IO[Throwable, A]
#+END_SRC

#+BEGIN_ASIDE
=scalaz.ioeffect.IO= is a high performance =IO= by John de Goes. It has a
separate lifecycle to the core scalaz library and must be manually added to our
=build.sbt= with

#+BEGIN_SRC scala
libraryDependencies += "org.scalaz" %% "scalaz-ioeffect" % "2.8.0"
#+END_SRC

Do not use the deprecated =scalaz-effect= and =scalaz-concurrency= packages.
Prefer the =scalaz.ioeffect= variants of all typeclasses and data types.
#+END_ASIDE

# https://www.youtube.com/watch?v=Eihz7kqn6mU
# https://www.slideshare.net/jdegoes/scalaz-8-vs-akka-actors

# benchmarks/jmh:run -i 5 -wi 5 -f1 -t2 -w2 -r2 .*
# # Run complete. Total time: 00:11:50
# Benchmark                                       (depth)  (size)   Mode  Cnt          Score          Error  Units
# ArrayFillBenchmarks.catsArrayFill                   N/A   10000  thrpt    5       8222.592 ±      262.246  ops/s
# ArrayFillBenchmarks.monixArrayFill                  N/A   10000  thrpt    5       8455.779 ±      613.571  ops/s
# ArrayFillBenchmarks.scalazArrayFill                 N/A   10000  thrpt    5      18232.371 ±      453.343  ops/s
# BubbleSortBenchmarks.catsBubbleSort                 N/A    1000  thrpt    5         89.523 ±        2.457  ops/s
# BubbleSortBenchmarks.monixBubbleSort                N/A    1000  thrpt    5         91.809 ±        1.767  ops/s
# BubbleSortBenchmarks.scalazBubbleSort               N/A    1000  thrpt    5        129.307 ±        2.003  ops/s
# IODeepAttemptBenchmark.catsDeepAttempt             1000     N/A  thrpt    5      40512.131 ±      783.616  ops/s
# IODeepAttemptBenchmark.futureDeepAttempt           1000     N/A  thrpt    5      10208.526 ±      167.039  ops/s
# IODeepAttemptBenchmark.monixDeepAttempt            1000     N/A  thrpt    5      41298.849 ±     1460.146  ops/s
# IODeepAttemptBenchmark.scalazDeepAttempt           1000     N/A  thrpt    5      46187.262 ±     1790.767  ops/s
# IODeepAttemptBenchmark.thunkDeepAttempt            1000     N/A  thrpt    5      30266.824 ±      634.086  ops/s
# IODeepFlatMapBenchmark.catsDeepFlatMap               20     N/A  thrpt    5       4026.655 ±      100.745  ops/s
# IODeepFlatMapBenchmark.futureDeepFlatMap             20     N/A  thrpt    5        131.566 ±        1.188  ops/s
# IODeepFlatMapBenchmark.monixDeepFlatMap              20     N/A  thrpt    5       3570.778 ±       63.175  ops/s
# IODeepFlatMapBenchmark.scalazDeepFlatMap             20     N/A  thrpt    5       3907.726 ±      261.831  ops/s
# IODeepFlatMapBenchmark.thunkDeepFlatMap              20     N/A  thrpt    5       4251.012 ±      128.777  ops/s
# IOLeftBindBenchmark.catsLeftBindBenchmark           100   10000  thrpt    5       9036.734 ±      245.864  ops/s
# IOLeftBindBenchmark.futureLeftBindBenchmark         100   10000  thrpt    5        396.114 ±        5.405  ops/s
# IOLeftBindBenchmark.monixLeftBindBenchmark          100   10000  thrpt    5       7145.843 ±      181.664  ops/s
# IOLeftBindBenchmark.scalazLeftBindBenchmark         100   10000  thrpt    5      11354.589 ±      379.889  ops/s
# IOLeftBindBenchmark.thunkLeftBindBenchmark          100   10000  thrpt    5  997401060.687 ±  5389516.539  ops/s
# IOMapBenchmark.catsMap                              500     N/A  thrpt    5     124230.424 ±     3096.434  ops/s
# IOMapBenchmark.futureMap                            500     N/A  thrpt    5      15050.309 ±     2869.725  ops/s
# IOMapBenchmark.monixMap                             500     N/A  thrpt    5     124979.926 ±     3156.908  ops/s
# IOMapBenchmark.scalazMap                            500     N/A  thrpt    5     126334.603 ±     9496.260  ops/s
# IOMapBenchmark.thunkMap                             500     N/A  thrpt    5     122862.554 ±     5301.997  ops/s
# IONarrowFlatMapBenchmark.catsNarrowFlatMap          N/A   10000  thrpt    5      13273.883 ±     1778.012  ops/s
# IONarrowFlatMapBenchmark.futureNarrowFlatMap        N/A   10000  thrpt    5        361.044 ±       16.853  ops/s
# IONarrowFlatMapBenchmark.monixNarrowFlatMap         N/A   10000  thrpt    5      15137.902 ±      970.714  ops/s
# IONarrowFlatMapBenchmark.scalazNarrowFlatMap        N/A   10000  thrpt    5      16024.170 ±      661.342  ops/s
# IONarrowFlatMapBenchmark.thunkNarrowFlatMap         N/A   10000  thrpt    5  990969244.629 ± 18968654.949  ops/s
# IOShallowAttemptBenchmark.catsShallowAttempt       1000     N/A  thrpt    5       4234.260 ±      346.703  ops/s
# IOShallowAttemptBenchmark.futureShallowAttempt     1000     N/A  thrpt    5        768.406 ±        7.250  ops/s
# IOShallowAttemptBenchmark.scalazShallowAttempt     1000     N/A  thrpt    5       3750.653 ±      620.466  ops/s
# IOShallowAttemptBenchmark.thunkShallowAttempt      1000     N/A  thrpt    5         91.027 ±        1.189  ops/s

**** Creating

There are multiple ways to create an =IO= that cover a variety of eager, lazy,
safe and unsafe code blocks:

#+BEGIN_SRC scala
object IO {
  // eager evaluation of an existing value
  def now[E, A](a: A): IO[E, A] = ...
  // lazy evaluation of a pure calculation
  def point[E, A](a: => A): IO[E, A] = ...
  // lazy evaluation of a side-effecting, yet Total, code block
  def sync[E, A](effect: => A): IO[E, A] = ...
  // lazy evaluation of a side-effecting code block that may fail
  def syncThrowable[A](effect: => A): IO[Throwable, A] = ...

  // create a failed IO
  def fail[E, A](error: E): IO[E, A] = ...
  // asynchronously sleeps for a specific period of time
  def sleep[E](duration: Duration): IO[E, Unit] = ...
  ...
}
#+END_SRC

with convenient =Task= constructors:

#+BEGIN_SRC scala
  object Task {
    def apply[A](effect: => A): Task[A] = IO.syncThrowable(effect)
    def now[A](effect: A): Task[A] = IO.now(effect)
    def fail[A](error: Throwable): Task[A] = IO.fail(error)
    def fromFuture[E, A](io: Task[Future[A]])(ec: ExecutionContext): Task[A] = ...
  }
#+END_SRC

The most common constructors, by far, when dealing with legacy code are
=Task.apply= and =Task.fromFuture=:

#+BEGIN_SRC scala
val fa: Task[Future[String]] = Task { ... impure code here ... }

Task.fromFuture(fa)(ExecutionContext.global): Task[String]
#+END_SRC

We can't pass around raw =Future=, because it eagerly evaluates, so must always
be constructed inside a safe block.

Note that the =ExecutionContext= is *not* =implicit=, contrary to the
convention. Recall that in scalaz we reserve the =implicit= keyword for
typeclass derivation, to simplify the language: =ExecutionContext= is
configuration that must be provided explicitly.

**** Running

The =IO= interpreter is called =RTS=, for /runtime system/. Its implementation
is beyond the scope of this book. We will instead focus on the features that
=IO= provides.

=IO= is just a data structure, and is interpreted /at the end of the world/ by
extending =SafeApp= and implementing =.run=

#+BEGIN_SRC scala
trait SafeApp extends RTS {

  sealed trait ExitStatus
  object ExitStatus {
    case class ExitNow(code: Int)                         extends ExitStatus
    case class ExitWhenDone(code: Int, timeout: Duration) extends ExitStatus
    case object DoNotExit                                 extends ExitStatus
  }

  def run(args: List[String]): IO[Void, ExitStatus]

  final def main(args0: Array[String]): Unit = ... calls run ...
}
#+END_SRC

#+BEGIN_ASIDE
=Void= is a type that has no values, like =scala.Nothing=. However, the scala
compiler infers =Nothing= when it fails to correctly infer a type parameter,
causing confusing error messages, whereas =Void= will fail fast during
compilation.

A =Void= error type means that the effect *cannot fail*, which is to say that we
have handled all errors by this point.
#+END_ASIDE

If we are integrating with a legacy system and are not in control of the entry
point of our application, we can extend the =RTS= and gain access to unsafe
methods to evaluate the =IO= at the entry point to our principled FP code.

For example, if we have an algebra that canonicalises values, and may hit disk
or network to resolve filenames and URLs:

#+BEGIN_SRC scala
trait Canon[F[_], A] {
  def canon(a: A): F[A]
}
#+END_SRC

we can write a scalatest that extends =RTS= and call =unsafePerformIO= to
interpret the =IO=

#+BEGIN_SRC scala
import org.scalatest._
import scalaz.ioeffect.{ RTS, Task }

class CanonSpec extends FlatSpec with RTS {
  "Canon" should "canon File" in {
    unsafePerformIO((new File(".")).canon) shouldBe ...
  }
}
#+END_SRC

**** Features

=IO= provides typeclass instances for =Bifunctor=, =MonadError[E, ?]=,
=BindRec=, =Plus=, =MonadPlus= (if =E= forms a =Monoid=), and an
=Applicative[IO.Par[E, ?]]=.

In addition to the functionality from the typeclasses, there are implementation
specific methods:

#+BEGIN_SRC scala
sealed abstract class IO[E, A] {
  // retries an action N times, until success
  def retryN(n: Int): IO[E, A] = ...
  // ... with exponential backoff
  def retryBackoff(n: Int, factor: Double, duration: Duration): IO[E, A] = ...

  // repeats an action with a pause between invocations, until it fails
  def repeat[B](interval: Duration): IO[E, B] = ...

  // cancel the action if it does not complete within the timeframe
  def timeout(duration: Duration): IO[E, Maybe[A]] = ...

  // runs `release` on success or failure.
  // Note that IO[Void, Unit] cannot fail.
  def bracket[B](release: A => IO[Void, Unit])(use: A => IO[E, B]): IO[E, B] = ...
  // alternative syntax for bracket
  def ensuring(finalizer: IO[Void, Unit]): IO[E, A] =
  // ignore failure and success, e.g. to ignore the result of a cleanup action
  def ignore: IO[Void, Unit] = ...

  // runs two effects in parallel
  def par[B](that: IO[E, B]): IO[E, (A, B)] = ...
  ...
#+END_SRC

It is possible for an =IO= to be in a /terminated/ state, which represents work
that is intended to be discarded (it is neither an error nor a success). The
utilities related to termination are:

#+BEGIN_SRC scala
...
  // terminate whatever actions are running with the given throwable.
  // bracket / ensuring is honoured.
  def terminate[E, A](t: Throwable): IO[E, A] = ...

  // runs two effects in parallel, return the winner and terminate the loser
  def race(that: IO[E, A]): IO[E, A] = ...

  // ignores terminations
  def uninterruptibly: IO[E, A] = ...
...
#+END_SRC

**** =Fiber=

An =IO= may spawn /fibers/, a lightweight abstraction over a JVM =Thread=. We
can =.fork= an =IO=, and =.supervise= any incomplete fibers to ensure that they
are terminated when the =IO= action completes

#+BEGIN_SRC scala
...
  def fork[E2]: IO[E2, Fiber[E, A]] = ...
  def supervised(error: Throwable): IO[E, A] = ...
...
#+END_SRC

When we have a =Fiber= we can =.join= back into the =IO=, or =interrupt= the
underlying work.

#+BEGIN_SRC scala
trait Fiber[E, A] {
  def join: IO[E, A]
  def interrupt[E2](t: Throwable): IO[E2, Unit]
}
#+END_SRC

We can use fibers to achieve a form of optimistic concurrency control. Consider
the case where we have =data= that we need to analyse, but we also need to
validate it. We can optimistically begin the analysis and cancel the work if the
validation fails, which is performed in parallel.

#+BEGIN_SRC scala
  final class BadData(data: Data) extends Throwable with NoStackTrace

  for {
    fiber1   <- analysis(data).fork
    fiber2   <- validate(data).fork
    valid    <- fiber2.join
    _        <- if (!valid) fiber1.interrupt(BadData(data))
                else IO.unit
    result   <- fiber1.join
  } yield result
#+END_SRC

Another usecase for fibers is when we need to perform a /fire and forget/
action. For example, low priority logging over a network.

**** =Promise=

A promise represents an asynchronous variable that can be set exactly once (with
=complete= or =error=). An unbounded number of listeners can =get= the variable.

#+BEGIN_SRC scala
final class Promise[E, A] private (ref: AtomicReference[State[E, A]]) {
  def complete[E2](a: A): IO[E2, Boolean] = ...
  def error[E2](e: E): IO[E2, Boolean] = ...
  def get: IO[E, A] = ...

  // interrupts all listeners
  def interrupt[E2](t: Throwable): IO[E2, Boolean] = ...
}
object Promise {
  def make[E, A]: IO[E, Promise[E, A]] = ...
}
#+END_SRC

=Promise= is not something that we typically use in application code. It is a
building block for high level concurrency frameworks.

#+BEGIN_ASIDE
When an operation is guaranteed to succeed, the error type =E= is left as a free
type parameter so that the caller can specify their preference.
#+END_ASIDE

**** =IORef=

=IORef= is the =IO= equivalent of an atomic mutable variable.

We can read the variable and we have a variety of ways to write or update it.

#+BEGIN_SRC scala
final class IORef[A] private (ref: AtomicReference[A]) {
  def read[E]: IO[E, A] = ...

  // write with immediate consistency guarantees
  def write[E](a: A): IO[E, Unit] = ...
  // write with eventual consistency guarantees
  def writeLater[E](a: A): IO[E, Unit] = ...
  // return true if an immediate write succeeded, false if not (and abort)
  def tryWrite[E](a: A): IO[E, Boolean] = ...

  // atomic primitives for updating the value
  def compareAndSet[E](prev: A, next: A): IO[E, Boolean] = ...
  def modify[E](f: A => A): IO[E, A] = ...
  def modifyFold[E, B](f: A => (B, A)): IO[E, B] = ...
}
object IORef {
  def apply[E, A](a: A): IO[E, IORef[A]] = ...
}
#+END_SRC

# MonadState example...
# http://degoes.net/articles/effects-without-transformers

=IORef= is another building block and can be used to provide a high performance
=MonadState=. For example, create a newtype specialised to =Task=

#+BEGIN_SRC scala
final class StateTask[A](val io: Task[A]) extends AnyVal
object StateTask {
  def create[S](initial: S): Task[MonadState[StateTask, S]] =
    for {
      ref <- IORef(initial)
    } yield
      new MonadState[StateTask, S] {
        override def get       = new StateTask(ref.read)
        override def put(s: S) = new StateTask(ref.write(s))
        ...
      }
}
#+END_SRC

We can make use of this optimised =StateMonad= implementation in a =SafeApp=,
where our =.program= depends on optimised MTL typeclasses:

#+BEGIN_SRC scala
object FastState extends SafeApp {
  def program[F[_]](implicit F: MonadState[F, Int]): F[ExitStatus] = ...

  def run(@unused args: List[String]): IO[Void, ExitStatus] =
    for {
      stateMonad <- StateTask.create(10)
      output     <- program(stateMonad).io
    } yield output
}
#+END_SRC

A more realistic application would take a variety of algebras and typeclasses as
input.

#+BEGIN_ASIDE
This optimised =MonadState= is constructed in a way that breaks typeclass
coherence. Two instances having the same types may be managing different state.
It would be prudent to isolate the construction of all such instances to the
application's entrypoint.
#+END_ASIDE

***** =MonadIO=

The =MonadIO= that we previously studied was simplified to hide the =E=
parameter. The actual typeclass is

#+BEGIN_SRC scala
trait MonadIO[M[_], E] {
  def liftIO[A](io: IO[E, A])(implicit M: Monad[M]): M[A]
}
#+END_SRC

with a minor change to the boilerplate on the companion of our algebra,
accounting for the extra =E=:

#+BEGIN_SRC scala
trait Lookup[F[_]] {
  def look: F[Int]
}
object Lookup {
  def liftIO[F[_]: Monad, E](io: Lookup[IO[E, ?]])(implicit M: MonadIO[F, E]) =
    new Lookup[F] {
      def look: F[Int] = M.liftIO(io.look)
    }
  ...
}
#+END_SRC

*** Summary

1. The =Future= is broke, don't go there.
2. Manage stack safety with a =Trampoline=.
3. The Monad Transformer Library (MTL) abstracts over common effects.
4. Monad Transformers provide default implementations of the MTL.
5. =Free= data structures let us analyse, optimise and easily test our programs.
6. =IO= gives us the ability to implement algebras as effects on the outside world and interact with legacy systems.
7. =IO= can perform effects in parallel and provides a high performance implementation of the MTL.

** The Infinite Sadness

You've reached the end of this Early Access book. Please check the
website regularly for updates.

You can expect to see chapters covering the following topics:

- Typeclass Derivation
- Appendix: Scalaz source code layout
- Appendix: Scala for Beginners
- Appendix: Haskell

As well as a chapter pulling everything together for the example application
(and getting the repository into a working state).

# Maybe...
# - Functional Streams
# - Bluffing Haskell
# - Recursion Schemes
# - Category Theory
# - Dependent Types

* TODO Remaining
  :PROPERTIES:
  :EXPORT_FILE_NAME: remaining.md
  :END:

** TODO Typeclass Derivation

- scalaz-deriving
- magnolia
- shapeless
- macros
- export-hook
- Property Testing (as a case study for Arbitrary)

** TODO Implementing the Application

Pad out the application implementation with everything we've learnt.

Will probably be a big chapter. Maybe best to leave it for a final
part of the book?

** TODO Haskell

** TODO Scala

The following should suffice (in this order)

- object, val, def, if, primitives, types
- trait, class, abstract class (construction, methods, inheritance / type hierarchy)
- String, List and Future as examples (including a brief look at for)
- case class and pattern matching
- a brief introduction to implicit

ADTs, for, typeclasses and implicit, and algebras are covered in detail in the main body of my book. As well as many warnings about Future.

* Backmatter                                                          :final:
:PROPERTIES:
:EXPORT_FILE_NAME: backmatter.md
:END:
{backmatter}

** Typeclass Cheatsheet

| Typeclass          | Method          | From            | Given                  | To             |
|--------------------+-----------------+-----------------+------------------------+----------------|
| ~InvariantFunctor~ | ~xmap~          | ~F[A]~          | ~A => B, B => A~       | ~F[B]~         |
| ~Contravariant~    | ~contramap~     | ~F[A]~          | ~B => A~               | ~F[B]~         |
| ~Functor~          | ~map~           | ~F[A]~          | ~A => B~               | ~F[B]~         |
| ~Apply~            | ~ap~ / ~<*>~    | ~F[A]~          | ~F[A => B]~            | ~F[B]~         |
|                    | ~apply2~        | ~F[A], F[B]~    | ~(A, B) => C~          | ~F[C]~         |
| ~Divide~           | ~divide2~       | ~F[A], F[B]~    | ~C => (A, B)~          | ~F[C]~         |
| ~Bind~             | ~bind~ / ~>>=~  | ~F[A]~          | ~A => F[B]~            | ~F[B]~         |
|                    | ~join~          | ~F[F[A]]~       |                        | ~F[A]~         |
| ~Cobind~           | ~cobind~        | ~F[A]~          | ~F[A] => B~            | ~F[B]~         |
|                    | ~cojoin~        | ~F[A]~          |                        | ~F[F[A]]~      |
| ~Applicative~      | ~point~         | ~A~             |                        | ~F[A]~         |
| ~Comonad~          | ~copoint~       | ~F[A]~          |                        | ~A~            |
| ~Semigroup~        | ~append~        | ~A, A~          |                        | ~A~            |
| ~Plus~             | ~plus~ / ~<+>~  | ~F[A], F[A]~    |                        | ~F[A]~         |
| ~MonadPlus~        | ~withFilter~    | ~F[A]~          | ~A => Boolean~         | ~F[A]~         |
| ~Align~            | ~align~         | ~F[A], F[B]~    |                        | ~F[A \&/ B]~   |
|                    | ~merge~         | ~F[A], F[A]~    |                        | ~F[A]~         |
| ~Zip~              | ~zip~           | ~F[A], F[B]~    |                        | ~F[(A, B)]~    |
| ~Unzip~            | ~unzip~         | ~F[(A, B)]~     |                        | ~(F[A], F[B])~ |
| ~Cozip~            | ~cozip~         | ~F[A \/ B]~     |                        | ~F[A] \/ F[B]~ |
| ~Foldable~         | ~foldMap~       | ~F[A]~          | ~A => B~               | ~B~            |
|                    | ~foldMapM~      | ~F[A]~          | ~A => G[B]~            | ~G[B]~         |
| ~Traverse~         | ~traverse~      | ~F[A]~          | ~A => G[B]~            | ~G[F[B]]~      |
|                    | ~sequence~      | ~F[G[A]]~       |                        | ~G[F[A]]~      |
| ~Equal~            | ~equal~ / ~===~ | ~A, A~          |                        | ~Boolean~      |
| ~Show~             | ~shows~         | ~A~             |                        | ~String~       |
| ~Bifunctor~        | ~bimap~         | ~F[A, B]~       | ~A => C, B => D~       | ~F[C, D]~      |
|                    | ~leftMap~       | ~F[A, B]~       | ~A => C~               | ~F[C, B]~      |
|                    | ~rightMap~      | ~F[A, B]~       | ~B => C~               | ~F[A, C]~      |
| ~Bifoldable~       | ~bifoldMap~     | ~F[A, B]~       | ~A => C, B => C~       | ~C~            |
| (with ~MonadPlus~) | ~separate~      | ~F[G[A, B]]~    |                        | ~(F[A], F[B])~ |
| ~Bitraverse~       | ~bitraverse~    | ~F[A, B]~       | ~A => G[C], B => G[D]~ | ~G[F[C, D]]~   |
|                    | ~bisequence~    | ~F[G[A], G[B]]~ |                        | ~G[F[A, B]]~   |

# https://emacs.stackexchange.com/questions/36029

** Third Party Licenses

Some of the source code in this book has been copied from free / libre
software projects. The license of those projects require that the
following texts are distributed with the source that is presented in
this book.

*** Scala License

#+BEGIN_SRC
Copyright (c) 2002-2017 EPFL
Copyright (c) 2011-2017 Lightbend, Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  * Neither the name of the EPFL nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#+END_SRC

*** Scalaz License

#+BEGIN_SRC
Copyright (c) 2009-2014 Tony Morris, Runar Bjarnason, Tom Adams,
                        Kristian Domagala, Brad Clow, Ricky Clarkson,
                        Paul Chiusano, Trygve Laugstøl, Nick Partridge,
                        Jason Zaugg
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of
   its contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#+END_SRC

*** =spray-json= License

=spray-json= is released under the [[http://www.apache.org/licenses/LICENSE-2.0][Apache 2.0]] and the following =NOTICE=

#+BEGIN_SRC
Copyright (C) 2009-2011 Mathias Doenitz
Inspired by a similar implementation by Nathan Hamblen
(https://github.com/dispatch/classic)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#+END_SRC

# `whitespace-style: (face trailing tabs lines-tail)' is too noisy
# Local Variables:
# whitespace-line-column: 82
# End:
